<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>算法基础 - 树 · KLEON</title><meta name="description" content="树是常用的数据结构，应用较多的有二叉搜索树，二叉平衡搜索树(AVL树)，红黑树，多路平衡搜索树(B-树，B+树，B*树)等。

# 基础
树可由链式结构或数组实现，遍历方式为前、中、后、层序遍历。
12345type TreeNode struct &amp;#123;  Val   int  Left  "><meta name="og:description" content="树是常用的数据结构，应用较多的有二叉搜索树，二叉平衡搜索树(AVL树)，红黑树，多路平衡搜索树(B-树，B+树，B*树)等。

# 基础
树可由链式结构或数组实现，遍历方式为前、中、后、层序遍历。
12345type TreeNode struct &amp;#123;  Val   int  Left  "><meta name="twitter:site" content="KLEON"><meta name="twitter:title" content="算法基础 - 树"><meta name="twitter:card" content="summary"><meta name="keywords" content=""><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/github.min.css"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.10.2/katex.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 6.1.0"></head><body><div id="stage" class="container"><div class="row"><div id="side-bar" class="col-sm-3 col-xs-12 side-container invisible"><div class="vertical-text site-title"><h3 tabindex="-1" class="site-title-small"><a href="/" class="a-title"></a></h3><h1 tabindex="-1" class="site-title-large"><a href="/" class="a-title">吹拉弹唱</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div id="site-nav" class="site-title-links"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li><li><a href="/categories">Categories</a></li><li><a href="/tags">Tags</a></li><li><a href="/googlebe23cb0bc55fc412.html"></a></li><li><a href="/about/index.html"></a></li><li class="soc"><a href="https://github.com/kleon1024" target="_blank" rel="noopener noreferrer" aria-label="Github"><i class="fa fa-github">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2022&nbsp;<a target="_blank" href="https://blog.kleon.space" rel="noopener noreferrer">Kleon</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div id="main-container" class="col-sm-9 col-xs-12 main-container invisible"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>算法基础 - 树</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2021-03-14</span><span class="date meta-item">Updated at&nbsp;2021-03-25</span><span class="meta-item"><i class="fa fa-folder"></i><span>&nbsp;</span><a href="/categories/算法/" title="算法" class="a-tag">算法</a><span>&nbsp;</span></span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a href="/tags/算法/" title="算法" class="a-tag">算法</a><span>&nbsp;</span><a href="/tags/数据结构/" title="数据结构" class="a-tag">数据结构</a><span>&nbsp;</span></span></p><p class="post-abstract"><p>树是常用的数据结构，应用较多的有二叉搜索树，二叉平衡搜索树(AVL树)，红黑树，多路平衡搜索树(B-树，B+树，B*树)等。</p>
<span id="more"></span>
<h1><a href="#ji-chu" class="header-anchor">#</a><span id="ji-chu"> 基础</span></h1>
<p>树可由链式结构或数组实现，遍历方式为前、中、后、层序遍历。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TreeNode <span class="hljs-keyword">struct</span> &#123;<br>  Val   <span class="hljs-type">int</span><br>  Left  *TreeNode<br>  Right *TreeNode<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#shu" class="header-anchor">#</a><span id="shu"> 树</span></h2>
<p>有向无环非线性数据结构，每个节点可以指向多个节点，但至多有一个节点指向自身。</p>
<h2><a href="#er-cha-shu" class="header-anchor">#</a><span id="er-cha-shu"> 二叉树</span></h2>
<p>每个节点至多只能指向两个节点。</p>
<h2><a href="#man-er-cha-shu" class="header-anchor">#</a><span id="man-er-cha-shu"> 满二叉树</span></h2>
<p>只有度为0和2的节点，并且度为0的节点在同一层上。</p>
<h2><a href="#wan-quan-er-cha-shu" class="header-anchor">#</a><span id="wan-quan-er-cha-shu"> 完全二叉树</span></h2>
<p>除了最底层节点可能没填满外，其余层节点数均达到最大值，并且最下面一层的节点应集中在最左侧。</p>
<h2><a href="#er-cha-sou-suo-shu" class="header-anchor">#</a><span id="er-cha-sou-suo-shu"> 二叉搜索树</span></h2>
<p>一种朴素的有序树结构，左子节点均小于父节点，右子节点均大于父节点。当插入新值时由根节点开始按以上规则逐层比较，直到找到合适的叶节点位置。</p>
<ul>
<li>优点：不需要在插入数据时调整结构</li>
<li>缺点：性能易受数据插入顺序影响，最差情况为顺序插入，退化为链表。</li>
</ul>
<h2><a href="#ping-heng-er-cha-sou-suo-shu-avl-shu" class="header-anchor">#</a><span id="ping-heng-er-cha-sou-suo-shu-avl-shu"> 平衡二叉搜索树(AVL树)</span></h2>
<p>二叉搜索树的改进，又称AVL(Adelson-Velsky and Landis)树，引入平衡因子，通过旋转操作保证所有子树高度差不超过1。</p>
<ul>
<li>优点：相比二叉树更平衡，极端情况下表现依然足够好。</li>
<li>缺点：在读写比例差不多的情况下，旋转操作过多。</li>
</ul>
<h2><a href="#hong-hei-shu-rb-shu" class="header-anchor">#</a><span id="hong-hei-shu-rb-shu"> 红黑树(RB树)</span></h2>
<p>AVL树的改进，引入着色规则，通过旋转和着色操作保证所有子树高度差不超过2。Map可以通过红黑树实现。</p>
<ul>
<li>优点：写性能更高。</li>
<li>缺点：查询性能弱于AVL树，因为子树高度差比AVL多一层，最差情况会多一次比较。</li>
</ul>
<h2><a href="#b-shu-b-tree-b-shu" class="header-anchor">#</a><span id="b-shu-b-tree-b-shu"> B-树(B-Tree, B树)</span></h2>
<p>多路搜索树，又称B树，用于数据索引，子节点内放指针和数据块。通过分裂操作维持树结构。</p>
<h2><a href="#b-shu" class="header-anchor">#</a><span id="b-shu"> B+树</span></h2>
<p>B-树改进型，子节点内不放数据块，统一放在叶节点内。查询性能稳定，IO数据利用率高。</p>
<h2><a href="#b-shu" class="header-anchor">#</a><span id="b-shu"> B*树</span></h2>
<p>B+树改进型，增加子节点间指针，如果兄弟节点数据未满，则将一部分指针移到兄弟节点，并修改父节点关键字，将结点的最低利用率从1/2提高到2/3。</p>
<h1><a href="#shi-jian" class="header-anchor">#</a><span id="shi-jian"> 实践</span></h1>
<h2><a href="#er-cha-shu-de-qian-xu-bian-li" class="header-anchor">#</a><span id="er-cha-shu-de-qian-xu-bian-li"> 二叉树的前序遍历</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-144-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">二叉树的前序遍历</a></p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">traverse</span><span class="hljs-params">(n *TreeNode, result *[]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> &#125;<br>    *result = <span class="hljs-built_in">append</span>(*result, n.Val)<br>    traverse(n.Left, result)<br>    traverse(n.Right, result)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    result := []<span class="hljs-type">int</span>&#123;&#125;<br>    traverse(root, &amp;result)<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br><br><span class="hljs-comment">//</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    result := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> result &#125;<br>    result = <span class="hljs-built_in">append</span>(result, root.Val)<br>    result = <span class="hljs-built_in">append</span>(result, preorderTraversal(root.Left)...)<br>    result = <span class="hljs-built_in">append</span>(result, preorderTraversal(root.Right)...)<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>迭代</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    stack := []*TreeNode&#123;&#125;<br>    result := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root != <span class="hljs-literal">nil</span> &#123;<br>        stack = <span class="hljs-built_in">append</span>(stack, root)<br>    &#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack) &gt; <span class="hljs-number">0</span> &#123;<br>        node := stack[<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>        stack = stack[:<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> node != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                stack = <span class="hljs-built_in">append</span>(stack, node.Right)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                stack = <span class="hljs-built_in">append</span>(stack, node.Left)<br>            &#125;<br>            stack = <span class="hljs-built_in">append</span>(stack, node)<br>            stack = <span class="hljs-built_in">append</span>(stack, <span class="hljs-literal">nil</span>)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            node = stack[<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>            stack = stack[:<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>            result = <span class="hljs-built_in">append</span>(result, node.Val)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#er-cha-shu-de-hou-xu-bian-li" class="header-anchor">#</a><span id="er-cha-shu-de-hou-xu-bian-li"> 二叉树的后序遍历</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-145-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">二叉树的后序遍历</a></p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    result := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> result &#125;<br>    result = <span class="hljs-built_in">append</span>(result, postorderTraversal(root.Left)...)<br>    result = <span class="hljs-built_in">append</span>(result, postorderTraversal(root.Right)...)<br>    result = <span class="hljs-built_in">append</span>(result, root.Val)<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>迭代</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    stack := []*TreeNode&#123;&#125;<br>    result := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root != <span class="hljs-literal">nil</span> &#123;<br>        stack = <span class="hljs-built_in">append</span>(stack, root)<br>    &#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack) &gt; <span class="hljs-number">0</span> &#123;<br>        node := stack[<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>        stack = stack[:<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> node != <span class="hljs-literal">nil</span> &#123;<br>            stack = <span class="hljs-built_in">append</span>(stack, node)<br>            stack = <span class="hljs-built_in">append</span>(stack, <span class="hljs-literal">nil</span>)<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                stack = <span class="hljs-built_in">append</span>(stack, node.Right)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                stack = <span class="hljs-built_in">append</span>(stack, node.Left)<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            node = stack[<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>            stack = stack[:<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>            result = <span class="hljs-built_in">append</span>(result, node.Val)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#er-cha-shu-de-zhong-xu-bian-li" class="header-anchor">#</a><span id="er-cha-shu-de-zhong-xu-bian-li"> 二叉树的中序遍历</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-94-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">二叉树的中序遍历</a></p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    result := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> result &#125;<br>    result = <span class="hljs-built_in">append</span>(result, inorderTraversal(root.Left)...)<br>    result = <span class="hljs-built_in">append</span>(result, root.Val)<br>    result = <span class="hljs-built_in">append</span>(result, inorderTraversal(root.Right)...)<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>迭代</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    stack := []*TreeNode&#123;&#125;<br>    result := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root != <span class="hljs-literal">nil</span> &#123;<br>        stack = <span class="hljs-built_in">append</span>(stack, root)<br>    &#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack) &gt; <span class="hljs-number">0</span> &#123;<br>        node := stack[<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>        stack = stack[:<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> node != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                stack = <span class="hljs-built_in">append</span>(stack, node.Right)<br>            &#125;<br>            stack = <span class="hljs-built_in">append</span>(stack, node)<br>            stack = <span class="hljs-built_in">append</span>(stack, <span class="hljs-literal">nil</span>)<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                stack = <span class="hljs-built_in">append</span>(stack, node.Left)<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            node = stack[<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>            stack = stack[:<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>            result = <span class="hljs-built_in">append</span>(result, node.Val)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>
<p>C++ 版本</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preorder</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt;&amp; v)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>    <br>    v.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>    <span class="hljs-built_in">preorder</span>(root-&gt;left, v);<br>    <span class="hljs-built_in">preorder</span>(root-&gt;right, v);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postorder</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt;&amp; v)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-built_in">postorder</span>(root-&gt;left, v);<br>    <span class="hljs-built_in">postorder</span>(root-&gt;right, v);<br>    v.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">midorder</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt;&amp; v)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-built_in">midorder</span>(root-&gt;left, v);<br>    v.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>    <span class="hljs-built_in">midorder</span>(root-&gt;right, v);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preorderIter</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt;&amp; v)</span> </span>&#123;<br>    std::stack&lt;TreeNode*&gt; s;<br>    <br>    <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">nullptr</span>) &#123;<br>        s.<span class="hljs-built_in">push</span>(root);<br>    &#125;<br>    <br>    TreeNode* node = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">while</span>(s.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<br>        node = s.<span class="hljs-built_in">top</span>();<br>        s.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (node) &#123;<br>            <span class="hljs-keyword">if</span> (node-&gt;right) &#123;<br>                s.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (node-&gt;left) &#123;<br>                s.<span class="hljs-built_in">push</span>(node-&gt;left);<br>            &#125;<br>            s.<span class="hljs-built_in">push</span>(node);<br>            s.<span class="hljs-built_in">push</span>(<span class="hljs-literal">nullptr</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            node = s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            v.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postorderIter</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt;&amp; v)</span> </span>&#123;<br>    std::stack&lt;TreeNode*&gt; s;<br>    <br>    <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">nullptr</span>) &#123;<br>        s.<span class="hljs-built_in">push</span>(root);<br>    &#125;<br>    <br>    TreeNode* node = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">while</span>(s.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<br>        node = s.<span class="hljs-built_in">top</span>();<br>        s.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (node) &#123;<br>            s.<span class="hljs-built_in">push</span>(node);<br>            s.<span class="hljs-built_in">push</span>(<span class="hljs-literal">nullptr</span>);<br>            <span class="hljs-keyword">if</span> (node-&gt;right) &#123;<br>                s.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (node-&gt;left) &#123;<br>                s.<span class="hljs-built_in">push</span>(node-&gt;left);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            node = s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            v.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorderIter</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt;&amp; v)</span> </span>&#123;<br>    std::stack&lt;TreeNode*&gt; s;<br>    <br>    <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">nullptr</span>) &#123;<br>        s.<span class="hljs-built_in">push</span>(root);<br>    &#125;<br>    <br>    TreeNode* node = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">while</span>(s.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<br>        node = s.<span class="hljs-built_in">top</span>();<br>        s.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (node) &#123;<br>            <span class="hljs-keyword">if</span> (node-&gt;right) &#123;<br>                s.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>            s.<span class="hljs-built_in">push</span>(node);<br>            s.<span class="hljs-built_in">push</span>(<span class="hljs-literal">nullptr</span>);<br>            <span class="hljs-keyword">if</span> (node-&gt;left) &#123;<br>                s.<span class="hljs-built_in">push</span>(node-&gt;left);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            node = s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            v.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#er-cha-shu-de-ceng-xu-bian-li" class="header-anchor">#</a><span id="er-cha-shu-de-ceng-xu-bian-li"> 二叉树的层序遍历</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-102-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">二叉树的层序遍历</a></p>
<ul>
<li>队列先进先出</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(root *TreeNode)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    queue := []*TreeNode&#123;&#125;<br>    result := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root != <span class="hljs-literal">nil</span> &#123;<br>        queue = <span class="hljs-built_in">append</span>(queue, root)<br>    &#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        size := <span class="hljs-built_in">len</span>(queue)<br>        vec := []<span class="hljs-type">int</span>&#123;&#125;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>            node := queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:]<br>            vec = <span class="hljs-built_in">append</span>(vec, node.Val)<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Right)<br>            &#125;<br>        &#125;<br>        result = <span class="hljs-built_in">append</span>(result, vec)<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#er-cha-shu-de-ceng-xu-bian-li-ii" class="header-anchor">#</a><span id="er-cha-shu-de-ceng-xu-bian-li-ii"> 二叉树的层序遍历II</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-107-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">二叉树的层序遍历II</a></p>
<ul>
<li>同二叉树的层序遍历</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">levelOrderBottom</span><span class="hljs-params">(root *TreeNode)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    queue := []*TreeNode&#123;&#125;<br>    result := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root != <span class="hljs-literal">nil</span> &#123;<br>        queue = <span class="hljs-built_in">append</span>(queue, root)<br>    &#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        size := <span class="hljs-built_in">len</span>(queue)<br>        vec := []<span class="hljs-type">int</span>&#123;&#125;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>            node := queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:]<br>            vec = <span class="hljs-built_in">append</span>(vec, node.Val)<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Right)<br>            &#125;<br>        &#125;<br>        result = <span class="hljs-built_in">append</span>(result, vec)<br>    &#125;<br>    <span class="hljs-keyword">for</span> i, j := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(result)<span class="hljs-number">-1</span>; i &lt; j; i, j = i+<span class="hljs-number">1</span>, j<span class="hljs-number">-1</span> &#123;<br>        result[i], result[j] = result[j], result[i]<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#ceng-xu-bian-li-huo-qu-er-cha-shu-de-you-shi-tu" class="header-anchor">#</a><span id="ceng-xu-bian-li-huo-qu-er-cha-shu-de-you-shi-tu"> 层序遍历获取二叉树的右视图</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-199-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-right-side-view/">二叉树的右视图</a></p>
<ul>
<li>同二叉树的层序遍历</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rightSideView</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    queue := []*TreeNode&#123;&#125;<br>    result := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root != <span class="hljs-literal">nil</span> &#123;<br>        queue = <span class="hljs-built_in">append</span>(queue, root)<br>    &#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        size := <span class="hljs-built_in">len</span>(queue)<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>            node := queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:]<br>            <span class="hljs-keyword">if</span> i == size - <span class="hljs-number">1</span> &#123;<br>                result = <span class="hljs-built_in">append</span>(result, node.Val)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Right)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#ceng-xu-bian-li-huo-qu-er-cha-shu-de-ceng-ping-jun-zhi" class="header-anchor">#</a><span id="ceng-xu-bian-li-huo-qu-er-cha-shu-de-ceng-ping-jun-zhi"> 层序遍历获取二叉树的层平均值</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-637-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/">二叉树的层平均值</a></p>
<ul>
<li>同二叉树的层序遍历</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">averageOfLevels</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">float64</span> &#123;<br>    result := []<span class="hljs-type">float64</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> result<br>    &#125;<br>    queue := list.New()<br>    queue.PushBack(root)<br>    <span class="hljs-keyword">for</span> queue.Len() &gt; <span class="hljs-number">0</span> &#123;<br>        size := queue.Len()<br>        sum := <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>            node := queue.Front()<br>            queue.Remove(node)<br>            t := node.Value.(*TreeNode)<br>            sum += t.Val<br>            <span class="hljs-keyword">if</span> t.Left != <span class="hljs-literal">nil</span> &#123;<br>                queue.PushBack(t.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> t.Right != <span class="hljs-literal">nil</span> &#123;<br>                queue.PushBack(t.Right)<br>            &#125;<br>        &#125;<br>        result = <span class="hljs-built_in">append</span>(result, <span class="hljs-type">float64</span>(sum) / <span class="hljs-type">float64</span>(size))<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#ceng-xu-bian-li-huo-qu-n-cha-shu-de-ceng-xu-bian-li" class="header-anchor">#</a><span id="ceng-xu-bian-li-huo-qu-n-cha-shu-de-ceng-xu-bian-li"> 层序遍历获取N叉树的层序遍历</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-429-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/">N叉树的层序遍历</a></p>
<ul>
<li>同二叉树的层序遍历</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a Node.</span><br><span class="hljs-comment"> * type Node struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Children []*Node</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(root *Node)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    queue := []*Node&#123;&#125;<br>    result := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root != <span class="hljs-literal">nil</span> &#123;<br>        queue = <span class="hljs-built_in">append</span>(queue, root)<br>    &#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        size := <span class="hljs-built_in">len</span>(queue)<br>        vec := []<span class="hljs-type">int</span>&#123;&#125;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>            node := queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:]<br>            vec = <span class="hljs-built_in">append</span>(vec, node.Val)<br>            <span class="hljs-keyword">for</span> _, n := <span class="hljs-keyword">range</span> node.Children &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, n)<br>            &#125;<br>        &#125;<br>        result = <span class="hljs-built_in">append</span>(result, vec)<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#qian-xu-bian-li-er-cha-shu-zhan-kai-wei-lian-biao" class="header-anchor">#</a><span id="qian-xu-bian-li-er-cha-shu-zhan-kai-wei-lian-biao"> 前序遍历二叉树展开为链表</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-114-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">二叉树展开为链表</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">flatten</span><span class="hljs-params">(root *TreeNode)</span></span>  &#123;<br>    stack := []*TreeNode&#123;&#125;<br>    list := []*TreeNode&#123;&#125;<br>    node := root<br>    <span class="hljs-keyword">for</span> node != <span class="hljs-literal">nil</span> || <span class="hljs-built_in">len</span>(stack) &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">for</span> node != <span class="hljs-literal">nil</span> &#123;<br>            list = <span class="hljs-built_in">append</span>(list, node)<br>            stack = <span class="hljs-built_in">append</span>(stack, node)<br>            node = node.Left<br>        &#125;<br>        node = stack[<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>        node = node.Right<br>        stack = stack[:<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(list); i++ &#123;<br>        prev, curr := list[i<span class="hljs-number">-1</span>], list[i]<br>        prev.Left, prev.Right = <span class="hljs-literal">nil</span>, curr<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h2><a href="#fan-zhuan-er-cha-shu" class="header-anchor">#</a><span id="fan-zhuan-er-cha-shu"> 翻转二叉树</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-226-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/invert-binary-tree/">翻转二叉树</a></p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">invertTree</span><span class="hljs-params">(root *TreeNode)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> root<br>    &#125;<br>    root.Left, root.Right = root.Right, root.Left<br>    invertTree(root.Left)<br>    invertTree(root.Right)<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>迭代</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">invertTree</span><span class="hljs-params">(root *TreeNode)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> root<br>    &#125;<br>    stack := []*TreeNode&#123;&#125;<br>    stack = <span class="hljs-built_in">append</span>(stack, root)<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack) &gt; <span class="hljs-number">0</span> &#123;<br>        node := stack[<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>        stack = stack[:<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>        node.Left, node.Right = node.Right, node.Left<br>        <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>            stack = <span class="hljs-built_in">append</span>(stack, node.Right)<br>        &#125;<br>        <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>            stack = <span class="hljs-built_in">append</span>(stack, node.Left)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>层序</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">invertTree</span><span class="hljs-params">(root *TreeNode)</span></span> *TreeNode &#123;<br>    queue := []*TreeNode&#123;&#125;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> root<br>    &#125;<br>    queue = <span class="hljs-built_in">append</span>(queue, root)<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        size := <span class="hljs-built_in">len</span>(queue)<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>            node := queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:]<br>            node.Left, node.Right = node.Right, node.Left<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Right)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#dui-cheng-er-cha-shu" class="header-anchor">#</a><span id="dui-cheng-er-cha-shu"> 对称二叉树</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-101-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/symmetric-tree/">对称二叉树</a></p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">compare</span><span class="hljs-params">(left *TreeNode, right *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> right != <span class="hljs-literal">nil</span> &amp;&amp; left == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>    <span class="hljs-keyword">if</span> right == <span class="hljs-literal">nil</span> &amp;&amp; left != <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>    <span class="hljs-keyword">if</span> right == <span class="hljs-literal">nil</span> &amp;&amp; left == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125;<br>    <span class="hljs-keyword">if</span> right.Val != left.Val &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br><br>    outside := compare(left.Left, right.Right)<br>    inside := compare(left.Right, right.Left)<br>    <span class="hljs-keyword">return</span> outside &amp;&amp; inside<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125;<br>    <span class="hljs-keyword">return</span> compare(root.Left, root.Right)<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>迭代，队列和栈均可</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125;<br>    queue := []*TreeNode&#123;&#125;<br>    queue = <span class="hljs-built_in">append</span>(queue, root.Left)<br>    queue = <span class="hljs-built_in">append</span>(queue, root.Right)<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        left := queue[<span class="hljs-number">0</span>]; queue = queue[<span class="hljs-number">1</span>:]<br>        right := queue[<span class="hljs-number">0</span>]; queue = queue[<span class="hljs-number">1</span>:]<br>        <span class="hljs-keyword">if</span> left == <span class="hljs-literal">nil</span> &amp;&amp; right == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> left == <span class="hljs-literal">nil</span> || right == <span class="hljs-literal">nil</span> || left.Val != right.Val &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>        queue = <span class="hljs-built_in">append</span>(queue, left.Left)<br>        queue = <span class="hljs-built_in">append</span>(queue, right.Right)<br>        queue = <span class="hljs-built_in">append</span>(queue, left.Right)<br>        queue = <span class="hljs-built_in">append</span>(queue, right.Left)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#er-cha-shu-de-zui-da-shen-du" class="header-anchor">#</a><span id="er-cha-shu-de-zui-da-shen-du"> 二叉树的最大深度</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-104-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">二叉树的最大深度</a></p>
<ul>
<li>后序遍历</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Max</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> x &lt; y &#123; <span class="hljs-keyword">return</span> y &#125;<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">depth</span><span class="hljs-params">(node *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + Max(depth(node.Left), depth(node.Right))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> depth(root)<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>层序遍历</li>
</ul>
<h2><a href="#n-cha-shu-de-zui-da-shen-du" class="header-anchor">#</a><span id="n-cha-shu-de-zui-da-shen-du"> N叉树的最大深度</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-104-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/">N叉树的最大深度</a></p>
<ul>
<li>迭代，同二叉树</li>
<li>层序遍历</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a Node.</span><br><span class="hljs-comment"> * type Node struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Children []*Node</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(root *Node)</span></span> <span class="hljs-type">int</span> &#123;<br>    queue := []*Node&#123;&#125;<br>    depth := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> depth &#125;<br>    queue = <span class="hljs-built_in">append</span>(queue, root)<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        size := <span class="hljs-built_in">len</span>(queue)<br>        depth++<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>            node := queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:]<br>            <span class="hljs-keyword">for</span> _, n := <span class="hljs-keyword">range</span> node.Children &#123;<br>                <span class="hljs-keyword">if</span> n != <span class="hljs-literal">nil</span> &#123;<br>                    queue = <span class="hljs-built_in">append</span>(queue, n)<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> depth<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#er-cha-shu-de-zui-xiao-shen-du" class="header-anchor">#</a><span id="er-cha-shu-de-zui-xiao-shen-du"> 二叉树的最小深度</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-111-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">二叉树的最小深度</a></p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Min</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> x &gt; y &#123; <span class="hljs-keyword">return</span> y &#125;<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">depth</span><span class="hljs-params">(node *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> &#125;<br>    leftDepth := depth(node.Left)<br>    rightDepth := depth(node.Right)<br><br>    <span class="hljs-keyword">if</span> node.Left == <span class="hljs-literal">nil</span> &amp;&amp; node.Right != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + rightDepth<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> node.Right == <span class="hljs-literal">nil</span> &amp;&amp; node.Left != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + leftDepth<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + Min(leftDepth, rightDepth)<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> depth(root)<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>层序遍历</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    queue := []*TreeNode&#123;&#125;<br>    depth := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> depth &#125;<br>    queue = <span class="hljs-built_in">append</span>(queue, root)<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        size := <span class="hljs-built_in">len</span>(queue)<br>        depth++<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>            node := queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:]<br>            <span class="hljs-keyword">if</span> node.Left == <span class="hljs-literal">nil</span> &amp;&amp; node.Right == <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-keyword">return</span> depth<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Right)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> depth<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#wan-quan-er-cha-shu-de-jie-dian-shu" class="header-anchor">#</a><span id="wan-quan-er-cha-shu-de-jie-dian-shu"> 完全二叉树的节点数</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-222-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-complete-tree-nodes/">完全二叉树的节点个数</a></p>
<ul>
<li>前序遍历递归</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">nodeNum</span><span class="hljs-params">(node *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + nodeNum(node.Left) + nodeNum(node.Right)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> nodeNum(root)<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>层序遍历迭代</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    queue := []*TreeNode&#123;&#125;<br>    count := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> count &#125;<br>    queue = <span class="hljs-built_in">append</span>(queue, root)<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        size := <span class="hljs-built_in">len</span>(queue)<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>            node := queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:]<br>            count++<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Right)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#ping-heng-er-cha-shu" class="header-anchor">#</a><span id="ping-heng-er-cha-shu"> 平衡二叉树</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-110-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/balanced-binary-tree/">平衡二叉树</a></p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Max</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> x &gt; y &#123; <span class="hljs-keyword">return</span> x &#125;<br>    <span class="hljs-keyword">return</span> y<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">depth</span><span class="hljs-params">(node *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> &#125;<br>    leftDepth := depth(node.Left)<br>    <span class="hljs-keyword">if</span> leftDepth &lt; <span class="hljs-number">0</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span> &#125;<br>    rightDepth := depth(node.Right)<br>    <span class="hljs-keyword">if</span> rightDepth &lt; <span class="hljs-number">0</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span> &#125;<br>    <span class="hljs-keyword">if</span> math.Abs(<span class="hljs-type">float64</span>(leftDepth) - <span class="hljs-type">float64</span>(rightDepth)) &gt; <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + Max(leftDepth, rightDepth)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> depth(root) &gt;= <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#er-cha-shu-de-suo-you-lu-jing" class="header-anchor">#</a><span id="er-cha-shu-de-suo-you-lu-jing"> 二叉树的所有路径</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-257-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-paths/">二叉树的所有路径</a></p>
<ul>
<li>前序遍历递归</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">path</span><span class="hljs-params">(node *TreeNode, pathStr <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>    results := []<span class="hljs-type">string</span>&#123;&#125;<br>    pathStr += strconv.Itoa(node.Val)<br>    <span class="hljs-keyword">if</span> node.Left == <span class="hljs-literal">nil</span> &amp;&amp; node.Right == <span class="hljs-literal">nil</span> &#123;<br>        results = <span class="hljs-built_in">append</span>(results, pathStr)<br>    &#125;<br>    pathStr += <span class="hljs-string">&quot;-&gt;&quot;</span><br>    <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>        results = <span class="hljs-built_in">append</span>(results, path(node.Left, pathStr)...)<br>    &#125;<br>    <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>        results = <span class="hljs-built_in">append</span>(results, path(node.Right, pathStr)...)<br>    &#125;<br>    <span class="hljs-keyword">return</span> results<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> []<span class="hljs-type">string</span>&#123;&#125; &#125;<br>    <span class="hljs-keyword">return</span> path(root, <span class="hljs-string">&quot;&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#xiang-tong-de-shu" class="header-anchor">#</a><span id="xiang-tong-de-shu"> 相同的树</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-100-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/same-tree/">相同的树</a></p>
<ul>
<li>递归，同对称树</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isSameTree</span><span class="hljs-params">(p *TreeNode, q *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> p != <span class="hljs-literal">nil</span> &amp;&amp; q == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>    <span class="hljs-keyword">if</span> p == <span class="hljs-literal">nil</span> &amp;&amp; q != <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>    <span class="hljs-keyword">if</span> p == <span class="hljs-literal">nil</span> &amp;&amp; q == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125;<br>    <span class="hljs-keyword">if</span> p.Val != q.Val &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br><br>    left := isSameTree(p.Left, q.Left)<br>    right := isSameTree(p.Right, q.Right)<br>    <span class="hljs-keyword">return</span> left &amp;&amp; right<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>迭代，队列和栈均可，同对称树</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isSameTree</span><span class="hljs-params">(p *TreeNode, q *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    queue := []*TreeNode&#123;&#125;<br>    queue = <span class="hljs-built_in">append</span>(queue, p)<br>    queue = <span class="hljs-built_in">append</span>(queue, q)<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        left := queue[<span class="hljs-number">0</span>]; queue = queue[<span class="hljs-number">1</span>:]<br>        right := queue[<span class="hljs-number">0</span>]; queue = queue[<span class="hljs-number">1</span>:]<br>        <span class="hljs-keyword">if</span> left == <span class="hljs-literal">nil</span> &amp;&amp; right == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> left == <span class="hljs-literal">nil</span> || right == <span class="hljs-literal">nil</span> || left.Val != right.Val &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>        queue = <span class="hljs-built_in">append</span>(queue, left.Left)<br>        queue = <span class="hljs-built_in">append</span>(queue, right.Left)<br>        queue = <span class="hljs-built_in">append</span>(queue, left.Right)<br>        queue = <span class="hljs-built_in">append</span>(queue, right.Right)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#zuo-xie-zi-zhi-he" class="header-anchor">#</a><span id="zuo-xie-zi-zhi-he"> 左叶子之和</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-404-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-of-left-leaves/">左叶子之和</a></p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sumOfLeftLeaves</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> &#125;<br>    sum := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> root.Left != <span class="hljs-literal">nil</span> &amp;&amp; root.Left.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Left.Right == <span class="hljs-literal">nil</span> &#123;<br>        sum = root.Left.Val<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum + sumOfLeftLeaves(root.Left) + sumOfLeftLeaves(root.Right)<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#zhao-shu-zuo-xia-jiao-de-zhi" class="header-anchor">#</a><span id="zhao-shu-zuo-xia-jiao-de-zhi"> 找树左下角的值</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-513-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/">找树左下角的值</a></p>
<ul>
<li>层序遍历</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    queue := []*TreeNode&#123;root&#125;<br>    result := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        size := <span class="hljs-built_in">len</span>(queue)<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>            node := queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:]<br>            <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123; result = node.Val &#125;<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Right)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#lu-jing-zong-he" class="header-anchor">#</a><span id="lu-jing-zong-he"> 路径总和</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-112-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum/">路径总和</a></p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(root *TreeNode, targetSum <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &amp;&amp; root.Val == targetSum &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    nextSum := targetSum - root.Val<br>    <span class="hljs-keyword">return</span> hasPathSum(root.Left, nextSum) || hasPathSum(root.Right, nextSum)<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#lu-jing-zong-he-ii" class="header-anchor">#</a><span id="lu-jing-zong-he-ii"> 路径总和II</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-113-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-ii/">路径总和II</a></p>
<ul>
<li>递归，注意Go的引用</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">traverse</span><span class="hljs-params">(root *TreeNode, targetSum <span class="hljs-type">int</span>, res *[][]<span class="hljs-type">int</span>, path[]<span class="hljs-type">int</span>)</span></span> &#123;<br>    path = <span class="hljs-built_in">append</span>(path, root.Val)<br>    nextSum := targetSum - root.Val<br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> nextSum == <span class="hljs-number">0</span> &#123;<br>            tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(path))<br>            <span class="hljs-built_in">copy</span>(tmp, path)<br>            *res = <span class="hljs-built_in">append</span>(*res, tmp)<br>        &#125;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> root.Left != <span class="hljs-literal">nil</span> &#123;<br>        traverse(root.Left, nextSum, res, path)<br>    &#125;<br>    <span class="hljs-keyword">if</span> root.Right != <span class="hljs-literal">nil</span> &#123;<br>        traverse(root.Right, nextSum, res, path)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(root *TreeNode, targetSum <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    result := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    path := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> result &#125;<br>    traverse(root, targetSum, &amp;result, path)<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#cong-zhong-xu-yu-hou-xu-bian-li-xu-lie-gou-zao-er-cha-shu" class="header-anchor">#</a><span id="cong-zhong-xu-yu-hou-xu-bian-li-xu-lie-gou-zao-er-cha-shu"> 从中序与后序遍历序列构造二叉树</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-106-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">从中序与后序遍历序列构造二叉树</a></p>
<ul>
<li>先取后序遍历最后一个值作为当前根节点，从中序遍历比对确定左右子树切割位置，后序遍历子树大小应和中序遍历数组子序列一致，将切分出的左右子序列递归。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">type</span> TreeBuilder <span class="hljs-keyword">struct</span> &#123;<br>    inorder []<span class="hljs-type">int</span><br>    postorder []<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t TreeBuilder)</span></span>traverse(inStart, inEnd, poStart, poEnd <span class="hljs-type">int</span>) *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> poStart == poEnd &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> &#125;<br>    rootVal := t.postorder[poEnd - <span class="hljs-number">1</span>]<br>    root := &amp;TreeNode&#123;Val: rootVal&#125;<br>    <span class="hljs-keyword">if</span> poEnd - poStart == <span class="hljs-number">1</span> &#123; <span class="hljs-keyword">return</span> root &#125;<br><br>    <span class="hljs-keyword">var</span> inMid <span class="hljs-type">int</span><br>    <span class="hljs-keyword">for</span> inMid = inStart; inMid &lt; inEnd; inMid++ &#123;<br>        <span class="hljs-keyword">if</span> t.inorder[inMid] == rootVal &#123; <span class="hljs-keyword">break</span> &#125;<br>    &#125;<br><br>    poMid := poStart + inMid - inStart<br>    root.Left = t.traverse(inStart, inMid, poStart, poMid)<br>    root.Right = t.traverse(inMid + <span class="hljs-number">1</span>, inEnd, poMid, poEnd - <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(inorder []<span class="hljs-type">int</span>, postorder []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">return</span> TreeBuilder&#123;inorder, postorder&#125;.traverse(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(inorder), <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(postorder))<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#cong-zhong-xu-yu-qian-xu-bian-li-xu-lie-gou-zao-er-cha-shu" class="header-anchor">#</a><span id="cong-zhong-xu-yu-qian-xu-bian-li-xu-lie-gou-zao-er-cha-shu"> 从中序与前序遍历序列构造二叉树</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-105-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">从中序与前序遍历序列构造二叉树</a></p>
<ul>
<li>类似后序+中序</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">type</span> TreeBuilder <span class="hljs-keyword">struct</span> &#123;<br>    inorder []<span class="hljs-type">int</span><br>    preorder []<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t TreeBuilder)</span></span>traverse(inStart, inEnd, prStart, prEnd <span class="hljs-type">int</span>) *TreeNode &#123;<br>    <span class="hljs-comment">// fmt.Printf(&quot;%v %v | %v %v \n&quot;, inStart, inEnd, prStart, prEnd)</span><br><br>    <span class="hljs-keyword">if</span> prStart == prEnd &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> &#125;<br>    rootVal := t.preorder[prStart]<br>    root := &amp;TreeNode&#123;Val: rootVal&#125;<br>    <span class="hljs-keyword">if</span> prEnd - prStart == <span class="hljs-number">1</span> &#123; <span class="hljs-keyword">return</span> root &#125;<br><br>    <span class="hljs-keyword">var</span> inMid <span class="hljs-type">int</span><br>    <span class="hljs-keyword">for</span> inMid = inStart; inMid &lt; inEnd; inMid++ &#123;<br>        <span class="hljs-keyword">if</span> t.inorder[inMid] == rootVal &#123; <span class="hljs-keyword">break</span> &#125;<br>    &#125;<br><br>    prMid := prStart + <span class="hljs-number">1</span> + inMid - inStart<br>    root.Left = t.traverse(inStart, inMid, prStart + <span class="hljs-number">1</span>, prMid)<br>    root.Right = t.traverse(inMid + <span class="hljs-number">1</span>, inEnd, prMid, prEnd)<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(preorder []<span class="hljs-type">int</span>, inorder []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">return</span> TreeBuilder&#123;inorder, preorder&#125;.traverse(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(inorder), <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(preorder))<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>改写成slice更简洁</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(preorder []<span class="hljs-type">int</span>, inorder []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-comment">// fmt.Printf(&quot;%v | %v \n&quot;, preorder, inorder)</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(preorder) == <span class="hljs-number">0</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> &#125;<br>    rootVal := preorder[<span class="hljs-number">0</span>]<br>    root := &amp;TreeNode&#123;Val: rootVal&#125;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(preorder) == <span class="hljs-number">1</span> &#123; <span class="hljs-keyword">return</span> root &#125;<br><br>    <span class="hljs-keyword">var</span> inMid <span class="hljs-type">int</span><br>    <span class="hljs-keyword">for</span> inMid = <span class="hljs-number">0</span>; inMid &lt; <span class="hljs-built_in">len</span>(inorder); inMid++ &#123;<br>        <span class="hljs-keyword">if</span> inorder[inMid] == rootVal &#123; <span class="hljs-keyword">break</span> &#125;<br>    &#125;<br><br>    root.Left = buildTree(preorder[<span class="hljs-number">1</span>:<span class="hljs-number">1</span>+inMid], inorder[:inMid])<br>    root.Right = buildTree(preorder[<span class="hljs-number">1</span>+inMid:], inorder[inMid+<span class="hljs-number">1</span>:])<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#zui-da-er-cha-shu" class="header-anchor">#</a><span id="zui-da-er-cha-shu"> 最大二叉树</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-654-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-binary-tree/">最大二叉树</a></p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">constructMaximumBinaryTree</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> &#125;<br>    max := nums[<span class="hljs-number">0</span>]<br>    index := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> nums &#123;<br>        <span class="hljs-keyword">if</span> v &gt; max &#123; <br>            max = v<br>            index = i<br>        &#125;<br>    &#125;<br>    root := &amp;TreeNode&#123;Val: max&#125;<br>    root.Left = constructMaximumBinaryTree(nums[:index])<br>    root.Right = constructMaximumBinaryTree(nums[index+<span class="hljs-number">1</span>:])<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#he-bing-er-cha-shu" class="header-anchor">#</a><span id="he-bing-er-cha-shu"> 合并二叉树</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-617-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-binary-trees/">合并二叉树</a></p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeTrees</span><span class="hljs-params">(root1 *TreeNode, root2 *TreeNode)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> root1 == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> root2 &#125;<br>    <span class="hljs-keyword">if</span> root2 == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> root1 &#125;<br>    root1.Val += root2.Val<br>    root1.Left = mergeTrees(root1.Left, root2.Left)<br>    root1.Right = mergeTrees(root1.Right, root2.Right)<br>    <span class="hljs-keyword">return</span> root1<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#er-cha-sou-suo-shu-zhong-de-sou-suo" class="header-anchor">#</a><span id="er-cha-sou-suo-shu-zhong-de-sou-suo"> 二叉搜索树中的搜索</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-700-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">二叉搜索树中的搜索</a></p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">searchBST</span><span class="hljs-params">(root *TreeNode, val <span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> &#125;<br>    <span class="hljs-keyword">if</span> root.Val &gt; val &#123; <span class="hljs-keyword">return</span> searchBST(root.Left, val) &#125;<br>    <span class="hljs-keyword">if</span> root.Val &lt; val &#123; <span class="hljs-keyword">return</span> searchBST(root.Right, val) &#125;<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>迭代</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">searchBST</span><span class="hljs-params">(root *TreeNode, val <span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">for</span> root != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> root.Val &gt; val &#123; <br>            root = root.Left<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> root.Val &lt; val &#123;<br>            root = root.Right<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> root<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#yan-zheng-er-cha-sou-suo-shu" class="header-anchor">#</a><span id="yan-zheng-er-cha-sou-suo-shu"> 验证二叉搜索树</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-98-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/validate-binary-search-tree/">验证二叉搜索树</a></p>
<ul>
<li>递归，注意子树区间必须，需要上下界来判断</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> helper(root, math.MinInt64, math.MaxInt64)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">helper</span><span class="hljs-params">(root *TreeNode, lower, upper <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> root.Val &lt;= lower || root.Val &gt;= upper &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> helper(root.Left, lower, root.Val) &amp;&amp; helper(root.Right, root.Val, upper)<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>中序遍历，序列递增</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    valid, _ := traverse(root, math.MinInt64)<br>    <span class="hljs-keyword">return</span> valid<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">traverse</span><span class="hljs-params">(root *TreeNode, val <span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">bool</span>, <span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, val<br>    &#125;<br>    <span class="hljs-keyword">var</span> valid <span class="hljs-type">bool</span><br>    valid, val = traverse(root.Left, val)<br>    <span class="hljs-keyword">if</span> !valid &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, val<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> root.Val &lt;= val &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, val<br>    &#125;<br>    val = root.Val<br><br>    valid, val = traverse(root.Right, val)<br>    <span class="hljs-keyword">if</span> !valid &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, val<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, val<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#er-cha-sou-suo-shu-de-zui-xiao-jue-dui-chai" class="header-anchor">#</a><span id="er-cha-sou-suo-shu-de-zui-xiao-jue-dui-chai"> 二叉搜索树的最小绝对差</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-530-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/">二叉搜索树的最小绝对差</a></p>
<ul>
<li>中序遍历，Go的struct指针</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">type</span> Searcher <span class="hljs-keyword">struct</span> &#123;<br>    min <span class="hljs-type">int</span><br>    last <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Abs</span><span class="hljs-params">(a <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> -a<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Searcher)</span></span>traverse(root *TreeNode) &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> &#125;<br>    s.traverse(root.Left)<br>    val := Abs(root.Val - s.last)<br>    <span class="hljs-keyword">if</span> val &lt; s.min &#123;<br>        s.min = val<br>    &#125;<br>    s.last = root.Val<br>    s.traverse(root.Right)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMinimumDifference</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    s := Searcher&#123;math.MaxInt64, math.MaxInt64&#125;<br>    s.traverse(root)<br>    <span class="hljs-keyword">return</span> s.min<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#er-cha-sou-suo-shu-zhong-de-zhong-shu" class="header-anchor">#</a><span id="er-cha-sou-suo-shu-zhong-de-zhong-shu"> 二叉搜索树中的众数</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-501-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/">二叉搜索树中的众数</a></p>
<ul>
<li>二叉搜索树中序遍历有序</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">type</span> Searcher <span class="hljs-keyword">struct</span> &#123;<br>    Last <span class="hljs-type">int</span><br>    Count <span class="hljs-type">int</span><br>    MaxCount <span class="hljs-type">int</span><br>    Modes []<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Searcher)</span></span>traverse(root *TreeNode) &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> &#125;<br>    s.traverse(root.Left)<br>    <span class="hljs-keyword">if</span> root.Val == s.Last &#123;<br>        s.Count++<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        s.Last = root.Val<br>        s.Count = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> s.Count &gt; s.MaxCount &#123;<br>        s.Modes = <span class="hljs-literal">nil</span><br>        s.Modes = <span class="hljs-built_in">append</span>(s.Modes, root.Val)<br>        s.MaxCount = s.Count<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> s.Count == s.MaxCount &#123;<br>        s.Modes = <span class="hljs-built_in">append</span>(s.Modes, root.Val)<br>    &#125;<br>    s.traverse(root.Right)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findMode</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    s := Searcher&#123;<br>        Last: <span class="hljs-number">0</span>,<br>        Count: <span class="hljs-number">0</span>,<br>        MaxCount: <span class="hljs-number">0</span>,<br>    &#125;<br>    s.traverse(root)<br>    <span class="hljs-keyword">return</span> s.Modes<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#er-cha-shu-de-zui-jin-gong-gong-zu-xian" class="header-anchor">#</a><span id="er-cha-shu-de-zui-jin-gong-gong-zu-xian"> 二叉树的最近公共祖先</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-236-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">二叉树的最近公共祖先</a></p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(root, p, q *TreeNode)</span></span> *TreeNode &#123;<br>     <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> &#125;<br>     <span class="hljs-keyword">if</span> root.Val == p.Val || root.Val == q.Val &#123;<br>         <span class="hljs-keyword">return</span> root<br>     &#125;<br>     left := lowestCommonAncestor(root.Left, p, q)<br>     right := lowestCommonAncestor(root.Right, p, q)<br>     <span class="hljs-keyword">if</span> left != <span class="hljs-literal">nil</span> &amp;&amp; right != <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> root &#125;<br>     <span class="hljs-keyword">if</span> left != <span class="hljs-literal">nil</span> &amp;&amp; right == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> left &#125;<br>     <span class="hljs-keyword">if</span> left == <span class="hljs-literal">nil</span> &amp;&amp; right != <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> right &#125;<br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian" class="header-anchor">#</a><span id="er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian"> 二叉搜索树的最近公共祖先</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-235-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">二叉搜索树的最近公共祖先</a></p>
<ul>
<li>二叉搜索树有序，前序遍历，第一个落在[p, q]或[q, p]区间的就是公共祖先</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val   int</span><br><span class="hljs-comment"> *     Left  *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(root, p, q *TreeNode)</span></span> *TreeNode &#123;<br>  <span class="hljs-keyword">if</span> root.Val &gt; p.Val &amp;&amp; root.Val &gt; q.Val &#123;<br>        <span class="hljs-keyword">return</span> lowestCommonAncestor(root.Left, p, q)<br>    &#125;<br>    <span class="hljs-keyword">if</span> root.Val &lt; p.Val &amp;&amp; root.Val &lt; q.Val &#123;<br>        <span class="hljs-keyword">return</span> lowestCommonAncestor(root.Right, p, q)<br>    &#125;<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>迭代</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val   int</span><br><span class="hljs-comment"> *     Left  *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(root, p, q *TreeNode)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-keyword">if</span> root.Val &gt; p.Val &amp;&amp; root.Val &gt; q.Val &#123;<br>            root = root.Left<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> root.Val &lt; p.Val &amp;&amp; root.Val &lt; q.Val &#123;<br>            root = root.Right<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> root<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#er-cha-sou-suo-shu-zhong-de-cha-ru-cao-zuo" class="header-anchor">#</a><span id="er-cha-sou-suo-shu-zhong-de-cha-ru-cao-zuo"> 二叉搜索树中的插入操作</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-701-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/">二叉搜索树中的插入操作</a></p>
<ul>
<li>利用二叉搜索树的性质插入</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(root *TreeNode, val <span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> &amp;TreeNode&#123;Val: val&#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> val &lt; root.Val &#123;<br>        root.Left = insertIntoBST(root.Left, val)<br>    &#125;<br>    <span class="hljs-keyword">if</span> val &gt; root.Val &#123;<br>        root.Right = insertIntoBST(root.Right, val)<br>    &#125;<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#shan-chu-er-cha-sou-suo-shu-zhong-de-jie-dian" class="header-anchor">#</a><span id="shan-chu-er-cha-sou-suo-shu-zhong-de-jie-dian"> 删除二叉搜索树中的节点</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-450-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">删除二叉搜索树中的节点</a></p>
<ul>
<li>删除节点时分五种情况：
<ol>
<li>找不到</li>
<li>左右都为空，直接删除</li>
<li>左空右不空，等于右</li>
<li>右空左不空，等于左</li>
<li>左右都不空，有两种方案</li>
</ol>
<ul>
<li>用右子树中最小的节点替换，退化为2，因为右子树中最小节点也一定比左子树中的任意节点都大，这个节点是右子树的最左叶子节点。可以统一2/3/5。</li>
<li>把左子树挂在右子树的最左叶子节点，退化为3</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(root *TreeNode, key <span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> root &#125;<br>    <span class="hljs-keyword">if</span> root.Val == key &#123;<br>        <span class="hljs-keyword">if</span> root.Right == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> root.Left<br>        &#125;<br>        cur := root.Right<br>        <span class="hljs-keyword">for</span> cur.Left != <span class="hljs-literal">nil</span> &#123;<br>            cur = cur.Left<br>        &#125;<br>        root.Val, cur.Val = cur.Val, root.Val<br>    &#125;<br>    root.Left = deleteNode(root.Left, key)<br>    root.Right = deleteNode(root.Right, key)<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#xiu-jian-er-cha-sou-suo-shu" class="header-anchor">#</a><span id="xiu-jian-er-cha-sou-suo-shu"> 修剪二叉搜索树</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-669-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/">修剪二叉搜索树</a></p>
<ul>
<li>前序遍历，如果节点值小于下界，左子树一定都小于下界，右子树不一定，可以先把右子树替换当前节点，递归判断。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trimBST</span><span class="hljs-params">(root *TreeNode, low <span class="hljs-type">int</span>, high <span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> root &#125;<br>    <span class="hljs-keyword">if</span> root.Val &lt; low &#123;<br>        <span class="hljs-keyword">return</span> trimBST(root.Right, low, high)<br>    &#125;<br>    <span class="hljs-keyword">if</span> root.Val &gt; high &#123;<br>        <span class="hljs-keyword">return</span> trimBST(root.Left, low, high)<br>    &#125;<br>    root.Left = trimBST(root.Left, low, high)<br>    root.Right = trimBST(root.Right, low, high)<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#jiang-you-xu-shu-zu-zhuan-huan-wei-er-cha-sou-suo-shu" class="header-anchor">#</a><span id="jiang-you-xu-shu-zu-zhuan-huan-wei-er-cha-sou-suo-shu"> 将有序数组转换为二叉搜索树</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-108-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">将有序数组转换为二叉搜索树</a></p>
<ul>
<li>利用二叉搜索树有序特性，二分数组</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> &#125;<br>    mid := <span class="hljs-built_in">len</span>(nums) / <span class="hljs-number">2</span><br>    root := &amp;TreeNode&#123;Val: nums[mid]&#125;<br>    root.Left = sortedArrayToBST(nums[:mid])<br>    root.Right = sortedArrayToBST(nums[mid+<span class="hljs-number">1</span>:])<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#ba-er-cha-sou-suo-shu-zhuan-huan-wei-lei-jia-shu" class="header-anchor">#</a><span id="ba-er-cha-sou-suo-shu-zhuan-huan-wei-lei-jia-shu"> 把二叉搜索树转换为累加树</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-538-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">把二叉搜索树转换为累加树</a></p>
<ul>
<li>反中序遍历累加即可</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">traverse</span><span class="hljs-params">(root *TreeNode, val <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> val &#125;<br>    val = traverse(root.Right, val)<br>    root.Val += val<br>    val = root.Val<br>    val = traverse(root.Left, val)<br>    <span class="hljs-keyword">return</span> val<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">convertBST</span><span class="hljs-params">(root *TreeNode)</span></span> *TreeNode &#123;<br>    traverse(root, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
</p></div><div class="share"><span>Share</span>&nbsp;<span class="soc"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></span><span class="soc"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></span><span class="soc"><a target="_blank" rel="noopener" href="http://twitter.com/home?status=https://blog.kleon.space/cs/algo/tree/%20KLEON%20算法基础 - 树" class="fa fa-twitter"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/cs/algo/array/" title="算法基础 - 数组"><i class="fa fa-angle-double-left"></i>&nbsp;Previous post: 算法基础 - 数组</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/cs/algo/sort/" title="算法基础 - 排序">Next post: 算法基础 - 排序&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2022&nbsp;<a target="_blank" href="https://blog.kleon.space" rel="noopener noreferrer">Kleon</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>