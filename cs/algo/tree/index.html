<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>算法基础 - 树 · KLEON</title><meta name="description" content="树是常用的数据结构，应用较多的有二叉搜索树，二叉平衡搜索树(AVL树)，红黑树，多路平衡搜索树(B-树，B+树，B*树)等。

基础
树可由链式结构或数组实现，遍历方式为前、中、后、层序遍历。
type TreeNode struct &amp;#123;
  Val   int
  Left  *Tree"><meta name="og:description" content="树是常用的数据结构，应用较多的有二叉搜索树，二叉平衡搜索树(AVL树)，红黑树，多路平衡搜索树(B-树，B+树，B*树)等。

基础
树可由链式结构或数组实现，遍历方式为前、中、后、层序遍历。
type TreeNode struct &amp;#123;
  Val   int
  Left  *Tree"><meta name="twitter:site" content="KLEON"><meta name="twitter:title" content="算法基础 - 树"><meta name="twitter:card" content="summary"><meta name="keywords" content=""><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 6.1.0"><link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div id="stage" class="container"><div class="row"><div id="side-bar" class="col-sm-3 col-xs-12 side-container invisible"><div class="vertical-text site-title"><h3 tabindex="-1" class="site-title-small"><a href="/" class="a-title"></a></h3><h1 tabindex="-1" class="site-title-large"><a href="/" class="a-title">自说自话</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div id="site-nav" class="site-title-links"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li><li><a href="/categories">Categories</a></li><li><a href="/tags">Tags</a></li><li><a href="/googlebe23cb0bc55fc412.html"></a></li><li><a href="/about/index.html"></a></li><li class="soc"><a href="https://github.com/kleon1024" target="_blank" rel="noopener noreferrer" aria-label="Github"><i class="fa fa-github">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2022&nbsp;<a target="_blank" href="https://blog.kleon.space" rel="noopener noreferrer">Kleon</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div id="main-container" class="col-sm-9 col-xs-12 main-container invisible"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>算法基础 - 树</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2021-03-14</span><span class="meta-item"><i class="fa fa-folder"></i><span>&nbsp;</span><a href="/categories/算法/" title="算法" class="a-tag">算法</a><span>&nbsp;</span></span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a href="/tags/算法/" title="算法" class="a-tag">算法</a><span>&nbsp;</span><a href="/tags/数据结构/" title="数据结构" class="a-tag">数据结构</a><span>&nbsp;</span></span></p><p class="post-abstract"><p>树是常用的数据结构，应用较多的有二叉搜索树，二叉平衡搜索树(AVL树)，红黑树，多路平衡搜索树(B-树，B+树，B*树)等。</p>
<span id="more"></span>
<h1>基础</h1>
<p>树可由链式结构或数组实现，遍历方式为前、中、后、层序遍历。</p>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">type TreeNode struct &#123;
  Val   int
  Left  *TreeNode
  Right *TreeNode
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="树"><a class="header-anchor" href="#树">¶</a>树</h2>
<p>有向无环非线性数据结构，每个节点可以指向多个节点，但至多有一个节点指向自身。</p>
<h2 id="二叉树"><a class="header-anchor" href="#二叉树">¶</a>二叉树</h2>
<p>每个节点至多只能指向两个节点。</p>
<h2 id="满二叉树"><a class="header-anchor" href="#满二叉树">¶</a>满二叉树</h2>
<p>只有度为0和2的节点，并且度为0的节点在同一层上。</p>
<h2 id="完全二叉树"><a class="header-anchor" href="#完全二叉树">¶</a>完全二叉树</h2>
<p>除了最底层节点可能没填满外，其余层节点数均达到最大值，并且最下面一层的节点应集中在最左侧。</p>
<h2 id="二叉搜索树"><a class="header-anchor" href="#二叉搜索树">¶</a>二叉搜索树</h2>
<p>一种朴素的有序树结构，左子节点均小于父节点，右子节点均大于父节点。当插入新值时由根节点开始按以上规则逐层比较，直到找到合适的叶节点位置。</p>
<ul>
<li>优点：不需要在插入数据时调整结构</li>
<li>缺点：性能易受数据插入顺序影响，最差情况为顺序插入，退化为链表。</li>
</ul>
<h2 id="平衡二叉搜索树-AVL树"><a class="header-anchor" href="#平衡二叉搜索树-AVL树">¶</a>平衡二叉搜索树(AVL树)</h2>
<p>二叉搜索树的改进，又称AVL(Adelson-Velsky and Landis)树，引入平衡因子，通过旋转操作保证所有子树高度差不超过1。</p>
<ul>
<li>优点：相比二叉树更平衡，极端情况下表现依然足够好。</li>
<li>缺点：在读写比例差不多的情况下，旋转操作过多。</li>
</ul>
<h2 id="红黑树-RB树"><a class="header-anchor" href="#红黑树-RB树">¶</a>红黑树(RB树)</h2>
<p>AVL树的改进，引入着色规则，通过旋转和着色操作保证所有子树高度差不超过2。Map可以通过红黑树实现。</p>
<ul>
<li>优点：写性能更高。</li>
<li>缺点：查询性能弱于AVL树，因为子树高度差比AVL多一层，最差情况会多一次比较。</li>
</ul>
<h2 id="B-树-B-Tree-B树"><a class="header-anchor" href="#B-树-B-Tree-B树">¶</a>B-树(B-Tree, B树)</h2>
<p>多路搜索树，又称B树，用于数据索引，子节点内放指针和数据块。通过分裂操作维持树结构。</p>
<h2 id="B-树"><a class="header-anchor" href="#B-树">¶</a>B+树</h2>
<p>B-树改进型，子节点内不放数据块，统一放在叶节点内。查询性能稳定，IO数据利用率高。</p>
<h2 id="B-树-v2"><a class="header-anchor" href="#B-树-v2">¶</a>B*树</h2>
<p>B+树改进型，增加子节点间指针，如果兄弟节点数据未满，则将一部分指针移到兄弟节点，并修改父节点关键字，将结点的最低利用率从1/2提高到2/3。</p>
<h1>实践</h1>
<h2 id="二叉树的前序遍历"><a class="header-anchor" href="#二叉树的前序遍历">¶</a>二叉树的前序遍历</h2>
<p><img src="https://img.shields.io/badge/leetcode-144-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">二叉树的前序遍历</a></p>
<ul>
<li>递归</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func traverse(n *TreeNode, result *[]int) &#123;
    if n == nil &#123; return &#125;
    *result = append(*result, n.Val)
    traverse(n.Left, result)
    traverse(n.Right, result)
&#125;

func preorderTraversal(root *TreeNode) []int &#123;
    result := []int&#123;&#125;
    traverse(root, &result)
    return result
&#125;

//

/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func preorderTraversal(root *TreeNode) []int &#123;
    result := []int&#123;&#125;
    if root == nil &#123; return result &#125;
    result = append(result, root.Val)
    result = append(result, preorderTraversal(root.Left)...)
    result = append(result, preorderTraversal(root.Right)...)
    return result
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>迭代</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func preorderTraversal(root *TreeNode) []int &#123;
    stack := []*TreeNode&#123;&#125;
    result := []int&#123;&#125;
    if root != nil &#123;
        stack = append(stack, root)
    &#125;
    for len(stack) > 0 &#123;
        node := stack[len(stack) - 1]
        stack = stack[:len(stack) - 1]
        if node != nil &#123;
            if node.Right != nil &#123;
                stack = append(stack, node.Right)
            &#125;
            if node.Left != nil &#123;
                stack = append(stack, node.Left)
            &#125;
            stack = append(stack, node)
            stack = append(stack, nil)
        &#125; else &#123;
            node = stack[len(stack) - 1]
            stack = stack[:len(stack) - 1]
            result = append(result, node.Val)
        &#125;
    &#125;
    return result
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二叉树的后序遍历"><a class="header-anchor" href="#二叉树的后序遍历">¶</a>二叉树的后序遍历</h2>
<p><img src="https://img.shields.io/badge/leetcode-145-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">二叉树的后序遍历</a></p>
<ul>
<li>递归</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func postorderTraversal(root *TreeNode) []int &#123;
    result := []int&#123;&#125;
    if root == nil &#123; return result &#125;
    result = append(result, postorderTraversal(root.Left)...)
    result = append(result, postorderTraversal(root.Right)...)
    result = append(result, root.Val)
    return result
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>迭代</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func postorderTraversal(root *TreeNode) []int &#123;
    stack := []*TreeNode&#123;&#125;
    result := []int&#123;&#125;
    if root != nil &#123;
        stack = append(stack, root)
    &#125;
    for len(stack) > 0 &#123;
        node := stack[len(stack) - 1]
        stack = stack[:len(stack) - 1]
        if node != nil &#123;
            stack = append(stack, node)
            stack = append(stack, nil)
            if node.Right != nil &#123;
                stack = append(stack, node.Right)
            &#125;
            if node.Left != nil &#123;
                stack = append(stack, node.Left)
            &#125;
        &#125; else &#123;
            node = stack[len(stack) - 1]
            stack = stack[:len(stack) - 1]
            result = append(result, node.Val)
        &#125;
    &#125;
    return result
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二叉树的中序遍历"><a class="header-anchor" href="#二叉树的中序遍历">¶</a>二叉树的中序遍历</h2>
<p><img src="https://img.shields.io/badge/leetcode-94-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">二叉树的中序遍历</a></p>
<ul>
<li>递归</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func inorderTraversal(root *TreeNode) []int &#123;
    result := []int&#123;&#125;
    if root == nil &#123; return result &#125;
    result = append(result, inorderTraversal(root.Left)...)
    result = append(result, root.Val)
    result = append(result, inorderTraversal(root.Right)...)
    return result
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>迭代</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func inorderTraversal(root *TreeNode) []int &#123;
    stack := []*TreeNode&#123;&#125;
    result := []int&#123;&#125;
    if root != nil &#123;
        stack = append(stack, root)
    &#125;
    for len(stack) > 0 &#123;
        node := stack[len(stack) - 1]
        stack = stack[:len(stack) - 1]
        if node != nil &#123;
            if node.Right != nil &#123;
                stack = append(stack, node.Right)
            &#125;
            stack = append(stack, node)
            stack = append(stack, nil)
            if node.Left != nil &#123;
                stack = append(stack, node.Left)
            &#125;
        &#125; else &#123;
            node = stack[len(stack) - 1]
            stack = stack[:len(stack) - 1]
            result = append(result, node.Val)
        &#125;
    &#125;
    return result
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>C++ 版本</p>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">void preorder(TreeNode* root, vector<int>& v) &#123;
    if (root == nullptr) return;
    
    v.push_back(root->val);
    preorder(root->left, v);
    preorder(root->right, v);
&#125;

void postorder(TreeNode* root, vector<int>& v) &#123;
    if (root == nullptr) return;

    postorder(root->left, v);
    postorder(root->right, v);
    v.push_back(root->val);
&#125;

void midorder(TreeNode* root, vector<int>& v) &#123;
    if (root == nullptr) return;

    midorder(root->left, v);
    v.push_back(root->val);
    midorder(root->right, v);
&#125;

void preorderIter(TreeNode* root, vector<int>& v) &#123;
    std::stack<TreeNode*> s;
    
    if (root != nullptr) &#123;
        s.push(root);
    &#125;
    
    TreeNode* node = nullptr;
    while(s.size() > 0) &#123;
        node = s.top();
        s.pop();
        if (node) &#123;
            if (node->right) &#123;
                s.push(node->right);
            &#125;
            if (node->left) &#123;
                s.push(node->left);
            &#125;
            s.push(node);
            s.push(nullptr);
        &#125; else &#123;
            node = s.top();
            s.pop();
            v.push_back(node->val);
        &#125;
    &#125;
&#125;

void postorderIter(TreeNode* root, vector<int>& v) &#123;
    std::stack<TreeNode*> s;
    
    if (root != nullptr) &#123;
        s.push(root);
    &#125;
    
    TreeNode* node = nullptr;
    while(s.size() > 0) &#123;
        node = s.top();
        s.pop();
        if (node) &#123;
            s.push(node);
            s.push(nullptr);
            if (node->right) &#123;
                s.push(node->right);
            &#125;
            if (node->left) &#123;
                s.push(node->left);
            &#125;
        &#125; else &#123;
            node = s.top();
            s.pop();
            v.push_back(node->val);
        &#125;
    &#125;
&#125;

void midorderIter(TreeNode* root, vector<int>& v) &#123;
    std::stack<TreeNode*> s;
    
    if (root != nullptr) &#123;
        s.push(root);
    &#125;
    
    TreeNode* node = nullptr;
    while(s.size() > 0) &#123;
        node = s.top();
        s.pop();
        if (node) &#123;
            if (node->right) &#123;
                s.push(node->right);
            &#125;
            s.push(node);
            s.push(nullptr);
            if (node->left) &#123;
                s.push(node->left);
            &#125;
        &#125; else &#123;
            node = s.top();
            s.pop();
            v.push_back(node->val);
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二叉树的层序遍历"><a class="header-anchor" href="#二叉树的层序遍历">¶</a>二叉树的层序遍历</h2>
<p><img src="https://img.shields.io/badge/leetcode-102-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">二叉树的层序遍历</a></p>
<ul>
<li>队列先进先出</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func levelOrder(root *TreeNode) [][]int &#123;
    queue := []*TreeNode&#123;&#125;
    result := [][]int&#123;&#125;
    if root != nil &#123;
        queue = append(queue, root)
    &#125;
    for len(queue) > 0 &#123;
        size := len(queue)
        vec := []int&#123;&#125;
        for i := 0; i < size; i++ &#123;
            node := queue[0]
            queue = queue[1:]
            vec = append(vec, node.Val)
            if node.Left != nil &#123;
                queue = append(queue, node.Left)
            &#125;
            if node.Right != nil &#123;
                queue = append(queue, node.Right)
            &#125;
        &#125;
        result = append(result, vec)
    &#125;
    return result
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二叉树的层序遍历II"><a class="header-anchor" href="#二叉树的层序遍历II">¶</a>二叉树的层序遍历II</h2>
<p><img src="https://img.shields.io/badge/leetcode-107-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">二叉树的层序遍历II</a></p>
<ul>
<li>同二叉树的层序遍历</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func levelOrderBottom(root *TreeNode) [][]int &#123;
    queue := []*TreeNode&#123;&#125;
    result := [][]int&#123;&#125;
    if root != nil &#123;
        queue = append(queue, root)
    &#125;
    for len(queue) > 0 &#123;
        size := len(queue)
        vec := []int&#123;&#125;
        for i := 0; i < size; i++ &#123;
            node := queue[0]
            queue = queue[1:]
            vec = append(vec, node.Val)
            if node.Left != nil &#123;
                queue = append(queue, node.Left)
            &#125;
            if node.Right != nil &#123;
                queue = append(queue, node.Right)
            &#125;
        &#125;
        result = append(result, vec)
    &#125;
    for i, j := 0, len(result)-1; i < j; i, j = i+1, j-1 &#123;
        result[i], result[j] = result[j], result[i]
    &#125;
    return result
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="层序遍历获取二叉树的右视图"><a class="header-anchor" href="#层序遍历获取二叉树的右视图">¶</a>层序遍历获取二叉树的右视图</h2>
<p><img src="https://img.shields.io/badge/leetcode-199-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-right-side-view/">二叉树的右视图</a></p>
<ul>
<li>同二叉树的层序遍历</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func rightSideView(root *TreeNode) []int &#123;
    queue := []*TreeNode&#123;&#125;
    result := []int&#123;&#125;
    if root != nil &#123;
        queue = append(queue, root)
    &#125;
    for len(queue) > 0 &#123;
        size := len(queue)
        for i := 0; i < size; i++ &#123;
            node := queue[0]
            queue = queue[1:]
            if i == size - 1 &#123;
                result = append(result, node.Val)
            &#125;
            if node.Left != nil &#123;
                queue = append(queue, node.Left)
            &#125;
            if node.Right != nil &#123;
                queue = append(queue, node.Right)
            &#125;
        &#125;
    &#125;
    return result
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="层序遍历获取二叉树的层平均值"><a class="header-anchor" href="#层序遍历获取二叉树的层平均值">¶</a>层序遍历获取二叉树的层平均值</h2>
<p><img src="https://img.shields.io/badge/leetcode-637-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/">二叉树的层平均值</a></p>
<ul>
<li>同二叉树的层序遍历</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func averageOfLevels(root *TreeNode) []float64 &#123;
    result := []float64&#123;&#125;
    if root == nil &#123;
        return result
    &#125;
    queue := list.New()
    queue.PushBack(root)
    for queue.Len() > 0 &#123;
        size := queue.Len()
        sum := 0
        for i := 0; i < size; i++ &#123;
            node := queue.Front()
            queue.Remove(node)
            t := node.Value.(*TreeNode)
            sum += t.Val
            if t.Left != nil &#123;
                queue.PushBack(t.Left)
            &#125;
            if t.Right != nil &#123;
                queue.PushBack(t.Right)
            &#125;
        &#125;
        result = append(result, float64(sum) / float64(size))
    &#125;
    return result
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="层序遍历获取N叉树的层序遍历"><a class="header-anchor" href="#层序遍历获取N叉树的层序遍历">¶</a>层序遍历获取N叉树的层序遍历</h2>
<p><img src="https://img.shields.io/badge/leetcode-429-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/">N叉树的层序遍历</a></p>
<ul>
<li>同二叉树的层序遍历</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a Node.
 * type Node struct &#123;
 *     Val int
 *     Children []*Node
 * &#125;
 */

func levelOrder(root *Node) [][]int &#123;
    queue := []*Node&#123;&#125;
    result := [][]int&#123;&#125;
    if root != nil &#123;
        queue = append(queue, root)
    &#125;
    for len(queue) > 0 &#123;
        size := len(queue)
        vec := []int&#123;&#125;
        for i := 0; i < size; i++ &#123;
            node := queue[0]
            queue = queue[1:]
            vec = append(vec, node.Val)
            for _, n := range node.Children &#123;
                queue = append(queue, n)
            &#125;
        &#125;
        result = append(result, vec)
    &#125;
    return result
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="前序遍历二叉树展开为链表"><a class="header-anchor" href="#前序遍历二叉树展开为链表">¶</a>前序遍历二叉树展开为链表</h2>
<p><img src="https://img.shields.io/badge/leetcode-114-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">二叉树展开为链表</a></p>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func flatten(root *TreeNode)  &#123;
    stack := []*TreeNode&#123;&#125;
    list := []*TreeNode&#123;&#125;
    node := root
    for node != nil || len(stack) > 0 &#123;
        for node != nil &#123;
            list = append(list, node)
            stack = append(stack, node)
            node = node.Left
        &#125;
        node = stack[len(stack) - 1]
        node = node.Right
        stack = stack[:len(stack) - 1]
    &#125;

    for i := 1; i < len(list); i++ &#123;
        prev, curr := list[i-1], list[i]
        prev.Left, prev.Right = nil, curr
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="翻转二叉树"><a class="header-anchor" href="#翻转二叉树">¶</a>翻转二叉树</h2>
<p><img src="https://img.shields.io/badge/leetcode-226-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/invert-binary-tree/">翻转二叉树</a></p>
<ul>
<li>递归</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func invertTree(root *TreeNode) *TreeNode &#123;
    if root == nil &#123;
        return root
    &#125;
    root.Left, root.Right = root.Right, root.Left
    invertTree(root.Left)
    invertTree(root.Right)
    return root
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>迭代</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func invertTree(root *TreeNode) *TreeNode &#123;
    if root == nil &#123;
        return root
    &#125;
    stack := []*TreeNode&#123;&#125;
    stack = append(stack, root)
    for len(stack) > 0 &#123;
        node := stack[len(stack) - 1]
        stack = stack[:len(stack) - 1]
        node.Left, node.Right = node.Right, node.Left
        if node.Right != nil &#123;
            stack = append(stack, node.Right)
        &#125;
        if node.Left != nil &#123;
            stack = append(stack, node.Left)
        &#125;
    &#125;
    return root
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>层序</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func invertTree(root *TreeNode) *TreeNode &#123;
    queue := []*TreeNode&#123;&#125;
    if root == nil &#123;
        return root
    &#125;
    queue = append(queue, root)
    for len(queue) > 0 &#123;
        size := len(queue)
        for i := 0; i < size; i++ &#123;
            node := queue[0]
            queue = queue[1:]
            node.Left, node.Right = node.Right, node.Left
            if node.Left != nil &#123;
                queue = append(queue, node.Left)
            &#125;
            if node.Right != nil &#123;
                queue = append(queue, node.Right)
            &#125;
        &#125;
    &#125;
    return root
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="对称二叉树"><a class="header-anchor" href="#对称二叉树">¶</a>对称二叉树</h2>
<p><img src="https://img.shields.io/badge/leetcode-101-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/symmetric-tree/">对称二叉树</a></p>
<ul>
<li>递归</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func compare(left *TreeNode, right *TreeNode) bool &#123;
    if right != nil && left == nil &#123; return false &#125;
    if right == nil && left != nil &#123; return false &#125;
    if right == nil && left == nil &#123; return true &#125;
    if right.Val != left.Val &#123; return false &#125;

    outside := compare(left.Left, right.Right)
    inside := compare(left.Right, right.Left)
    return outside && inside
&#125;

func isSymmetric(root *TreeNode) bool &#123;
    if root == nil &#123; return true &#125;
    return compare(root.Left, root.Right)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>迭代，队列和栈均可</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func isSymmetric(root *TreeNode) bool &#123;
    if root == nil &#123; return true &#125;
    queue := []*TreeNode&#123;&#125;
    queue = append(queue, root.Left)
    queue = append(queue, root.Right)

    for len(queue) > 0 &#123;
        left := queue[0]; queue = queue[1:]
        right := queue[0]; queue = queue[1:]
        if left == nil && right == nil &#123;
            continue
        &#125;
        if left == nil || right == nil || left.Val != right.Val &#123;
            return false
        &#125;
        queue = append(queue, left.Left)
        queue = append(queue, right.Right)
        queue = append(queue, left.Right)
        queue = append(queue, right.Left)
    &#125;
    return true
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二叉树的最大深度"><a class="header-anchor" href="#二叉树的最大深度">¶</a>二叉树的最大深度</h2>
<p><img src="https://img.shields.io/badge/leetcode-104-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">二叉树的最大深度</a></p>
<ul>
<li>后序遍历</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func Max(x, y int) int &#123;
    if x < y &#123; return y &#125;
    return x
&#125;

func depth(node *TreeNode) int &#123;
    if node == nil &#123; return 0 &#125;
    return 1 + Max(depth(node.Left), depth(node.Right))
&#125;

func maxDepth(root *TreeNode) int &#123;
    return depth(root)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>层序遍历</li>
</ul>
<h2 id="N叉树的最大深度"><a class="header-anchor" href="#N叉树的最大深度">¶</a>N叉树的最大深度</h2>
<p><img src="https://img.shields.io/badge/leetcode-104-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">N叉树的最大深度</a></p>
<ul>
<li>迭代，同二叉树</li>
<li>层序遍历</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a Node.
 * type Node struct &#123;
 *     Val int
 *     Children []*Node
 * &#125;
 */

func maxDepth(root *Node) int &#123;
    queue := []*Node&#123;&#125;
    depth := 0
    if root == nil &#123; return depth &#125;
    queue = append(queue, root)
    for len(queue) > 0 &#123;
        size := len(queue)
        depth++
        for i := 0; i < size; i++ &#123;
            node := queue[0]
            queue = queue[1:]
            for _, n := range node.Children &#123;
                if n != nil &#123;
                    queue = append(queue, n)
                &#125;
            &#125;
        &#125;
    &#125;
    return depth
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二叉树的最小深度"><a class="header-anchor" href="#二叉树的最小深度">¶</a>二叉树的最小深度</h2>
<p><img src="https://img.shields.io/badge/leetcode-111-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">二叉树的最小深度</a></p>
<ul>
<li>递归</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func Min(x, y int) int &#123;
    if x > y &#123; return y &#125;
    return x
&#125;

func depth(node *TreeNode) int &#123;
    if node == nil &#123; return 0 &#125;
    leftDepth := depth(node.Left)
    rightDepth := depth(node.Right)

    if node.Left == nil && node.Right != nil &#123;
        return 1 + rightDepth
    &#125;

    if node.Right == nil && node.Left != nil &#123;
        return 1 + leftDepth
    &#125;

    return 1 + Min(leftDepth, rightDepth)
&#125;


func minDepth(root *TreeNode) int &#123;
    return depth(root)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>层序遍历</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func minDepth(root *TreeNode) int &#123;
    queue := []*TreeNode&#123;&#125;
    depth := 0
    if root == nil &#123; return depth &#125;
    queue = append(queue, root)
    for len(queue) > 0 &#123;
        size := len(queue)
        depth++
        for i := 0; i < size; i++ &#123;
            node := queue[0]
            queue = queue[1:]
            if node.Left == nil && node.Right == nil &#123;
                return depth
            &#125;
            if node.Left != nil &#123;
                queue = append(queue, node.Left)
            &#125;
            if node.Right != nil &#123;
                queue = append(queue, node.Right)
            &#125;
        &#125;
    &#125;
    return depth
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="完全二叉树的节点数"><a class="header-anchor" href="#完全二叉树的节点数">¶</a>完全二叉树的节点数</h2>
<p><img src="https://img.shields.io/badge/leetcode-222-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-complete-tree-nodes/">完全二叉树的节点个数</a></p>
<ul>
<li>前序遍历递归</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func nodeNum(node *TreeNode) int &#123;
    if node == nil &#123; return 0 &#125;
    return 1 + nodeNum(node.Left) + nodeNum(node.Right)
&#125;

func countNodes(root *TreeNode) int &#123;
    return nodeNum(root)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>层序遍历迭代</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func countNodes(root *TreeNode) int &#123;
    queue := []*TreeNode&#123;&#125;
    count := 0
    if root == nil &#123; return count &#125;
    queue = append(queue, root)
    for len(queue) > 0 &#123;
        size := len(queue)
        for i := 0; i < size; i++ &#123;
            node := queue[0]
            queue = queue[1:]
            count++
            if node.Left != nil &#123;
                queue = append(queue, node.Left)
            &#125;
            if node.Right != nil &#123;
                queue = append(queue, node.Right)
            &#125;
        &#125;
    &#125;
    return count
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="平衡二叉树"><a class="header-anchor" href="#平衡二叉树">¶</a>平衡二叉树</h2>
<p><img src="https://img.shields.io/badge/leetcode-110-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/balanced-binary-tree/">平衡二叉树</a></p>
<ul>
<li>递归</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func Max(x, y int) int &#123;
    if x > y &#123; return x &#125;
    return y
&#125;

func depth(node *TreeNode) int &#123;
    if node == nil &#123; return 0 &#125;
    leftDepth := depth(node.Left)
    if leftDepth < 0 &#123; return -1 &#125;
    rightDepth := depth(node.Right)
    if rightDepth < 0 &#123; return -1 &#125;
    if math.Abs(float64(leftDepth) - float64(rightDepth)) > 1 &#123;
        return -1
    &#125;
    return 1 + Max(leftDepth, rightDepth)
&#125;

func isBalanced(root *TreeNode) bool &#123;
    return depth(root) >= 0
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二叉树的所有路径"><a class="header-anchor" href="#二叉树的所有路径">¶</a>二叉树的所有路径</h2>
<p><img src="https://img.shields.io/badge/leetcode-257-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-paths/">二叉树的所有路径</a></p>
<ul>
<li>谦虚遍历递归</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func path(node *TreeNode, pathStr string) []string &#123;
    results := []string&#123;&#125;
    pathStr += strconv.Itoa(node.Val)
    if node.Left == nil && node.Right == nil &#123;
        results = append(results, pathStr)
    &#125;
    pathStr += "->"
    if node.Left != nil &#123;
        results = append(results, path(node.Left, pathStr)...)
    &#125;
    if node.Right != nil &#123;
        results = append(results, path(node.Right, pathStr)...)
    &#125;
    return results
&#125;

func binaryTreePaths(root *TreeNode) []string &#123;
    if root == nil &#123; return []string&#123;&#125; &#125;
    return path(root, "")
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="相同的树"><a class="header-anchor" href="#相同的树">¶</a>相同的树</h2>
<p><img src="https://img.shields.io/badge/leetcode-100-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/same-tree/">相同的树</a></p>
<ul>
<li>递归，同对称树</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func isSameTree(p *TreeNode, q *TreeNode) bool &#123;
    if p != nil && q == nil &#123; return false &#125;
    if p == nil && q != nil &#123; return false &#125;
    if p == nil && q == nil &#123; return true &#125;
    if p.Val != q.Val &#123; return false &#125;

    left := isSameTree(p.Left, q.Left)
    right := isSameTree(p.Right, q.Right)
    return left && right
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>迭代，队列和栈均可，同对称树</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func isSameTree(p *TreeNode, q *TreeNode) bool &#123;
    queue := []*TreeNode&#123;&#125;
    queue = append(queue, p)
    queue = append(queue, q)
    for len(queue) > 0 &#123;
        left := queue[0]; queue = queue[1:]
        right := queue[0]; queue = queue[1:]
        if left == nil && right == nil &#123;
            continue
        &#125;
        if left == nil || right == nil || left.Val != right.Val &#123;
            return false
        &#125;
        queue = append(queue, left.Left)
        queue = append(queue, right.Left)
        queue = append(queue, left.Right)
        queue = append(queue, right.Right)
    &#125;
    return true
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="左叶子之和"><a class="header-anchor" href="#左叶子之和">¶</a>左叶子之和</h2>
<p><img src="https://img.shields.io/badge/leetcode-404-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-of-left-leaves/">左叶子之和</a></p>
<ul>
<li>递归</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func sumOfLeftLeaves(root *TreeNode) int &#123;
    if root == nil &#123; return 0 &#125;
    sum := 0
    if root.Left != nil && root.Left.Left == nil && root.Left.Right == nil &#123;
        sum = root.Left.Val
    &#125;
    return sum + sumOfLeftLeaves(root.Left) + sumOfLeftLeaves(root.Right)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="找树左下角的值"><a class="header-anchor" href="#找树左下角的值">¶</a>找树左下角的值</h2>
<p><img src="https://img.shields.io/badge/leetcode-513-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/">找树左下角的值</a></p>
<ul>
<li>层序遍历</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func findBottomLeftValue(root *TreeNode) int &#123;
    queue := []*TreeNode&#123;root&#125;
    result := 0
    for len(queue) > 0 &#123;
        size := len(queue)
        for i := 0; i < size; i++ &#123;
            node := queue[0]
            queue = queue[1:]
            if i == 0 &#123; result = node.Val &#125;
            if node.Left != nil &#123;
                queue = append(queue, node.Left)
            &#125;
            if node.Right != nil &#123;
                queue = append(queue, node.Right)
            &#125;
        &#125;
    &#125;
    return result
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="路径总和"><a class="header-anchor" href="#路径总和">¶</a>路径总和</h2>
<p><img src="https://img.shields.io/badge/leetcode-112-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum/">路径总和</a></p>
<ul>
<li>递归</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func hasPathSum(root *TreeNode, targetSum int) bool &#123;
    if root == nil &#123; return false &#125;
    if root.Left == nil && root.Right == nil && root.Val == targetSum &#123;
        return true
    &#125;
    nextSum := targetSum - root.Val
    return hasPathSum(root.Left, nextSum) || hasPathSum(root.Right, nextSum)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="路径总和II"><a class="header-anchor" href="#路径总和II">¶</a>路径总和II</h2>
<p><img src="https://img.shields.io/badge/leetcode-113-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-ii/">路径总和II</a></p>
<ul>
<li>递归，注意Go的引用</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func traverse(root *TreeNode, targetSum int, res *[][]int, path[]int) &#123;
    path = append(path, root.Val)
    nextSum := targetSum - root.Val
    if root.Left == nil && root.Right == nil &#123;
        if nextSum == 0 &#123;
            tmp := make([]int, len(path))
            copy(tmp, path)
            *res = append(*res, tmp)
        &#125;
        return
    &#125;

    if root.Left != nil &#123;
        traverse(root.Left, nextSum, res, path)
    &#125;
    if root.Right != nil &#123;
        traverse(root.Right, nextSum, res, path)
    &#125;
&#125;

func pathSum(root *TreeNode, targetSum int) [][]int &#123;
    result := [][]int&#123;&#125;
    path := []int&#123;&#125;
    if root == nil &#123; return result &#125;
    traverse(root, targetSum, &result, path)
    return result
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="从中序与后序遍历序列构造二叉树"><a class="header-anchor" href="#从中序与后序遍历序列构造二叉树">¶</a>从中序与后序遍历序列构造二叉树</h2>
<p><img src="https://img.shields.io/badge/leetcode-106-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">从中序与后序遍历序列构造二叉树</a></p>
<ul>
<li>先取后序遍历最后一个值作为当前根节点，从中序遍历比对确定左右子树切割位置，后序遍历子树大小应和中序遍历数组子序列一致，将切分出的左右子序列递归。</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
type TreeBuilder struct &#123;
    inorder []int
    postorder []int
&#125;

func (t TreeBuilder)traverse(inStart, inEnd, poStart, poEnd int) *TreeNode &#123;
    if poStart == poEnd &#123; return nil &#125;
    rootVal := t.postorder[poEnd - 1]
    root := &TreeNode&#123;Val: rootVal&#125;
    if poEnd - poStart == 1 &#123; return root &#125;

    var inMid int
    for inMid = inStart; inMid < inEnd; inMid++ &#123;
        if t.inorder[inMid] == rootVal &#123; break &#125;
    &#125;

    poMid := poStart + inMid - inStart
    root.Left = t.traverse(inStart, inMid, poStart, poMid)
    root.Right = t.traverse(inMid + 1, inEnd, poMid, poEnd - 1)
    return root
&#125;

func buildTree(inorder []int, postorder []int) *TreeNode &#123;
    return TreeBuilder&#123;inorder, postorder&#125;.traverse(0, len(inorder), 0, len(postorder))
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="从中序与前序遍历序列构造二叉树"><a class="header-anchor" href="#从中序与前序遍历序列构造二叉树">¶</a>从中序与前序遍历序列构造二叉树</h2>
<p><img src="https://img.shields.io/badge/leetcode-105-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">从中序与前序遍历序列构造二叉树</a></p>
<ul>
<li>类似后序+中序</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
type TreeBuilder struct &#123;
    inorder []int
    preorder []int
&#125;

func (t TreeBuilder)traverse(inStart, inEnd, prStart, prEnd int) *TreeNode &#123;
    // fmt.Printf("%v %v | %v %v \n", inStart, inEnd, prStart, prEnd)

    if prStart == prEnd &#123; return nil &#125;
    rootVal := t.preorder[prStart]
    root := &TreeNode&#123;Val: rootVal&#125;
    if prEnd - prStart == 1 &#123; return root &#125;

    var inMid int
    for inMid = inStart; inMid < inEnd; inMid++ &#123;
        if t.inorder[inMid] == rootVal &#123; break &#125;
    &#125;

    prMid := prStart + 1 + inMid - inStart
    root.Left = t.traverse(inStart, inMid, prStart + 1, prMid)
    root.Right = t.traverse(inMid + 1, inEnd, prMid, prEnd)
    return root
&#125;

func buildTree(preorder []int, inorder []int) *TreeNode &#123;
    return TreeBuilder&#123;inorder, preorder&#125;.traverse(0, len(inorder), 0, len(preorder))
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>改写成slice更简洁</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func buildTree(preorder []int, inorder []int) *TreeNode &#123;
    // fmt.Printf("%v | %v \n", preorder, inorder)
    if len(preorder) == 0 &#123; return nil &#125;
    rootVal := preorder[0]
    root := &TreeNode&#123;Val: rootVal&#125;
    if len(preorder) == 1 &#123; return root &#125;

    var inMid int
    for inMid = 0; inMid < len(inorder); inMid++ &#123;
        if inorder[inMid] == rootVal &#123; break &#125;
    &#125;

    root.Left = buildTree(preorder[1:1+inMid], inorder[:inMid])
    root.Right = buildTree(preorder[1+inMid:], inorder[inMid+1:])
    return root
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="最大二叉树"><a class="header-anchor" href="#最大二叉树">¶</a>最大二叉树</h2>
<p><img src="https://img.shields.io/badge/leetcode-654-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-binary-tree/">最大二叉树</a></p>
<ul>
<li>递归</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func constructMaximumBinaryTree(nums []int) *TreeNode &#123;
    if len(nums) == 0 &#123; return nil &#125;
    max := nums[0]
    index := 0
    for i, v := range nums &#123;
        if v > max &#123; 
            max = v
            index = i
        &#125;
    &#125;
    root := &TreeNode&#123;Val: max&#125;
    root.Left = constructMaximumBinaryTree(nums[:index])
    root.Right = constructMaximumBinaryTree(nums[index+1:])
    return root
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="合并二叉树"><a class="header-anchor" href="#合并二叉树">¶</a>合并二叉树</h2>
<p><img src="https://img.shields.io/badge/leetcode-617-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-binary-trees/">合并二叉树</a></p>
<ul>
<li>递归</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func mergeTrees(root1 *TreeNode, root2 *TreeNode) *TreeNode &#123;
    if root1 == nil &#123; return root2 &#125;
    if root2 == nil &#123; return root1 &#125;
    root1.Val += root2.Val
    root1.Left = mergeTrees(root1.Left, root2.Left)
    root1.Right = mergeTrees(root1.Right, root2.Right)
    return root1
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二叉搜索树中的搜索"><a class="header-anchor" href="#二叉搜索树中的搜索">¶</a>二叉搜索树中的搜索</h2>
<p><img src="https://img.shields.io/badge/leetcode-700-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">二叉搜索树中的搜索</a></p>
<ul>
<li>递归</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func searchBST(root *TreeNode, val int) *TreeNode &#123;
    if root == nil &#123; return nil &#125;
    if root.Val > val &#123; return searchBST(root.Left, val) &#125;
    if root.Val < val &#123; return searchBST(root.Right, val) &#125;
    return root
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>迭代</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func searchBST(root *TreeNode, val int) *TreeNode &#123;
    for root != nil &#123;
        if root.Val > val &#123; 
            root = root.Left
        &#125; else if root.Val < val &#123;
            root = root.Right
        &#125; else &#123;
            return root
        &#125;
    &#125;
    return nil
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="验证二叉搜索树"><a class="header-anchor" href="#验证二叉搜索树">¶</a>验证二叉搜索树</h2>
<p><img src="https://img.shields.io/badge/leetcode-98-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/validate-binary-search-tree/">验证二叉搜索树</a></p>
<ul>
<li>递归，注意子树区间必须，需要上下界来判断</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */

func isValidBST(root *TreeNode) bool &#123;
    return helper(root, math.MinInt64, math.MaxInt64)
&#125;

func helper(root *TreeNode, lower, upper int) bool &#123;
    if root == nil &#123;
        return true
    &#125;
    if root.Val <= lower || root.Val >= upper &#123;
        return false
    &#125;
    return helper(root.Left, lower, root.Val) && helper(root.Right, root.Val, upper)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>中序遍历，序列递增</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */

func isValidBST(root *TreeNode) bool &#123;
    valid, _ := traverse(root, math.MinInt64)
    return valid
&#125;

func traverse(root *TreeNode, val int) (bool, int) &#123;
    if root == nil &#123;
        return true, val
    &#125;
    var valid bool
    valid, val = traverse(root.Left, val)
    if !valid &#123;
        return false, val
    &#125;

    if root.Val <= val &#123;
        return false, val
    &#125;
    val = root.Val

    valid, val = traverse(root.Right, val)
    if !valid &#123;
        return false, val
    &#125;
    return true, val
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二叉搜索树的最小绝对差"><a class="header-anchor" href="#二叉搜索树的最小绝对差">¶</a>二叉搜索树的最小绝对差</h2>
<p><img src="https://img.shields.io/badge/leetcode-530-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/">二叉搜索树的最小绝对差</a></p>
<ul>
<li>中序遍历，Go的struct指针</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
type Searcher struct &#123;
    min int
    last int
&#125;

func Abs(a int) int &#123;
    if a < 0 &#123;
        return -a
    &#125;
    return a
&#125;

func (s *Searcher)traverse(root *TreeNode) &#123;
    if root == nil &#123; return &#125;
    s.traverse(root.Left)
    val := Abs(root.Val - s.last)
    if val < s.min &#123;
        s.min = val
    &#125;
    s.last = root.Val
    s.traverse(root.Right)
&#125;

func getMinimumDifference(root *TreeNode) int &#123;
    s := Searcher&#123;math.MaxInt64, math.MaxInt64&#125;
    s.traverse(root)
    return s.min
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二叉搜索树中的众数"><a class="header-anchor" href="#二叉搜索树中的众数">¶</a>二叉搜索树中的众数</h2>
<p><img src="https://img.shields.io/badge/leetcode-501-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/">二叉搜索树中的众数</a></p>
<ul>
<li>二叉搜索树中序遍历有序</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
type Searcher struct &#123;
    Last int
    Count int
    MaxCount int
    Modes []int
&#125;

func (s *Searcher)traverse(root *TreeNode) &#123;
    if root == nil &#123; return &#125;
    s.traverse(root.Left)
    if root.Val == s.Last &#123;
        s.Count++
    &#125; else &#123;
        s.Last = root.Val
        s.Count = 1
    &#125;
    if s.Count > s.MaxCount &#123;
        s.Modes = nil
        s.Modes = append(s.Modes, root.Val)
        s.MaxCount = s.Count
    &#125; else if s.Count == s.MaxCount &#123;
        s.Modes = append(s.Modes, root.Val)
    &#125;
    s.traverse(root.Right)
&#125;

func findMode(root *TreeNode) []int &#123;
    s := Searcher&#123;
        Last: 0,
        Count: 0,
        MaxCount: 0,
    &#125;
    s.traverse(root)
    return s.Modes
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二叉树的最近公共祖先"><a class="header-anchor" href="#二叉树的最近公共祖先">¶</a>二叉树的最近公共祖先</h2>
<p><img src="https://img.shields.io/badge/leetcode-236-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">二叉树的最近公共祖先</a></p>
<ul>
<li>递归</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
 func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode &#123;
     if root == nil &#123; return nil &#125;
     if root.Val == p.Val || root.Val == q.Val &#123;
         return root
     &#125;
     left := lowestCommonAncestor(root.Left, p, q)
     right := lowestCommonAncestor(root.Right, p, q)
     if left != nil && right != nil &#123; return root &#125;
     if left != nil && right == nil &#123; return left &#125;
     if left == nil && right != nil &#123; return right &#125;
     return nil
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二叉搜索树的最近公共祖先"><a class="header-anchor" href="#二叉搜索树的最近公共祖先">¶</a>二叉搜索树的最近公共祖先</h2>
<p><img src="https://img.shields.io/badge/leetcode-235-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">二叉搜索树的最近公共祖先</a></p>
<ul>
<li>二叉搜索树有序，前序遍历，第一个落在[p, q]或[q, p]区间的就是公共祖先</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val   int
 *     Left  *TreeNode
 *     Right *TreeNode
 * &#125;
 */

func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode &#123;
	if root.Val > p.Val && root.Val > q.Val &#123;
        return lowestCommonAncestor(root.Left, p, q)
    &#125;
    if root.Val < p.Val && root.Val < q.Val &#123;
        return lowestCommonAncestor(root.Right, p, q)
    &#125;
    return root
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>迭代</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val   int
 *     Left  *TreeNode
 *     Right *TreeNode
 * &#125;
 */

func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode &#123;
    for &#123;
        if root.Val > p.Val && root.Val > q.Val &#123;
            root = root.Left
        &#125; else if root.Val < p.Val && root.Val < q.Val &#123;
            root = root.Right
        &#125; else &#123;
            return root
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二叉搜索树中的插入操作"><a class="header-anchor" href="#二叉搜索树中的插入操作">¶</a>二叉搜索树中的插入操作</h2>
<p><img src="https://img.shields.io/badge/leetcode-701-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/">二叉搜索树中的插入操作</a></p>
<ul>
<li>利用二叉搜索树的性质插入</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func insertIntoBST(root *TreeNode, val int) *TreeNode &#123;
    if root == nil &#123;
        return &TreeNode&#123;Val: val&#125;
    &#125;
    if val < root.Val &#123;
        root.Left = insertIntoBST(root.Left, val)
    &#125;
    if val > root.Val &#123;
        root.Right = insertIntoBST(root.Right, val)
    &#125;
    return root
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="删除二叉搜索树中的节点"><a class="header-anchor" href="#删除二叉搜索树中的节点">¶</a>删除二叉搜索树中的节点</h2>
<p><img src="https://img.shields.io/badge/leetcode-450-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">删除二叉搜索树中的节点</a></p>
<ul>
<li>删除节点时分五种情况：
<ol>
<li>找不到</li>
<li>左右都为空，直接删除</li>
<li>左空右不空，等于右</li>
<li>右空左不空，等于左</li>
<li>左右都不空，有两种方案</li>
</ol>
<ul>
<li>用右子树中最小的节点替换，退化为2，因为右子树中最小节点也一定比左子树中的任意节点都大，这个节点是右子树的最左叶子节点。可以统一2/3/5。</li>
<li>把左子树挂在右子树的最左叶子节点，退化为3</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func deleteNode(root *TreeNode, key int) *TreeNode &#123;
    if root == nil &#123; return root &#125;
    if root.Val == key &#123;
        if root.Right == nil &#123;
            return root.Left
        &#125;
        cur := root.Right
        for cur.Left != nil &#123;
            cur = cur.Left
        &#125;
        root.Val, cur.Val = cur.Val, root.Val
    &#125;
    root.Left = deleteNode(root.Left, key)
    root.Right = deleteNode(root.Right, key)
    return root
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="修剪二叉搜索树"><a class="header-anchor" href="#修剪二叉搜索树">¶</a>修剪二叉搜索树</h2>
<p><img src="https://img.shields.io/badge/leetcode-669-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/">修剪二叉搜索树</a></p>
<ul>
<li>前序遍历，如果节点值小于下界，左子树一定都小于下界，右子树不一定，可以先把右子树替换当前节点，递归判断。</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func trimBST(root *TreeNode, low int, high int) *TreeNode &#123;
    if root == nil &#123; return root &#125;
    if root.Val < low &#123;
        return trimBST(root.Right, low, high)
    &#125;
    if root.Val > high &#123;
        return trimBST(root.Left, low, high)
    &#125;
    root.Left = trimBST(root.Left, low, high)
    root.Right = trimBST(root.Right, low, high)
    return root
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="将有序数组转换为二叉搜索树"><a class="header-anchor" href="#将有序数组转换为二叉搜索树">¶</a>将有序数组转换为二叉搜索树</h2>
<p><img src="https://img.shields.io/badge/leetcode-108-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">将有序数组转换为二叉搜索树</a></p>
<ul>
<li>利用二叉搜索树有序特性，二分数组</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func sortedArrayToBST(nums []int) *TreeNode &#123;
    if len(nums) == 0 &#123; return nil &#125;
    mid := len(nums) / 2
    root := &TreeNode&#123;Val: nums[mid]&#125;
    root.Left = sortedArrayToBST(nums[:mid])
    root.Right = sortedArrayToBST(nums[mid+1:])
    return root
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="把二叉搜索树转换为累加树"><a class="header-anchor" href="#把二叉搜索树转换为累加树">¶</a>把二叉搜索树转换为累加树</h2>
<p><img src="https://img.shields.io/badge/leetcode-538-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">把二叉搜索树转换为累加树</a></p>
<ul>
<li>反中序遍历累加即可</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func traverse(root *TreeNode, val int) int &#123;
    if root == nil &#123; return val &#125;
    val = traverse(root.Right, val)
    root.Val += val
    val = root.Val
    val = traverse(root.Left, val)
    return val
&#125;

func convertBST(root *TreeNode) *TreeNode &#123;
    traverse(root, 0)
    return root
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
</p></div><div class="share"><span>Share</span>&nbsp;<span class="soc"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></span><span class="soc"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></span><span class="soc"><a target="_blank" rel="noopener" href="http://twitter.com/home?status=https://blog.kleon.space/cs/algo/tree/%20KLEON%20算法基础 - 树" class="fa fa-twitter"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/cs/algo/array/" title="算法基础 - 数组"><i class="fa fa-angle-double-left"></i>&nbsp;Previous post: 算法基础 - 数组</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/cs/algo/sort/" title="算法基础 - 排序">Next post: 算法基础 - 排序&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2022&nbsp;<a target="_blank" href="https://blog.kleon.space" rel="noopener noreferrer">Kleon</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>