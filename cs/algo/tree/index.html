<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>算法基础 - 树 · KLEON</title><meta name="description" content="树是常用的数据结构，应用较多的有二叉搜索树，二叉平衡搜索树(AVL树)，红黑树，多路平衡搜索树(B-树，B+树，B*树)等。

#基础
树可由链式结构或数组实现，遍历方式为前、中、后、层序遍历。
12345type TreeNode struct &amp;#123;  Val   int  Left  *"><meta name="og:description" content="树是常用的数据结构，应用较多的有二叉搜索树，二叉平衡搜索树(AVL树)，红黑树，多路平衡搜索树(B-树，B+树，B*树)等。

#基础
树可由链式结构或数组实现，遍历方式为前、中、后、层序遍历。
12345type TreeNode struct &amp;#123;  Val   int  Left  *"><meta name="twitter:site" content="KLEON"><meta name="twitter:title" content="算法基础 - 树"><meta name="twitter:card" content="summary"><meta name="keywords" content=""><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/github.min.css"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 6.1.0"></head><body><div id="stage" class="container"><div class="row"><div id="side-bar" class="col-sm-3 col-xs-12 side-container invisible"><div class="vertical-text site-title"><h3 tabindex="-1" class="site-title-small"><a href="/" class="a-title"></a></h3><h1 tabindex="-1" class="site-title-large"><a href="/" class="a-title">自说自话</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div id="site-nav" class="site-title-links"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li><li><a href="/categories">Categories</a></li><li><a href="/tags">Tags</a></li><li><a href="/googlebe23cb0bc55fc412.html"></a></li><li><a href="/about/index.html"></a></li><li class="soc"><a href="https://github.com/kleon1024" target="_blank" rel="noopener noreferrer" aria-label="Github"><i class="fa fa-github">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2022&nbsp;<a target="_blank" href="https://blog.kleon.space" rel="noopener noreferrer">Kleon</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div id="main-container" class="col-sm-9 col-xs-12 main-container invisible"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>算法基础 - 树</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2021-03-14</span><span class="date meta-item">Updated at&nbsp;2021-03-25</span><span class="meta-item"><i class="fa fa-folder"></i><span>&nbsp;</span><a href="/categories/算法/" title="算法" class="a-tag">算法</a><span>&nbsp;</span></span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a href="/tags/算法/" title="算法" class="a-tag">算法</a><span>&nbsp;</span><a href="/tags/数据结构/" title="数据结构" class="a-tag">数据结构</a><span>&nbsp;</span></span></p><p class="post-abstract"><p>树是常用的数据结构，应用较多的有二叉搜索树，二叉平衡搜索树(AVL树)，红黑树，多路平衡搜索树(B-树，B+树，B*树)等。</p>
<span id="more"></span>
<h1><a href="#ji-chu" class="header-anchor">#</a><span id="ji-chu">基础</span></h1>
<p>树可由链式结构或数组实现，遍历方式为前、中、后、层序遍历。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">type TreeNode struct &#123;<br>  Val   int<br>  Left  *TreeNode<br>  Right *TreeNode<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#shu" class="header-anchor">#</a><span id="shu">树</span></h2>
<p>有向无环非线性数据结构，每个节点可以指向多个节点，但至多有一个节点指向自身。</p>
<h2><a href="#er-cha-shu" class="header-anchor">#</a><span id="er-cha-shu">二叉树</span></h2>
<p>每个节点至多只能指向两个节点。</p>
<h2><a href="#man-er-cha-shu" class="header-anchor">#</a><span id="man-er-cha-shu">满二叉树</span></h2>
<p>只有度为0和2的节点，并且度为0的节点在同一层上。</p>
<h2><a href="#wan-quan-er-cha-shu" class="header-anchor">#</a><span id="wan-quan-er-cha-shu">完全二叉树</span></h2>
<p>除了最底层节点可能没填满外，其余层节点数均达到最大值，并且最下面一层的节点应集中在最左侧。</p>
<h2><a href="#er-cha-sou-suo-shu" class="header-anchor">#</a><span id="er-cha-sou-suo-shu">二叉搜索树</span></h2>
<p>一种朴素的有序树结构，左子节点均小于父节点，右子节点均大于父节点。当插入新值时由根节点开始按以上规则逐层比较，直到找到合适的叶节点位置。</p>
<ul>
<li>优点：不需要在插入数据时调整结构</li>
<li>缺点：性能易受数据插入顺序影响，最差情况为顺序插入，退化为链表。</li>
</ul>
<h2><a href="#ping-heng-er-cha-sou-suo-shu-avl-shu" class="header-anchor">#</a><span id="ping-heng-er-cha-sou-suo-shu-avl-shu">平衡二叉搜索树(AVL树)</span></h2>
<p>二叉搜索树的改进，又称AVL(Adelson-Velsky and Landis)树，引入平衡因子，通过旋转操作保证所有子树高度差不超过1。</p>
<ul>
<li>优点：相比二叉树更平衡，极端情况下表现依然足够好。</li>
<li>缺点：在读写比例差不多的情况下，旋转操作过多。</li>
</ul>
<h2><a href="#hong-hei-shu-rb-shu" class="header-anchor">#</a><span id="hong-hei-shu-rb-shu">红黑树(RB树)</span></h2>
<p>AVL树的改进，引入着色规则，通过旋转和着色操作保证所有子树高度差不超过2。Map可以通过红黑树实现。</p>
<ul>
<li>优点：写性能更高。</li>
<li>缺点：查询性能弱于AVL树，因为子树高度差比AVL多一层，最差情况会多一次比较。</li>
</ul>
<h2><a href="#b-shu-b-tree-b-shu" class="header-anchor">#</a><span id="b-shu-b-tree-b-shu">B-树(B-Tree, B树)</span></h2>
<p>多路搜索树，又称B树，用于数据索引，子节点内放指针和数据块。通过分裂操作维持树结构。</p>
<h2><a href="#b-shu" class="header-anchor">#</a><span id="b-shu">B+树</span></h2>
<p>B-树改进型，子节点内不放数据块，统一放在叶节点内。查询性能稳定，IO数据利用率高。</p>
<h2><a href="#b-shu" class="header-anchor">#</a><span id="b-shu">B*树</span></h2>
<p>B+树改进型，增加子节点间指针，如果兄弟节点数据未满，则将一部分指针移到兄弟节点，并修改父节点关键字，将结点的最低利用率从1/2提高到2/3。</p>
<h1><a href="#shi-jian" class="header-anchor">#</a><span id="shi-jian">实践</span></h1>
<h2><a href="#er-cha-shu-de-qian-xu-bian-li" class="header-anchor">#</a><span id="er-cha-shu-de-qian-xu-bian-li">二叉树的前序遍历</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-144-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">二叉树的前序遍历</a></p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br>func traverse(n *TreeNode, result *[]int) &#123;<br>    if n == nil &#123; return &#125;<br>    *result = append(*result, n.Val)<br>    traverse(n.Left, result)<br>    traverse(n.Right, result)<br>&#125;<br><br>func preorderTraversal(root *TreeNode) []int &#123;<br>    result := []int&#123;&#125;<br>    traverse(root, &amp;result)<br>    return result<br>&#125;<br><br>//<br><br>/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br>func preorderTraversal(root *TreeNode) []int &#123;<br>    result := []int&#123;&#125;<br>    if root == nil &#123; return result &#125;<br>    result = append(result, root.Val)<br>    result = append(result, preorderTraversal(root.Left)...)<br>    result = append(result, preorderTraversal(root.Right)...)<br>    return result<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>迭代</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br>func preorderTraversal(root *TreeNode) []int &#123;<br>    stack := []*TreeNode&#123;&#125;<br>    result := []int&#123;&#125;<br>    if root != nil &#123;<br>        stack = append(stack, root)<br>    &#125;<br>    for len(stack) &gt; 0 &#123;<br>        node := stack[len(stack) - 1]<br>        stack = stack[:len(stack) - 1]<br>        if node != nil &#123;<br>            if node.Right != nil &#123;<br>                stack = append(stack, node.Right)<br>            &#125;<br>            if node.Left != nil &#123;<br>                stack = append(stack, node.Left)<br>            &#125;<br>            stack = append(stack, node)<br>            stack = append(stack, nil)<br>        &#125; else &#123;<br>            node = stack[len(stack) - 1]<br>            stack = stack[:len(stack) - 1]<br>            result = append(result, node.Val)<br>        &#125;<br>    &#125;<br>    return result<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#er-cha-shu-de-hou-xu-bian-li" class="header-anchor">#</a><span id="er-cha-shu-de-hou-xu-bian-li">二叉树的后序遍历</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-145-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">二叉树的后序遍历</a></p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br>func postorderTraversal(root *TreeNode) []int &#123;<br>    result := []int&#123;&#125;<br>    if root == nil &#123; return result &#125;<br>    result = append(result, postorderTraversal(root.Left)...)<br>    result = append(result, postorderTraversal(root.Right)...)<br>    result = append(result, root.Val)<br>    return result<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>迭代</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br>func postorderTraversal(root *TreeNode) []int &#123;<br>    stack := []*TreeNode&#123;&#125;<br>    result := []int&#123;&#125;<br>    if root != nil &#123;<br>        stack = append(stack, root)<br>    &#125;<br>    for len(stack) &gt; 0 &#123;<br>        node := stack[len(stack) - 1]<br>        stack = stack[:len(stack) - 1]<br>        if node != nil &#123;<br>            stack = append(stack, node)<br>            stack = append(stack, nil)<br>            if node.Right != nil &#123;<br>                stack = append(stack, node.Right)<br>            &#125;<br>            if node.Left != nil &#123;<br>                stack = append(stack, node.Left)<br>            &#125;<br>        &#125; else &#123;<br>            node = stack[len(stack) - 1]<br>            stack = stack[:len(stack) - 1]<br>            result = append(result, node.Val)<br>        &#125;<br>    &#125;<br>    return result<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#er-cha-shu-de-zhong-xu-bian-li" class="header-anchor">#</a><span id="er-cha-shu-de-zhong-xu-bian-li">二叉树的中序遍历</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-94-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">二叉树的中序遍历</a></p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br>func inorderTraversal(root *TreeNode) []int &#123;<br>    result := []int&#123;&#125;<br>    if root == nil &#123; return result &#125;<br>    result = append(result, inorderTraversal(root.Left)...)<br>    result = append(result, root.Val)<br>    result = append(result, inorderTraversal(root.Right)...)<br>    return result<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>迭代</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br>func inorderTraversal(root *TreeNode) []int &#123;<br>    stack := []*TreeNode&#123;&#125;<br>    result := []int&#123;&#125;<br>    if root != nil &#123;<br>        stack = append(stack, root)<br>    &#125;<br>    for len(stack) &gt; 0 &#123;<br>        node := stack[len(stack) - 1]<br>        stack = stack[:len(stack) - 1]<br>        if node != nil &#123;<br>            if node.Right != nil &#123;<br>                stack = append(stack, node.Right)<br>            &#125;<br>            stack = append(stack, node)<br>            stack = append(stack, nil)<br>            if node.Left != nil &#123;<br>                stack = append(stack, node.Left)<br>            &#125;<br>        &#125; else &#123;<br>            node = stack[len(stack) - 1]<br>            stack = stack[:len(stack) - 1]<br>            result = append(result, node.Val)<br>        &#125;<br>    &#125;<br>    return result<br>&#125;<br></code></pre></td></tr></table></figure>
<p>C++ 版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">void preorder(TreeNode* root, vector&lt;int&gt;&amp; v) &#123;<br>    if (root == nullptr) return;<br>    <br>    v.push_back(root-&gt;val);<br>    preorder(root-&gt;left, v);<br>    preorder(root-&gt;right, v);<br>&#125;<br><br>void postorder(TreeNode* root, vector&lt;int&gt;&amp; v) &#123;<br>    if (root == nullptr) return;<br><br>    postorder(root-&gt;left, v);<br>    postorder(root-&gt;right, v);<br>    v.push_back(root-&gt;val);<br>&#125;<br><br>void midorder(TreeNode* root, vector&lt;int&gt;&amp; v) &#123;<br>    if (root == nullptr) return;<br><br>    midorder(root-&gt;left, v);<br>    v.push_back(root-&gt;val);<br>    midorder(root-&gt;right, v);<br>&#125;<br><br>void preorderIter(TreeNode* root, vector&lt;int&gt;&amp; v) &#123;<br>    std::stack&lt;TreeNode*&gt; s;<br>    <br>    if (root != nullptr) &#123;<br>        s.push(root);<br>    &#125;<br>    <br>    TreeNode* node = nullptr;<br>    while(s.size() &gt; 0) &#123;<br>        node = s.top();<br>        s.pop();<br>        if (node) &#123;<br>            if (node-&gt;right) &#123;<br>                s.push(node-&gt;right);<br>            &#125;<br>            if (node-&gt;left) &#123;<br>                s.push(node-&gt;left);<br>            &#125;<br>            s.push(node);<br>            s.push(nullptr);<br>        &#125; else &#123;<br>            node = s.top();<br>            s.pop();<br>            v.push_back(node-&gt;val);<br>        &#125;<br>    &#125;<br>&#125;<br><br>void postorderIter(TreeNode* root, vector&lt;int&gt;&amp; v) &#123;<br>    std::stack&lt;TreeNode*&gt; s;<br>    <br>    if (root != nullptr) &#123;<br>        s.push(root);<br>    &#125;<br>    <br>    TreeNode* node = nullptr;<br>    while(s.size() &gt; 0) &#123;<br>        node = s.top();<br>        s.pop();<br>        if (node) &#123;<br>            s.push(node);<br>            s.push(nullptr);<br>            if (node-&gt;right) &#123;<br>                s.push(node-&gt;right);<br>            &#125;<br>            if (node-&gt;left) &#123;<br>                s.push(node-&gt;left);<br>            &#125;<br>        &#125; else &#123;<br>            node = s.top();<br>            s.pop();<br>            v.push_back(node-&gt;val);<br>        &#125;<br>    &#125;<br>&#125;<br><br>void midorderIter(TreeNode* root, vector&lt;int&gt;&amp; v) &#123;<br>    std::stack&lt;TreeNode*&gt; s;<br>    <br>    if (root != nullptr) &#123;<br>        s.push(root);<br>    &#125;<br>    <br>    TreeNode* node = nullptr;<br>    while(s.size() &gt; 0) &#123;<br>        node = s.top();<br>        s.pop();<br>        if (node) &#123;<br>            if (node-&gt;right) &#123;<br>                s.push(node-&gt;right);<br>            &#125;<br>            s.push(node);<br>            s.push(nullptr);<br>            if (node-&gt;left) &#123;<br>                s.push(node-&gt;left);<br>            &#125;<br>        &#125; else &#123;<br>            node = s.top();<br>            s.pop();<br>            v.push_back(node-&gt;val);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#er-cha-shu-de-ceng-xu-bian-li" class="header-anchor">#</a><span id="er-cha-shu-de-ceng-xu-bian-li">二叉树的层序遍历</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-102-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">二叉树的层序遍历</a></p>
<ul>
<li>队列先进先出</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br>func levelOrder(root *TreeNode) [][]int &#123;<br>    queue := []*TreeNode&#123;&#125;<br>    result := [][]int&#123;&#125;<br>    if root != nil &#123;<br>        queue = append(queue, root)<br>    &#125;<br>    for len(queue) &gt; 0 &#123;<br>        size := len(queue)<br>        vec := []int&#123;&#125;<br>        for i := 0; i &lt; size; i++ &#123;<br>            node := queue[0]<br>            queue = queue[1:]<br>            vec = append(vec, node.Val)<br>            if node.Left != nil &#123;<br>                queue = append(queue, node.Left)<br>            &#125;<br>            if node.Right != nil &#123;<br>                queue = append(queue, node.Right)<br>            &#125;<br>        &#125;<br>        result = append(result, vec)<br>    &#125;<br>    return result<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#er-cha-shu-de-ceng-xu-bian-li-ii" class="header-anchor">#</a><span id="er-cha-shu-de-ceng-xu-bian-li-ii">二叉树的层序遍历II</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-107-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">二叉树的层序遍历II</a></p>
<ul>
<li>同二叉树的层序遍历</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br>func levelOrderBottom(root *TreeNode) [][]int &#123;<br>    queue := []*TreeNode&#123;&#125;<br>    result := [][]int&#123;&#125;<br>    if root != nil &#123;<br>        queue = append(queue, root)<br>    &#125;<br>    for len(queue) &gt; 0 &#123;<br>        size := len(queue)<br>        vec := []int&#123;&#125;<br>        for i := 0; i &lt; size; i++ &#123;<br>            node := queue[0]<br>            queue = queue[1:]<br>            vec = append(vec, node.Val)<br>            if node.Left != nil &#123;<br>                queue = append(queue, node.Left)<br>            &#125;<br>            if node.Right != nil &#123;<br>                queue = append(queue, node.Right)<br>            &#125;<br>        &#125;<br>        result = append(result, vec)<br>    &#125;<br>    for i, j := 0, len(result)-1; i &lt; j; i, j = i+1, j-1 &#123;<br>        result[i], result[j] = result[j], result[i]<br>    &#125;<br>    return result<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#ceng-xu-bian-li-huo-qu-er-cha-shu-de-you-shi-tu" class="header-anchor">#</a><span id="ceng-xu-bian-li-huo-qu-er-cha-shu-de-you-shi-tu">层序遍历获取二叉树的右视图</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-199-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-right-side-view/">二叉树的右视图</a></p>
<ul>
<li>同二叉树的层序遍历</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br>func rightSideView(root *TreeNode) []int &#123;<br>    queue := []*TreeNode&#123;&#125;<br>    result := []int&#123;&#125;<br>    if root != nil &#123;<br>        queue = append(queue, root)<br>    &#125;<br>    for len(queue) &gt; 0 &#123;<br>        size := len(queue)<br>        for i := 0; i &lt; size; i++ &#123;<br>            node := queue[0]<br>            queue = queue[1:]<br>            if i == size - 1 &#123;<br>                result = append(result, node.Val)<br>            &#125;<br>            if node.Left != nil &#123;<br>                queue = append(queue, node.Left)<br>            &#125;<br>            if node.Right != nil &#123;<br>                queue = append(queue, node.Right)<br>            &#125;<br>        &#125;<br>    &#125;<br>    return result<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#ceng-xu-bian-li-huo-qu-er-cha-shu-de-ceng-ping-jun-zhi" class="header-anchor">#</a><span id="ceng-xu-bian-li-huo-qu-er-cha-shu-de-ceng-ping-jun-zhi">层序遍历获取二叉树的层平均值</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-637-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/">二叉树的层平均值</a></p>
<ul>
<li>同二叉树的层序遍历</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br>func averageOfLevels(root *TreeNode) []float64 &#123;<br>    result := []float64&#123;&#125;<br>    if root == nil &#123;<br>        return result<br>    &#125;<br>    queue := list.New()<br>    queue.PushBack(root)<br>    for queue.Len() &gt; 0 &#123;<br>        size := queue.Len()<br>        sum := 0<br>        for i := 0; i &lt; size; i++ &#123;<br>            node := queue.Front()<br>            queue.Remove(node)<br>            t := node.Value.(*TreeNode)<br>            sum += t.Val<br>            if t.Left != nil &#123;<br>                queue.PushBack(t.Left)<br>            &#125;<br>            if t.Right != nil &#123;<br>                queue.PushBack(t.Right)<br>            &#125;<br>        &#125;<br>        result = append(result, float64(sum) / float64(size))<br>    &#125;<br>    return result<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#ceng-xu-bian-li-huo-qu-n-cha-shu-de-ceng-xu-bian-li" class="header-anchor">#</a><span id="ceng-xu-bian-li-huo-qu-n-cha-shu-de-ceng-xu-bian-li">层序遍历获取N叉树的层序遍历</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-429-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/">N叉树的层序遍历</a></p>
<ul>
<li>同二叉树的层序遍历</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a Node.<br> * type Node struct &#123;<br> *     Val int<br> *     Children []*Node<br> * &#125;<br> */<br><br>func levelOrder(root *Node) [][]int &#123;<br>    queue := []*Node&#123;&#125;<br>    result := [][]int&#123;&#125;<br>    if root != nil &#123;<br>        queue = append(queue, root)<br>    &#125;<br>    for len(queue) &gt; 0 &#123;<br>        size := len(queue)<br>        vec := []int&#123;&#125;<br>        for i := 0; i &lt; size; i++ &#123;<br>            node := queue[0]<br>            queue = queue[1:]<br>            vec = append(vec, node.Val)<br>            for _, n := range node.Children &#123;<br>                queue = append(queue, n)<br>            &#125;<br>        &#125;<br>        result = append(result, vec)<br>    &#125;<br>    return result<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#qian-xu-bian-li-er-cha-shu-zhan-kai-wei-lian-biao" class="header-anchor">#</a><span id="qian-xu-bian-li-er-cha-shu-zhan-kai-wei-lian-biao">前序遍历二叉树展开为链表</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-114-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">二叉树展开为链表</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br>func flatten(root *TreeNode)  &#123;<br>    stack := []*TreeNode&#123;&#125;<br>    list := []*TreeNode&#123;&#125;<br>    node := root<br>    for node != nil || len(stack) &gt; 0 &#123;<br>        for node != nil &#123;<br>            list = append(list, node)<br>            stack = append(stack, node)<br>            node = node.Left<br>        &#125;<br>        node = stack[len(stack) - 1]<br>        node = node.Right<br>        stack = stack[:len(stack) - 1]<br>    &#125;<br><br>    for i := 1; i &lt; len(list); i++ &#123;<br>        prev, curr := list[i-1], list[i]<br>        prev.Left, prev.Right = nil, curr<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h2><a href="#fan-zhuan-er-cha-shu" class="header-anchor">#</a><span id="fan-zhuan-er-cha-shu">翻转二叉树</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-226-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/invert-binary-tree/">翻转二叉树</a></p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br>func invertTree(root *TreeNode) *TreeNode &#123;<br>    if root == nil &#123;<br>        return root<br>    &#125;<br>    root.Left, root.Right = root.Right, root.Left<br>    invertTree(root.Left)<br>    invertTree(root.Right)<br>    return root<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>迭代</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br>func invertTree(root *TreeNode) *TreeNode &#123;<br>    if root == nil &#123;<br>        return root<br>    &#125;<br>    stack := []*TreeNode&#123;&#125;<br>    stack = append(stack, root)<br>    for len(stack) &gt; 0 &#123;<br>        node := stack[len(stack) - 1]<br>        stack = stack[:len(stack) - 1]<br>        node.Left, node.Right = node.Right, node.Left<br>        if node.Right != nil &#123;<br>            stack = append(stack, node.Right)<br>        &#125;<br>        if node.Left != nil &#123;<br>            stack = append(stack, node.Left)<br>        &#125;<br>    &#125;<br>    return root<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>层序</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br>func invertTree(root *TreeNode) *TreeNode &#123;<br>    queue := []*TreeNode&#123;&#125;<br>    if root == nil &#123;<br>        return root<br>    &#125;<br>    queue = append(queue, root)<br>    for len(queue) &gt; 0 &#123;<br>        size := len(queue)<br>        for i := 0; i &lt; size; i++ &#123;<br>            node := queue[0]<br>            queue = queue[1:]<br>            node.Left, node.Right = node.Right, node.Left<br>            if node.Left != nil &#123;<br>                queue = append(queue, node.Left)<br>            &#125;<br>            if node.Right != nil &#123;<br>                queue = append(queue, node.Right)<br>            &#125;<br>        &#125;<br>    &#125;<br>    return root<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#dui-cheng-er-cha-shu" class="header-anchor">#</a><span id="dui-cheng-er-cha-shu">对称二叉树</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-101-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/symmetric-tree/">对称二叉树</a></p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br>func compare(left *TreeNode, right *TreeNode) bool &#123;<br>    if right != nil &amp;&amp; left == nil &#123; return false &#125;<br>    if right == nil &amp;&amp; left != nil &#123; return false &#125;<br>    if right == nil &amp;&amp; left == nil &#123; return true &#125;<br>    if right.Val != left.Val &#123; return false &#125;<br><br>    outside := compare(left.Left, right.Right)<br>    inside := compare(left.Right, right.Left)<br>    return outside &amp;&amp; inside<br>&#125;<br><br>func isSymmetric(root *TreeNode) bool &#123;<br>    if root == nil &#123; return true &#125;<br>    return compare(root.Left, root.Right)<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>迭代，队列和栈均可</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br>func isSymmetric(root *TreeNode) bool &#123;<br>    if root == nil &#123; return true &#125;<br>    queue := []*TreeNode&#123;&#125;<br>    queue = append(queue, root.Left)<br>    queue = append(queue, root.Right)<br><br>    for len(queue) &gt; 0 &#123;<br>        left := queue[0]; queue = queue[1:]<br>        right := queue[0]; queue = queue[1:]<br>        if left == nil &amp;&amp; right == nil &#123;<br>            continue<br>        &#125;<br>        if left == nil || right == nil || left.Val != right.Val &#123;<br>            return false<br>        &#125;<br>        queue = append(queue, left.Left)<br>        queue = append(queue, right.Right)<br>        queue = append(queue, left.Right)<br>        queue = append(queue, right.Left)<br>    &#125;<br>    return true<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#er-cha-shu-de-zui-da-shen-du" class="header-anchor">#</a><span id="er-cha-shu-de-zui-da-shen-du">二叉树的最大深度</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-104-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">二叉树的最大深度</a></p>
<ul>
<li>后序遍历</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br>func Max(x, y int) int &#123;<br>    if x &lt; y &#123; return y &#125;<br>    return x<br>&#125;<br><br>func depth(node *TreeNode) int &#123;<br>    if node == nil &#123; return 0 &#125;<br>    return 1 + Max(depth(node.Left), depth(node.Right))<br>&#125;<br><br>func maxDepth(root *TreeNode) int &#123;<br>    return depth(root)<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>层序遍历</li>
</ul>
<h2><a href="#n-cha-shu-de-zui-da-shen-du" class="header-anchor">#</a><span id="n-cha-shu-de-zui-da-shen-du">N叉树的最大深度</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-104-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">N叉树的最大深度</a></p>
<ul>
<li>迭代，同二叉树</li>
<li>层序遍历</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a Node.<br> * type Node struct &#123;<br> *     Val int<br> *     Children []*Node<br> * &#125;<br> */<br><br>func maxDepth(root *Node) int &#123;<br>    queue := []*Node&#123;&#125;<br>    depth := 0<br>    if root == nil &#123; return depth &#125;<br>    queue = append(queue, root)<br>    for len(queue) &gt; 0 &#123;<br>        size := len(queue)<br>        depth++<br>        for i := 0; i &lt; size; i++ &#123;<br>            node := queue[0]<br>            queue = queue[1:]<br>            for _, n := range node.Children &#123;<br>                if n != nil &#123;<br>                    queue = append(queue, n)<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    return depth<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#er-cha-shu-de-zui-xiao-shen-du" class="header-anchor">#</a><span id="er-cha-shu-de-zui-xiao-shen-du">二叉树的最小深度</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-111-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">二叉树的最小深度</a></p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br>func Min(x, y int) int &#123;<br>    if x &gt; y &#123; return y &#125;<br>    return x<br>&#125;<br><br>func depth(node *TreeNode) int &#123;<br>    if node == nil &#123; return 0 &#125;<br>    leftDepth := depth(node.Left)<br>    rightDepth := depth(node.Right)<br><br>    if node.Left == nil &amp;&amp; node.Right != nil &#123;<br>        return 1 + rightDepth<br>    &#125;<br><br>    if node.Right == nil &amp;&amp; node.Left != nil &#123;<br>        return 1 + leftDepth<br>    &#125;<br><br>    return 1 + Min(leftDepth, rightDepth)<br>&#125;<br><br><br>func minDepth(root *TreeNode) int &#123;<br>    return depth(root)<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>层序遍历</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br>func minDepth(root *TreeNode) int &#123;<br>    queue := []*TreeNode&#123;&#125;<br>    depth := 0<br>    if root == nil &#123; return depth &#125;<br>    queue = append(queue, root)<br>    for len(queue) &gt; 0 &#123;<br>        size := len(queue)<br>        depth++<br>        for i := 0; i &lt; size; i++ &#123;<br>            node := queue[0]<br>            queue = queue[1:]<br>            if node.Left == nil &amp;&amp; node.Right == nil &#123;<br>                return depth<br>            &#125;<br>            if node.Left != nil &#123;<br>                queue = append(queue, node.Left)<br>            &#125;<br>            if node.Right != nil &#123;<br>                queue = append(queue, node.Right)<br>            &#125;<br>        &#125;<br>    &#125;<br>    return depth<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#wan-quan-er-cha-shu-de-jie-dian-shu" class="header-anchor">#</a><span id="wan-quan-er-cha-shu-de-jie-dian-shu">完全二叉树的节点数</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-222-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-complete-tree-nodes/">完全二叉树的节点个数</a></p>
<ul>
<li>前序遍历递归</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br>func nodeNum(node *TreeNode) int &#123;<br>    if node == nil &#123; return 0 &#125;<br>    return 1 + nodeNum(node.Left) + nodeNum(node.Right)<br>&#125;<br><br>func countNodes(root *TreeNode) int &#123;<br>    return nodeNum(root)<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>层序遍历迭代</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br>func countNodes(root *TreeNode) int &#123;<br>    queue := []*TreeNode&#123;&#125;<br>    count := 0<br>    if root == nil &#123; return count &#125;<br>    queue = append(queue, root)<br>    for len(queue) &gt; 0 &#123;<br>        size := len(queue)<br>        for i := 0; i &lt; size; i++ &#123;<br>            node := queue[0]<br>            queue = queue[1:]<br>            count++<br>            if node.Left != nil &#123;<br>                queue = append(queue, node.Left)<br>            &#125;<br>            if node.Right != nil &#123;<br>                queue = append(queue, node.Right)<br>            &#125;<br>        &#125;<br>    &#125;<br>    return count<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#ping-heng-er-cha-shu" class="header-anchor">#</a><span id="ping-heng-er-cha-shu">平衡二叉树</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-110-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/balanced-binary-tree/">平衡二叉树</a></p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br>func Max(x, y int) int &#123;<br>    if x &gt; y &#123; return x &#125;<br>    return y<br>&#125;<br><br>func depth(node *TreeNode) int &#123;<br>    if node == nil &#123; return 0 &#125;<br>    leftDepth := depth(node.Left)<br>    if leftDepth &lt; 0 &#123; return -1 &#125;<br>    rightDepth := depth(node.Right)<br>    if rightDepth &lt; 0 &#123; return -1 &#125;<br>    if math.Abs(float64(leftDepth) - float64(rightDepth)) &gt; 1 &#123;<br>        return -1<br>    &#125;<br>    return 1 + Max(leftDepth, rightDepth)<br>&#125;<br><br>func isBalanced(root *TreeNode) bool &#123;<br>    return depth(root) &gt;= 0<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#er-cha-shu-de-suo-you-lu-jing" class="header-anchor">#</a><span id="er-cha-shu-de-suo-you-lu-jing">二叉树的所有路径</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-257-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-paths/">二叉树的所有路径</a></p>
<ul>
<li>谦虚遍历递归</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br>func path(node *TreeNode, pathStr string) []string &#123;<br>    results := []string&#123;&#125;<br>    pathStr += strconv.Itoa(node.Val)<br>    if node.Left == nil &amp;&amp; node.Right == nil &#123;<br>        results = append(results, pathStr)<br>    &#125;<br>    pathStr += &quot;-&gt;&quot;<br>    if node.Left != nil &#123;<br>        results = append(results, path(node.Left, pathStr)...)<br>    &#125;<br>    if node.Right != nil &#123;<br>        results = append(results, path(node.Right, pathStr)...)<br>    &#125;<br>    return results<br>&#125;<br><br>func binaryTreePaths(root *TreeNode) []string &#123;<br>    if root == nil &#123; return []string&#123;&#125; &#125;<br>    return path(root, &quot;&quot;)<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#xiang-tong-de-shu" class="header-anchor">#</a><span id="xiang-tong-de-shu">相同的树</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-100-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/same-tree/">相同的树</a></p>
<ul>
<li>递归，同对称树</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br>func isSameTree(p *TreeNode, q *TreeNode) bool &#123;<br>    if p != nil &amp;&amp; q == nil &#123; return false &#125;<br>    if p == nil &amp;&amp; q != nil &#123; return false &#125;<br>    if p == nil &amp;&amp; q == nil &#123; return true &#125;<br>    if p.Val != q.Val &#123; return false &#125;<br><br>    left := isSameTree(p.Left, q.Left)<br>    right := isSameTree(p.Right, q.Right)<br>    return left &amp;&amp; right<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>迭代，队列和栈均可，同对称树</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br>func isSameTree(p *TreeNode, q *TreeNode) bool &#123;<br>    queue := []*TreeNode&#123;&#125;<br>    queue = append(queue, p)<br>    queue = append(queue, q)<br>    for len(queue) &gt; 0 &#123;<br>        left := queue[0]; queue = queue[1:]<br>        right := queue[0]; queue = queue[1:]<br>        if left == nil &amp;&amp; right == nil &#123;<br>            continue<br>        &#125;<br>        if left == nil || right == nil || left.Val != right.Val &#123;<br>            return false<br>        &#125;<br>        queue = append(queue, left.Left)<br>        queue = append(queue, right.Left)<br>        queue = append(queue, left.Right)<br>        queue = append(queue, right.Right)<br>    &#125;<br>    return true<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#zuo-xie-zi-zhi-he" class="header-anchor">#</a><span id="zuo-xie-zi-zhi-he">左叶子之和</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-404-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-of-left-leaves/">左叶子之和</a></p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br>func sumOfLeftLeaves(root *TreeNode) int &#123;<br>    if root == nil &#123; return 0 &#125;<br>    sum := 0<br>    if root.Left != nil &amp;&amp; root.Left.Left == nil &amp;&amp; root.Left.Right == nil &#123;<br>        sum = root.Left.Val<br>    &#125;<br>    return sum + sumOfLeftLeaves(root.Left) + sumOfLeftLeaves(root.Right)<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#zhao-shu-zuo-xia-jiao-de-zhi" class="header-anchor">#</a><span id="zhao-shu-zuo-xia-jiao-de-zhi">找树左下角的值</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-513-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/">找树左下角的值</a></p>
<ul>
<li>层序遍历</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br>func findBottomLeftValue(root *TreeNode) int &#123;<br>    queue := []*TreeNode&#123;root&#125;<br>    result := 0<br>    for len(queue) &gt; 0 &#123;<br>        size := len(queue)<br>        for i := 0; i &lt; size; i++ &#123;<br>            node := queue[0]<br>            queue = queue[1:]<br>            if i == 0 &#123; result = node.Val &#125;<br>            if node.Left != nil &#123;<br>                queue = append(queue, node.Left)<br>            &#125;<br>            if node.Right != nil &#123;<br>                queue = append(queue, node.Right)<br>            &#125;<br>        &#125;<br>    &#125;<br>    return result<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#lu-jing-zong-he" class="header-anchor">#</a><span id="lu-jing-zong-he">路径总和</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-112-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum/">路径总和</a></p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br>func hasPathSum(root *TreeNode, targetSum int) bool &#123;<br>    if root == nil &#123; return false &#125;<br>    if root.Left == nil &amp;&amp; root.Right == nil &amp;&amp; root.Val == targetSum &#123;<br>        return true<br>    &#125;<br>    nextSum := targetSum - root.Val<br>    return hasPathSum(root.Left, nextSum) || hasPathSum(root.Right, nextSum)<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#lu-jing-zong-he-ii" class="header-anchor">#</a><span id="lu-jing-zong-he-ii">路径总和II</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-113-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-ii/">路径总和II</a></p>
<ul>
<li>递归，注意Go的引用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br>func traverse(root *TreeNode, targetSum int, res *[][]int, path[]int) &#123;<br>    path = append(path, root.Val)<br>    nextSum := targetSum - root.Val<br>    if root.Left == nil &amp;&amp; root.Right == nil &#123;<br>        if nextSum == 0 &#123;<br>            tmp := make([]int, len(path))<br>            copy(tmp, path)<br>            *res = append(*res, tmp)<br>        &#125;<br>        return<br>    &#125;<br><br>    if root.Left != nil &#123;<br>        traverse(root.Left, nextSum, res, path)<br>    &#125;<br>    if root.Right != nil &#123;<br>        traverse(root.Right, nextSum, res, path)<br>    &#125;<br>&#125;<br><br>func pathSum(root *TreeNode, targetSum int) [][]int &#123;<br>    result := [][]int&#123;&#125;<br>    path := []int&#123;&#125;<br>    if root == nil &#123; return result &#125;<br>    traverse(root, targetSum, &amp;result, path)<br>    return result<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#cong-zhong-xu-yu-hou-xu-bian-li-xu-lie-gou-zao-er-cha-shu" class="header-anchor">#</a><span id="cong-zhong-xu-yu-hou-xu-bian-li-xu-lie-gou-zao-er-cha-shu">从中序与后序遍历序列构造二叉树</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-106-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">从中序与后序遍历序列构造二叉树</a></p>
<ul>
<li>先取后序遍历最后一个值作为当前根节点，从中序遍历比对确定左右子树切割位置，后序遍历子树大小应和中序遍历数组子序列一致，将切分出的左右子序列递归。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br>type TreeBuilder struct &#123;<br>    inorder []int<br>    postorder []int<br>&#125;<br><br>func (t TreeBuilder)traverse(inStart, inEnd, poStart, poEnd int) *TreeNode &#123;<br>    if poStart == poEnd &#123; return nil &#125;<br>    rootVal := t.postorder[poEnd - 1]<br>    root := &amp;TreeNode&#123;Val: rootVal&#125;<br>    if poEnd - poStart == 1 &#123; return root &#125;<br><br>    var inMid int<br>    for inMid = inStart; inMid &lt; inEnd; inMid++ &#123;<br>        if t.inorder[inMid] == rootVal &#123; break &#125;<br>    &#125;<br><br>    poMid := poStart + inMid - inStart<br>    root.Left = t.traverse(inStart, inMid, poStart, poMid)<br>    root.Right = t.traverse(inMid + 1, inEnd, poMid, poEnd - 1)<br>    return root<br>&#125;<br><br>func buildTree(inorder []int, postorder []int) *TreeNode &#123;<br>    return TreeBuilder&#123;inorder, postorder&#125;.traverse(0, len(inorder), 0, len(postorder))<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#cong-zhong-xu-yu-qian-xu-bian-li-xu-lie-gou-zao-er-cha-shu" class="header-anchor">#</a><span id="cong-zhong-xu-yu-qian-xu-bian-li-xu-lie-gou-zao-er-cha-shu">从中序与前序遍历序列构造二叉树</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-105-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">从中序与前序遍历序列构造二叉树</a></p>
<ul>
<li>类似后序+中序</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br>type TreeBuilder struct &#123;<br>    inorder []int<br>    preorder []int<br>&#125;<br><br>func (t TreeBuilder)traverse(inStart, inEnd, prStart, prEnd int) *TreeNode &#123;<br>    // fmt.Printf(&quot;%v %v | %v %v \n&quot;, inStart, inEnd, prStart, prEnd)<br><br>    if prStart == prEnd &#123; return nil &#125;<br>    rootVal := t.preorder[prStart]<br>    root := &amp;TreeNode&#123;Val: rootVal&#125;<br>    if prEnd - prStart == 1 &#123; return root &#125;<br><br>    var inMid int<br>    for inMid = inStart; inMid &lt; inEnd; inMid++ &#123;<br>        if t.inorder[inMid] == rootVal &#123; break &#125;<br>    &#125;<br><br>    prMid := prStart + 1 + inMid - inStart<br>    root.Left = t.traverse(inStart, inMid, prStart + 1, prMid)<br>    root.Right = t.traverse(inMid + 1, inEnd, prMid, prEnd)<br>    return root<br>&#125;<br><br>func buildTree(preorder []int, inorder []int) *TreeNode &#123;<br>    return TreeBuilder&#123;inorder, preorder&#125;.traverse(0, len(inorder), 0, len(preorder))<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>改写成slice更简洁</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br>func buildTree(preorder []int, inorder []int) *TreeNode &#123;<br>    // fmt.Printf(&quot;%v | %v \n&quot;, preorder, inorder)<br>    if len(preorder) == 0 &#123; return nil &#125;<br>    rootVal := preorder[0]<br>    root := &amp;TreeNode&#123;Val: rootVal&#125;<br>    if len(preorder) == 1 &#123; return root &#125;<br><br>    var inMid int<br>    for inMid = 0; inMid &lt; len(inorder); inMid++ &#123;<br>        if inorder[inMid] == rootVal &#123; break &#125;<br>    &#125;<br><br>    root.Left = buildTree(preorder[1:1+inMid], inorder[:inMid])<br>    root.Right = buildTree(preorder[1+inMid:], inorder[inMid+1:])<br>    return root<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#zui-da-er-cha-shu" class="header-anchor">#</a><span id="zui-da-er-cha-shu">最大二叉树</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-654-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-binary-tree/">最大二叉树</a></p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br>func constructMaximumBinaryTree(nums []int) *TreeNode &#123;<br>    if len(nums) == 0 &#123; return nil &#125;<br>    max := nums[0]<br>    index := 0<br>    for i, v := range nums &#123;<br>        if v &gt; max &#123; <br>            max = v<br>            index = i<br>        &#125;<br>    &#125;<br>    root := &amp;TreeNode&#123;Val: max&#125;<br>    root.Left = constructMaximumBinaryTree(nums[:index])<br>    root.Right = constructMaximumBinaryTree(nums[index+1:])<br>    return root<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#he-bing-er-cha-shu" class="header-anchor">#</a><span id="he-bing-er-cha-shu">合并二叉树</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-617-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-binary-trees/">合并二叉树</a></p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br>func mergeTrees(root1 *TreeNode, root2 *TreeNode) *TreeNode &#123;<br>    if root1 == nil &#123; return root2 &#125;<br>    if root2 == nil &#123; return root1 &#125;<br>    root1.Val += root2.Val<br>    root1.Left = mergeTrees(root1.Left, root2.Left)<br>    root1.Right = mergeTrees(root1.Right, root2.Right)<br>    return root1<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#er-cha-sou-suo-shu-zhong-de-sou-suo" class="header-anchor">#</a><span id="er-cha-sou-suo-shu-zhong-de-sou-suo">二叉搜索树中的搜索</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-700-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">二叉搜索树中的搜索</a></p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br>func searchBST(root *TreeNode, val int) *TreeNode &#123;<br>    if root == nil &#123; return nil &#125;<br>    if root.Val &gt; val &#123; return searchBST(root.Left, val) &#125;<br>    if root.Val &lt; val &#123; return searchBST(root.Right, val) &#125;<br>    return root<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>迭代</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br>func searchBST(root *TreeNode, val int) *TreeNode &#123;<br>    for root != nil &#123;<br>        if root.Val &gt; val &#123; <br>            root = root.Left<br>        &#125; else if root.Val &lt; val &#123;<br>            root = root.Right<br>        &#125; else &#123;<br>            return root<br>        &#125;<br>    &#125;<br>    return nil<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#yan-zheng-er-cha-sou-suo-shu" class="header-anchor">#</a><span id="yan-zheng-er-cha-sou-suo-shu">验证二叉搜索树</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-98-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/validate-binary-search-tree/">验证二叉搜索树</a></p>
<ul>
<li>递归，注意子树区间必须，需要上下界来判断</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br><br>func isValidBST(root *TreeNode) bool &#123;<br>    return helper(root, math.MinInt64, math.MaxInt64)<br>&#125;<br><br>func helper(root *TreeNode, lower, upper int) bool &#123;<br>    if root == nil &#123;<br>        return true<br>    &#125;<br>    if root.Val &lt;= lower || root.Val &gt;= upper &#123;<br>        return false<br>    &#125;<br>    return helper(root.Left, lower, root.Val) &amp;&amp; helper(root.Right, root.Val, upper)<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>中序遍历，序列递增</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br><br>func isValidBST(root *TreeNode) bool &#123;<br>    valid, _ := traverse(root, math.MinInt64)<br>    return valid<br>&#125;<br><br>func traverse(root *TreeNode, val int) (bool, int) &#123;<br>    if root == nil &#123;<br>        return true, val<br>    &#125;<br>    var valid bool<br>    valid, val = traverse(root.Left, val)<br>    if !valid &#123;<br>        return false, val<br>    &#125;<br><br>    if root.Val &lt;= val &#123;<br>        return false, val<br>    &#125;<br>    val = root.Val<br><br>    valid, val = traverse(root.Right, val)<br>    if !valid &#123;<br>        return false, val<br>    &#125;<br>    return true, val<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#er-cha-sou-suo-shu-de-zui-xiao-jue-dui-chai" class="header-anchor">#</a><span id="er-cha-sou-suo-shu-de-zui-xiao-jue-dui-chai">二叉搜索树的最小绝对差</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-530-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/">二叉搜索树的最小绝对差</a></p>
<ul>
<li>中序遍历，Go的struct指针</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br>type Searcher struct &#123;<br>    min int<br>    last int<br>&#125;<br><br>func Abs(a int) int &#123;<br>    if a &lt; 0 &#123;<br>        return -a<br>    &#125;<br>    return a<br>&#125;<br><br>func (s *Searcher)traverse(root *TreeNode) &#123;<br>    if root == nil &#123; return &#125;<br>    s.traverse(root.Left)<br>    val := Abs(root.Val - s.last)<br>    if val &lt; s.min &#123;<br>        s.min = val<br>    &#125;<br>    s.last = root.Val<br>    s.traverse(root.Right)<br>&#125;<br><br>func getMinimumDifference(root *TreeNode) int &#123;<br>    s := Searcher&#123;math.MaxInt64, math.MaxInt64&#125;<br>    s.traverse(root)<br>    return s.min<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#er-cha-sou-suo-shu-zhong-de-zhong-shu" class="header-anchor">#</a><span id="er-cha-sou-suo-shu-zhong-de-zhong-shu">二叉搜索树中的众数</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-501-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/">二叉搜索树中的众数</a></p>
<ul>
<li>二叉搜索树中序遍历有序</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br>type Searcher struct &#123;<br>    Last int<br>    Count int<br>    MaxCount int<br>    Modes []int<br>&#125;<br><br>func (s *Searcher)traverse(root *TreeNode) &#123;<br>    if root == nil &#123; return &#125;<br>    s.traverse(root.Left)<br>    if root.Val == s.Last &#123;<br>        s.Count++<br>    &#125; else &#123;<br>        s.Last = root.Val<br>        s.Count = 1<br>    &#125;<br>    if s.Count &gt; s.MaxCount &#123;<br>        s.Modes = nil<br>        s.Modes = append(s.Modes, root.Val)<br>        s.MaxCount = s.Count<br>    &#125; else if s.Count == s.MaxCount &#123;<br>        s.Modes = append(s.Modes, root.Val)<br>    &#125;<br>    s.traverse(root.Right)<br>&#125;<br><br>func findMode(root *TreeNode) []int &#123;<br>    s := Searcher&#123;<br>        Last: 0,<br>        Count: 0,<br>        MaxCount: 0,<br>    &#125;<br>    s.traverse(root)<br>    return s.Modes<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#er-cha-shu-de-zui-jin-gong-gong-zu-xian" class="header-anchor">#</a><span id="er-cha-shu-de-zui-jin-gong-gong-zu-xian">二叉树的最近公共祖先</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-236-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">二叉树的最近公共祖先</a></p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br> func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode &#123;<br>     if root == nil &#123; return nil &#125;<br>     if root.Val == p.Val || root.Val == q.Val &#123;<br>         return root<br>     &#125;<br>     left := lowestCommonAncestor(root.Left, p, q)<br>     right := lowestCommonAncestor(root.Right, p, q)<br>     if left != nil &amp;&amp; right != nil &#123; return root &#125;<br>     if left != nil &amp;&amp; right == nil &#123; return left &#125;<br>     if left == nil &amp;&amp; right != nil &#123; return right &#125;<br>     return nil<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian" class="header-anchor">#</a><span id="er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian">二叉搜索树的最近公共祖先</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-235-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">二叉搜索树的最近公共祖先</a></p>
<ul>
<li>二叉搜索树有序，前序遍历，第一个落在[p, q]或[q, p]区间的就是公共祖先</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val   int<br> *     Left  *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br><br>func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode &#123;<br>  if root.Val &gt; p.Val &amp;&amp; root.Val &gt; q.Val &#123;<br>        return lowestCommonAncestor(root.Left, p, q)<br>    &#125;<br>    if root.Val &lt; p.Val &amp;&amp; root.Val &lt; q.Val &#123;<br>        return lowestCommonAncestor(root.Right, p, q)<br>    &#125;<br>    return root<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>迭代</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val   int<br> *     Left  *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br><br>func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode &#123;<br>    for &#123;<br>        if root.Val &gt; p.Val &amp;&amp; root.Val &gt; q.Val &#123;<br>            root = root.Left<br>        &#125; else if root.Val &lt; p.Val &amp;&amp; root.Val &lt; q.Val &#123;<br>            root = root.Right<br>        &#125; else &#123;<br>            return root<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#er-cha-sou-suo-shu-zhong-de-cha-ru-cao-zuo" class="header-anchor">#</a><span id="er-cha-sou-suo-shu-zhong-de-cha-ru-cao-zuo">二叉搜索树中的插入操作</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-701-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/">二叉搜索树中的插入操作</a></p>
<ul>
<li>利用二叉搜索树的性质插入</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br>func insertIntoBST(root *TreeNode, val int) *TreeNode &#123;<br>    if root == nil &#123;<br>        return &amp;TreeNode&#123;Val: val&#125;<br>    &#125;<br>    if val &lt; root.Val &#123;<br>        root.Left = insertIntoBST(root.Left, val)<br>    &#125;<br>    if val &gt; root.Val &#123;<br>        root.Right = insertIntoBST(root.Right, val)<br>    &#125;<br>    return root<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#shan-chu-er-cha-sou-suo-shu-zhong-de-jie-dian" class="header-anchor">#</a><span id="shan-chu-er-cha-sou-suo-shu-zhong-de-jie-dian">删除二叉搜索树中的节点</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-450-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">删除二叉搜索树中的节点</a></p>
<ul>
<li>删除节点时分五种情况：
<ol>
<li>找不到</li>
<li>左右都为空，直接删除</li>
<li>左空右不空，等于右</li>
<li>右空左不空，等于左</li>
<li>左右都不空，有两种方案</li>
</ol>
<ul>
<li>用右子树中最小的节点替换，退化为2，因为右子树中最小节点也一定比左子树中的任意节点都大，这个节点是右子树的最左叶子节点。可以统一2/3/5。</li>
<li>把左子树挂在右子树的最左叶子节点，退化为3</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br>func deleteNode(root *TreeNode, key int) *TreeNode &#123;<br>    if root == nil &#123; return root &#125;<br>    if root.Val == key &#123;<br>        if root.Right == nil &#123;<br>            return root.Left<br>        &#125;<br>        cur := root.Right<br>        for cur.Left != nil &#123;<br>            cur = cur.Left<br>        &#125;<br>        root.Val, cur.Val = cur.Val, root.Val<br>    &#125;<br>    root.Left = deleteNode(root.Left, key)<br>    root.Right = deleteNode(root.Right, key)<br>    return root<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#xiu-jian-er-cha-sou-suo-shu" class="header-anchor">#</a><span id="xiu-jian-er-cha-sou-suo-shu">修剪二叉搜索树</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-669-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/">修剪二叉搜索树</a></p>
<ul>
<li>前序遍历，如果节点值小于下界，左子树一定都小于下界，右子树不一定，可以先把右子树替换当前节点，递归判断。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br>func trimBST(root *TreeNode, low int, high int) *TreeNode &#123;<br>    if root == nil &#123; return root &#125;<br>    if root.Val &lt; low &#123;<br>        return trimBST(root.Right, low, high)<br>    &#125;<br>    if root.Val &gt; high &#123;<br>        return trimBST(root.Left, low, high)<br>    &#125;<br>    root.Left = trimBST(root.Left, low, high)<br>    root.Right = trimBST(root.Right, low, high)<br>    return root<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#jiang-you-xu-shu-zu-zhuan-huan-wei-er-cha-sou-suo-shu" class="header-anchor">#</a><span id="jiang-you-xu-shu-zu-zhuan-huan-wei-er-cha-sou-suo-shu">将有序数组转换为二叉搜索树</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-108-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">将有序数组转换为二叉搜索树</a></p>
<ul>
<li>利用二叉搜索树有序特性，二分数组</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br>func sortedArrayToBST(nums []int) *TreeNode &#123;<br>    if len(nums) == 0 &#123; return nil &#125;<br>    mid := len(nums) / 2<br>    root := &amp;TreeNode&#123;Val: nums[mid]&#125;<br>    root.Left = sortedArrayToBST(nums[:mid])<br>    root.Right = sortedArrayToBST(nums[mid+1:])<br>    return root<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#ba-er-cha-sou-suo-shu-zhuan-huan-wei-lei-jia-shu" class="header-anchor">#</a><span id="ba-er-cha-sou-suo-shu-zhuan-huan-wei-lei-jia-shu">把二叉搜索树转换为累加树</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-538-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">把二叉搜索树转换为累加树</a></p>
<ul>
<li>反中序遍历累加即可</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * type TreeNode struct &#123;<br> *     Val int<br> *     Left *TreeNode<br> *     Right *TreeNode<br> * &#125;<br> */<br>func traverse(root *TreeNode, val int) int &#123;<br>    if root == nil &#123; return val &#125;<br>    val = traverse(root.Right, val)<br>    root.Val += val<br>    val = root.Val<br>    val = traverse(root.Left, val)<br>    return val<br>&#125;<br><br>func convertBST(root *TreeNode) *TreeNode &#123;<br>    traverse(root, 0)<br>    return root<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
</p></div><div class="share"><span>Share</span>&nbsp;<span class="soc"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></span><span class="soc"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></span><span class="soc"><a target="_blank" rel="noopener" href="http://twitter.com/home?status=https://blog.kleon.space/cs/algo/tree/%20KLEON%20算法基础 - 树" class="fa fa-twitter"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/cs/algo/array/" title="算法基础 - 数组"><i class="fa fa-angle-double-left"></i>&nbsp;Previous post: 算法基础 - 数组</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/cs/algo/sort/" title="算法基础 - 排序">Next post: 算法基础 - 排序&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2022&nbsp;<a target="_blank" href="https://blog.kleon.space" rel="noopener noreferrer">Kleon</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>