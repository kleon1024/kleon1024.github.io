<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>算法基础 - 树 · KLEON</title><meta name="description" content="树是常用的数据结构，应用较多的有二叉搜索树，二叉平衡搜索树(AVL树)，红黑树，多路平衡搜索树(B-树，B+树，B*树)等。

基础
树可由链式结构或数组实现，遍历方式为前、中、后、层序遍历。
type TreeNode type TreeNode struct &amp;#123;
  Val   int"><meta name="og:description" content="树是常用的数据结构，应用较多的有二叉搜索树，二叉平衡搜索树(AVL树)，红黑树，多路平衡搜索树(B-树，B+树，B*树)等。

基础
树可由链式结构或数组实现，遍历方式为前、中、后、层序遍历。
type TreeNode type TreeNode struct &amp;#123;
  Val   int"><meta name="twitter:site" content="KLEON"><meta name="twitter:title" content="算法基础 - 树"><meta name="twitter:card" content="summary"><meta name="keywords" content=""><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 6.1.0"><link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div id="stage" class="container"><div class="row"><div id="side-bar" class="col-sm-3 col-xs-12 side-container invisible"><div class="vertical-text site-title"><h3 tabindex="-1" class="site-title-small"><a href="/" class="a-title">keep moving</a></h3><h1 tabindex="-1" class="site-title-large"><a href="/" class="a-title">自说自话</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div id="site-nav" class="site-title-links"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li><li><a href="/categories">Categories</a></li><li><a href="/tags">Tags</a></li><li><a href="/googlebe23cb0bc55fc412.html"></a></li><li><a href="/about/index.html"></a></li><li class="soc"><a href="https://github.com/kleon1024" target="_blank" rel="noopener noreferrer" aria-label="Github"><i class="fa fa-github">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2022&nbsp;<a target="_blank" href="https://kleon1024.github.io" rel="noopener noreferrer">Kleon</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div id="main-container" class="col-sm-9 col-xs-12 main-container invisible"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>算法基础 - 树</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2021-03-14</span><span class="meta-item"><i class="fa fa-folder"></i><span>&nbsp;</span><a href="/categories/算法/" title="算法" class="a-tag">算法</a><span>&nbsp;</span></span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a href="/tags/算法/" title="算法" class="a-tag">算法</a><span>&nbsp;</span><a href="/tags/数据结构/" title="数据结构" class="a-tag">数据结构</a><span>&nbsp;</span></span></p><p class="post-abstract"><p>树是常用的数据结构，应用较多的有二叉搜索树，二叉平衡搜索树(AVL树)，红黑树，多路平衡搜索树(B-树，B+树，B*树)等。</p>
<span id="more"></span>
<h1>基础</h1>
<p>树可由链式结构或数组实现，遍历方式为前、中、后、层序遍历。</p>
<pre class="line-numbers language-highlight go"><span class="keyword">type</span> TreeNode <span class="keyword"><code class="language-highlight go"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;
  Val   <span class="type">int</span>
  Left  *TreeNode
  Right *TreeNode
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="树"><a class="header-anchor" href="#树">¶</a>树</h2>
<p>有向无环非线性数据结构，每个节点可以指向多个节点，但至多有一个节点指向自身。</p>
<h2 id="二叉树"><a class="header-anchor" href="#二叉树">¶</a>二叉树</h2>
<p>每个节点至多只能指向两个节点。</p>
<h2 id="满二叉树"><a class="header-anchor" href="#满二叉树">¶</a>满二叉树</h2>
<p>只有度为0和2的节点，并且度为0的节点在同一层上。</p>
<h2 id="完全二叉树"><a class="header-anchor" href="#完全二叉树">¶</a>完全二叉树</h2>
<p>除了最底层节点可能没填满外，其余层节点数均达到最大值，并且最下面一层的节点应集中在最左侧。</p>
<h2 id="二叉搜索树"><a class="header-anchor" href="#二叉搜索树">¶</a>二叉搜索树</h2>
<p>一种朴素的有序树结构，左子节点均小于父节点，右子节点均大于父节点。当插入新值时由根节点开始按以上规则逐层比较，直到找到合适的叶节点位置。</p>
<ul>
<li>优点：不需要在插入数据时调整结构</li>
<li>缺点：性能易受数据插入顺序影响，最差情况为顺序插入，退化为链表。</li>
</ul>
<h2 id="平衡二叉搜索树-AVL树"><a class="header-anchor" href="#平衡二叉搜索树-AVL树">¶</a>平衡二叉搜索树(AVL树)</h2>
<p>二叉搜索树的改进，又称AVL(Adelson-Velsky and Landis)树，引入平衡因子，通过旋转操作保证所有子树高度差不超过1。</p>
<ul>
<li>优点：相比二叉树更平衡，极端情况下表现依然足够好。</li>
<li>缺点：在读写比例差不多的情况下，旋转操作过多。</li>
</ul>
<h2 id="红黑树-RB树"><a class="header-anchor" href="#红黑树-RB树">¶</a>红黑树(RB树)</h2>
<p>AVL树的改进，引入着色规则，通过旋转和着色操作保证所有子树高度差不超过2。Map可以通过红黑树实现。</p>
<ul>
<li>优点：写性能更高。</li>
<li>缺点：查询性能弱于AVL树，因为子树高度差比AVL多一层，最差情况会多一次比较。</li>
</ul>
<h2 id="B-树-B-Tree-B树"><a class="header-anchor" href="#B-树-B-Tree-B树">¶</a>B-树(B-Tree, B树)</h2>
<p>多路搜索树，又称B树，用于数据索引，子节点内放指针和数据块。通过分裂操作维持树结构。</p>
<h2 id="B-树"><a class="header-anchor" href="#B-树">¶</a>B+树</h2>
<p>B-树改进型，子节点内不放数据块，统一放在叶节点内。查询性能稳定，IO数据利用率高。</p>
<h2 id="B-树-v2"><a class="header-anchor" href="#B-树-v2">¶</a>B*树</h2>
<p>B+树改进型，增加子节点间指针，如果兄弟节点数据未满，则将一部分指针移到兄弟节点，并修改父节点关键字，将结点的最低利用率从1/2提高到2/3。</p>
<h1>实践</h1>
<h2 id="二叉树的前序遍历"><a class="header-anchor" href="#二叉树的前序遍历">¶</a>二叉树的前序遍历</h2>
<p><img src="https://img.shields.io/badge/leetcode-144-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">二叉树的前序遍历</a></p>
<ul>
<li>递归</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">func</span> <span class="title">traverse</span><span class="params">(n *TreeNode, result *[]<span class="type">int</span>)</span></span> &#123;
    <span class="keyword">if</span> n == <span class="literal">nil</span> &#123; <span class="keyword">return</span> &#125;
    *result = <span class="built_in">append</span>(*result, n.Val)
    traverse(n.Left, result)
    traverse(n.Right, result)
&#125;

<span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span></span> []<span class="type">int</span> &#123;
    result := []<span class="type">int</span>&#123;&#125;
    traverse(root, &result)
    <span class="keyword">return</span> result
&#125;

<span class="comment">//</span>

<span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span></span> []<span class="type">int</span> &#123;
    result := []<span class="type">int</span>&#123;&#125;
    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="keyword">return</span> result &#125;
    result = <span class="built_in">append</span>(result, root.Val)
    result = <span class="built_in">append</span>(result, preorderTraversal(root.Left)...)
    result = <span class="built_in">append</span>(result, preorderTraversal(root.Right)...)
    <span class="keyword">return</span> result
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>迭代</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span></span> []<span class="type">int</span> &#123;
    stack := []*TreeNode&#123;&#125;
    result := []<span class="type">int</span>&#123;&#125;
    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;
        stack = <span class="built_in">append</span>(stack, root)
    &#125;
    <span class="keyword">for</span> <span class="built_in">len</span>(stack) > <span class="number">0</span> &#123;
        node := stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>]
        stack = stack[:<span class="built_in">len</span>(stack) - <span class="number">1</span>]
        <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;
            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;
                stack = <span class="built_in">append</span>(stack, node.Right)
            &#125;
            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;
                stack = <span class="built_in">append</span>(stack, node.Left)
            &#125;
            stack = <span class="built_in">append</span>(stack, node)
            stack = <span class="built_in">append</span>(stack, <span class="literal">nil</span>)
        &#125; <span class="keyword">else</span> &#123;
            node = stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>]
            stack = stack[:<span class="built_in">len</span>(stack) - <span class="number">1</span>]
            result = <span class="built_in">append</span>(result, node.Val)
        &#125;
    &#125;
    <span class="keyword">return</span> result
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二叉树的后序遍历"><a class="header-anchor" href="#二叉树的后序遍历">¶</a>二叉树的后序遍历</h2>
<p><img src="https://img.shields.io/badge/leetcode-145-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">二叉树的后序遍历</a></p>
<ul>
<li>递归</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">func</span> <span class="title">postorderTraversal</span><span class="params">(root *TreeNode)</span></span> []<span class="type">int</span> &#123;
    result := []<span class="type">int</span>&#123;&#125;
    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="keyword">return</span> result &#125;
    result = <span class="built_in">append</span>(result, postorderTraversal(root.Left)...)
    result = <span class="built_in">append</span>(result, postorderTraversal(root.Right)...)
    result = <span class="built_in">append</span>(result, root.Val)
    <span class="keyword">return</span> result
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>迭代</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">func</span> <span class="title">postorderTraversal</span><span class="params">(root *TreeNode)</span></span> []<span class="type">int</span> &#123;
    stack := []*TreeNode&#123;&#125;
    result := []<span class="type">int</span>&#123;&#125;
    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;
        stack = <span class="built_in">append</span>(stack, root)
    &#125;
    <span class="keyword">for</span> <span class="built_in">len</span>(stack) > <span class="number">0</span> &#123;
        node := stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>]
        stack = stack[:<span class="built_in">len</span>(stack) - <span class="number">1</span>]
        <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;
            stack = <span class="built_in">append</span>(stack, node)
            stack = <span class="built_in">append</span>(stack, <span class="literal">nil</span>)
            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;
                stack = <span class="built_in">append</span>(stack, node.Right)
            &#125;
            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;
                stack = <span class="built_in">append</span>(stack, node.Left)
            &#125;
        &#125; <span class="keyword">else</span> &#123;
            node = stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>]
            stack = stack[:<span class="built_in">len</span>(stack) - <span class="number">1</span>]
            result = <span class="built_in">append</span>(result, node.Val)
        &#125;
    &#125;
    <span class="keyword">return</span> result
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二叉树的中序遍历"><a class="header-anchor" href="#二叉树的中序遍历">¶</a>二叉树的中序遍历</h2>
<p><img src="https://img.shields.io/badge/leetcode-94-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">二叉树的中序遍历</a></p>
<ul>
<li>递归</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span></span> []<span class="type">int</span> &#123;
    result := []<span class="type">int</span>&#123;&#125;
    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="keyword">return</span> result &#125;
    result = <span class="built_in">append</span>(result, inorderTraversal(root.Left)...)
    result = <span class="built_in">append</span>(result, root.Val)
    result = <span class="built_in">append</span>(result, inorderTraversal(root.Right)...)
    <span class="keyword">return</span> result
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>迭代</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span></span> []<span class="type">int</span> &#123;
    stack := []*TreeNode&#123;&#125;
    result := []<span class="type">int</span>&#123;&#125;
    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;
        stack = <span class="built_in">append</span>(stack, root)
    &#125;
    <span class="keyword">for</span> <span class="built_in">len</span>(stack) > <span class="number">0</span> &#123;
        node := stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>]
        stack = stack[:<span class="built_in">len</span>(stack) - <span class="number">1</span>]
        <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;
            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;
                stack = <span class="built_in">append</span>(stack, node.Right)
            &#125;
            stack = <span class="built_in">append</span>(stack, node)
            stack = <span class="built_in">append</span>(stack, <span class="literal">nil</span>)
            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;
                stack = <span class="built_in">append</span>(stack, node.Left)
            &#125;
        &#125; <span class="keyword">else</span> &#123;
            node = stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>]
            stack = stack[:<span class="built_in">len</span>(stack) - <span class="number">1</span>]
            result = <span class="built_in">append</span>(result, node.Val)
        &#125;
    &#125;
    <span class="keyword">return</span> result
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>C++ 版本</p>
<pre class="line-numbers language-highlight c++"><span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root, vector&lt;<span class="type"><code class="language-highlight c++"><span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>>& v)</span> </span>&#123;
    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;
    
    v.<span class="built_in">push_back</span>(root->val);
    <span class="built_in">preorder</span>(root->left, v);
    <span class="built_in">preorder</span>(root->right, v);
&#125;

<span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(TreeNode* root, vector<<span class="type">int</span>>& v)</span> </span>&#123;
    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;

    <span class="built_in">postorder</span>(root->left, v);
    <span class="built_in">postorder</span>(root->right, v);
    v.<span class="built_in">push_back</span>(root->val);
&#125;

<span class="function"><span class="type">void</span> <span class="title">midorder</span><span class="params">(TreeNode* root, vector<<span class="type">int</span>>& v)</span> </span>&#123;
    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;

    <span class="built_in">midorder</span>(root->left, v);
    v.<span class="built_in">push_back</span>(root->val);
    <span class="built_in">midorder</span>(root->right, v);
&#125;

<span class="function"><span class="type">void</span> <span class="title">preorderIter</span><span class="params">(TreeNode* root, vector<<span class="type">int</span>>& v)</span> </span>&#123;
    std::stack<TreeNode*> s;
    
    <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;
        s.<span class="built_in">push</span>(root);
    &#125;
    
    TreeNode* node = <span class="literal">nullptr</span>;
    <span class="keyword">while</span>(s.<span class="built_in">size</span>() > <span class="number">0</span>) &#123;
        node = s.<span class="built_in">top</span>();
        s.<span class="built_in">pop</span>();
        <span class="keyword">if</span> (node) &#123;
            <span class="keyword">if</span> (node->right) &#123;
                s.<span class="built_in">push</span>(node->right);
            &#125;
            <span class="keyword">if</span> (node->left) &#123;
                s.<span class="built_in">push</span>(node->left);
            &#125;
            s.<span class="built_in">push</span>(node);
            s.<span class="built_in">push</span>(<span class="literal">nullptr</span>);
        &#125; <span class="keyword">else</span> &#123;
            node = s.<span class="built_in">top</span>();
            s.<span class="built_in">pop</span>();
            v.<span class="built_in">push_back</span>(node->val);
        &#125;
    &#125;
&#125;

<span class="function"><span class="type">void</span> <span class="title">postorderIter</span><span class="params">(TreeNode* root, vector<<span class="type">int</span>>& v)</span> </span>&#123;
    std::stack<TreeNode*> s;
    
    <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;
        s.<span class="built_in">push</span>(root);
    &#125;
    
    TreeNode* node = <span class="literal">nullptr</span>;
    <span class="keyword">while</span>(s.<span class="built_in">size</span>() > <span class="number">0</span>) &#123;
        node = s.<span class="built_in">top</span>();
        s.<span class="built_in">pop</span>();
        <span class="keyword">if</span> (node) &#123;
            s.<span class="built_in">push</span>(node);
            s.<span class="built_in">push</span>(<span class="literal">nullptr</span>);
            <span class="keyword">if</span> (node->right) &#123;
                s.<span class="built_in">push</span>(node->right);
            &#125;
            <span class="keyword">if</span> (node->left) &#123;
                s.<span class="built_in">push</span>(node->left);
            &#125;
        &#125; <span class="keyword">else</span> &#123;
            node = s.<span class="built_in">top</span>();
            s.<span class="built_in">pop</span>();
            v.<span class="built_in">push_back</span>(node->val);
        &#125;
    &#125;
&#125;

<span class="function"><span class="type">void</span> <span class="title">midorderIter</span><span class="params">(TreeNode* root, vector<<span class="type">int</span>>& v)</span> </span>&#123;
    std::stack<TreeNode*> s;
    
    <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;
        s.<span class="built_in">push</span>(root);
    &#125;
    
    TreeNode* node = <span class="literal">nullptr</span>;
    <span class="keyword">while</span>(s.<span class="built_in">size</span>() > <span class="number">0</span>) &#123;
        node = s.<span class="built_in">top</span>();
        s.<span class="built_in">pop</span>();
        <span class="keyword">if</span> (node) &#123;
            <span class="keyword">if</span> (node->right) &#123;
                s.<span class="built_in">push</span>(node->right);
            &#125;
            s.<span class="built_in">push</span>(node);
            s.<span class="built_in">push</span>(<span class="literal">nullptr</span>);
            <span class="keyword">if</span> (node->left) &#123;
                s.<span class="built_in">push</span>(node->left);
            &#125;
        &#125; <span class="keyword">else</span> &#123;
            node = s.<span class="built_in">top</span>();
            s.<span class="built_in">pop</span>();
            v.<span class="built_in">push_back</span>(node->val);
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二叉树的层序遍历"><a class="header-anchor" href="#二叉树的层序遍历">¶</a>二叉树的层序遍历</h2>
<p><img src="https://img.shields.io/badge/leetcode-102-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">二叉树的层序遍历</a></p>
<ul>
<li>队列先进先出</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span></span> [][]<span class="type">int</span> &#123;
    queue := []*TreeNode&#123;&#125;
    result := [][]<span class="type">int</span>&#123;&#125;
    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;
        queue = <span class="built_in">append</span>(queue, root)
    &#125;
    <span class="keyword">for</span> <span class="built_in">len</span>(queue) > <span class="number">0</span> &#123;
        size := <span class="built_in">len</span>(queue)
        vec := []<span class="type">int</span>&#123;&#125;
        <span class="keyword">for</span> i := <span class="number">0</span>; i < size; i++ &#123;
            node := queue[<span class="number">0</span>]
            queue = queue[<span class="number">1</span>:]
            vec = <span class="built_in">append</span>(vec, node.Val)
            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;
                queue = <span class="built_in">append</span>(queue, node.Left)
            &#125;
            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;
                queue = <span class="built_in">append</span>(queue, node.Right)
            &#125;
        &#125;
        result = <span class="built_in">append</span>(result, vec)
    &#125;
    <span class="keyword">return</span> result
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二叉树的层序遍历II"><a class="header-anchor" href="#二叉树的层序遍历II">¶</a>二叉树的层序遍历II</h2>
<p><img src="https://img.shields.io/badge/leetcode-107-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">二叉树的层序遍历II</a></p>
<ul>
<li>同二叉树的层序遍历</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">func</span> <span class="title">levelOrderBottom</span><span class="params">(root *TreeNode)</span></span> [][]<span class="type">int</span> &#123;
    queue := []*TreeNode&#123;&#125;
    result := [][]<span class="type">int</span>&#123;&#125;
    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;
        queue = <span class="built_in">append</span>(queue, root)
    &#125;
    <span class="keyword">for</span> <span class="built_in">len</span>(queue) > <span class="number">0</span> &#123;
        size := <span class="built_in">len</span>(queue)
        vec := []<span class="type">int</span>&#123;&#125;
        <span class="keyword">for</span> i := <span class="number">0</span>; i < size; i++ &#123;
            node := queue[<span class="number">0</span>]
            queue = queue[<span class="number">1</span>:]
            vec = <span class="built_in">append</span>(vec, node.Val)
            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;
                queue = <span class="built_in">append</span>(queue, node.Left)
            &#125;
            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;
                queue = <span class="built_in">append</span>(queue, node.Right)
            &#125;
        &#125;
        result = <span class="built_in">append</span>(result, vec)
    &#125;
    <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(result)<span class="number">-1</span>; i < j; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;
        result[i], result[j] = result[j], result[i]
    &#125;
    <span class="keyword">return</span> result
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="层序遍历获取二叉树的右视图"><a class="header-anchor" href="#层序遍历获取二叉树的右视图">¶</a>层序遍历获取二叉树的右视图</h2>
<p><img src="https://img.shields.io/badge/leetcode-199-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-right-side-view/">二叉树的右视图</a></p>
<ul>
<li>同二叉树的层序遍历</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">func</span> <span class="title">rightSideView</span><span class="params">(root *TreeNode)</span></span> []<span class="type">int</span> &#123;
    queue := []*TreeNode&#123;&#125;
    result := []<span class="type">int</span>&#123;&#125;
    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;
        queue = <span class="built_in">append</span>(queue, root)
    &#125;
    <span class="keyword">for</span> <span class="built_in">len</span>(queue) > <span class="number">0</span> &#123;
        size := <span class="built_in">len</span>(queue)
        <span class="keyword">for</span> i := <span class="number">0</span>; i < size; i++ &#123;
            node := queue[<span class="number">0</span>]
            queue = queue[<span class="number">1</span>:]
            <span class="keyword">if</span> i == size - <span class="number">1</span> &#123;
                result = <span class="built_in">append</span>(result, node.Val)
            &#125;
            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;
                queue = <span class="built_in">append</span>(queue, node.Left)
            &#125;
            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;
                queue = <span class="built_in">append</span>(queue, node.Right)
            &#125;
        &#125;
    &#125;
    <span class="keyword">return</span> result
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="层序遍历获取二叉树的层平均值"><a class="header-anchor" href="#层序遍历获取二叉树的层平均值">¶</a>层序遍历获取二叉树的层平均值</h2>
<p><img src="https://img.shields.io/badge/leetcode-637-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/">二叉树的层平均值</a></p>
<ul>
<li>同二叉树的层序遍历</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">func</span> <span class="title">averageOfLevels</span><span class="params">(root *TreeNode)</span></span> []<span class="type">float64</span> &#123;
    result := []<span class="type">float64</span>&#123;&#125;
    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;
        <span class="keyword">return</span> result
    &#125;
    queue := list.New()
    queue.PushBack(root)
    <span class="keyword">for</span> queue.Len() > <span class="number">0</span> &#123;
        size := queue.Len()
        sum := <span class="number">0</span>
        <span class="keyword">for</span> i := <span class="number">0</span>; i < size; i++ &#123;
            node := queue.Front()
            queue.Remove(node)
            t := node.Value.(*TreeNode)
            sum += t.Val
            <span class="keyword">if</span> t.Left != <span class="literal">nil</span> &#123;
                queue.PushBack(t.Left)
            &#125;
            <span class="keyword">if</span> t.Right != <span class="literal">nil</span> &#123;
                queue.PushBack(t.Right)
            &#125;
        &#125;
        result = <span class="built_in">append</span>(result, <span class="type">float64</span>(sum) / <span class="type">float64</span>(size))
    &#125;
    <span class="keyword">return</span> result
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="层序遍历获取N叉树的层序遍历"><a class="header-anchor" href="#层序遍历获取N叉树的层序遍历">¶</a>层序遍历获取N叉树的层序遍历</h2>
<p><img src="https://img.shields.io/badge/leetcode-429-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/">N叉树的层序遍历</a></p>
<ul>
<li>同二叉树的层序遍历</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a Node.</span>
<span class="comment"> * type Node struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Children []*Node</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>

<span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *Node)</span></span> [][]<span class="type">int</span> &#123;
    queue := []*Node&#123;&#125;
    result := [][]<span class="type">int</span>&#123;&#125;
    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;
        queue = <span class="built_in">append</span>(queue, root)
    &#125;
    <span class="keyword">for</span> <span class="built_in">len</span>(queue) > <span class="number">0</span> &#123;
        size := <span class="built_in">len</span>(queue)
        vec := []<span class="type">int</span>&#123;&#125;
        <span class="keyword">for</span> i := <span class="number">0</span>; i < size; i++ &#123;
            node := queue[<span class="number">0</span>]
            queue = queue[<span class="number">1</span>:]
            vec = <span class="built_in">append</span>(vec, node.Val)
            <span class="keyword">for</span> _, n := <span class="keyword">range</span> node.Children &#123;
                queue = <span class="built_in">append</span>(queue, n)
            &#125;
        &#125;
        result = <span class="built_in">append</span>(result, vec)
    &#125;
    <span class="keyword">return</span> result
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="前序遍历二叉树展开为链表"><a class="header-anchor" href="#前序遍历二叉树展开为链表">¶</a>前序遍历二叉树展开为链表</h2>
<p><img src="https://img.shields.io/badge/leetcode-114-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">二叉树展开为链表</a></p>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">func</span> <span class="title">flatten</span><span class="params">(root *TreeNode)</span></span>  &#123;
    stack := []*TreeNode&#123;&#125;
    list := []*TreeNode&#123;&#125;
    node := root
    <span class="keyword">for</span> node != <span class="literal">nil</span> || <span class="built_in">len</span>(stack) > <span class="number">0</span> &#123;
        <span class="keyword">for</span> node != <span class="literal">nil</span> &#123;
            list = <span class="built_in">append</span>(list, node)
            stack = <span class="built_in">append</span>(stack, node)
            node = node.Left
        &#125;
        node = stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>]
        node = node.Right
        stack = stack[:<span class="built_in">len</span>(stack) - <span class="number">1</span>]
    &#125;

    <span class="keyword">for</span> i := <span class="number">1</span>; i < <span class="built_in">len</span>(list); i++ &#123;
        prev, curr := list[i<span class="number">-1</span>], list[i]
        prev.Left, prev.Right = <span class="literal">nil</span>, curr
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="翻转二叉树"><a class="header-anchor" href="#翻转二叉树">¶</a>翻转二叉树</h2>
<p><img src="https://img.shields.io/badge/leetcode-226-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/invert-binary-tree/">翻转二叉树</a></p>
<ul>
<li>递归</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">func</span> <span class="title">invertTree</span><span class="params">(root *TreeNode)</span></span> *TreeNode &#123;
    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;
        <span class="keyword">return</span> root
    &#125;
    root.Left, root.Right = root.Right, root.Left
    invertTree(root.Left)
    invertTree(root.Right)
    <span class="keyword">return</span> root
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>迭代</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">func</span> <span class="title">invertTree</span><span class="params">(root *TreeNode)</span></span> *TreeNode &#123;
    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;
        <span class="keyword">return</span> root
    &#125;
    stack := []*TreeNode&#123;&#125;
    stack = <span class="built_in">append</span>(stack, root)
    <span class="keyword">for</span> <span class="built_in">len</span>(stack) > <span class="number">0</span> &#123;
        node := stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>]
        stack = stack[:<span class="built_in">len</span>(stack) - <span class="number">1</span>]
        node.Left, node.Right = node.Right, node.Left
        <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;
            stack = <span class="built_in">append</span>(stack, node.Right)
        &#125;
        <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;
            stack = <span class="built_in">append</span>(stack, node.Left)
        &#125;
    &#125;
    <span class="keyword">return</span> root
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>层序</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">func</span> <span class="title">invertTree</span><span class="params">(root *TreeNode)</span></span> *TreeNode &#123;
    queue := []*TreeNode&#123;&#125;
    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;
        <span class="keyword">return</span> root
    &#125;
    queue = <span class="built_in">append</span>(queue, root)
    <span class="keyword">for</span> <span class="built_in">len</span>(queue) > <span class="number">0</span> &#123;
        size := <span class="built_in">len</span>(queue)
        <span class="keyword">for</span> i := <span class="number">0</span>; i < size; i++ &#123;
            node := queue[<span class="number">0</span>]
            queue = queue[<span class="number">1</span>:]
            node.Left, node.Right = node.Right, node.Left
            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;
                queue = <span class="built_in">append</span>(queue, node.Left)
            &#125;
            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;
                queue = <span class="built_in">append</span>(queue, node.Right)
            &#125;
        &#125;
    &#125;
    <span class="keyword">return</span> root
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="对称二叉树"><a class="header-anchor" href="#对称二叉树">¶</a>对称二叉树</h2>
<p><img src="https://img.shields.io/badge/leetcode-101-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/symmetric-tree/">对称二叉树</a></p>
<ul>
<li>递归</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">func</span> <span class="title">compare</span><span class="params">(left *TreeNode, right *TreeNode)</span></span> <span class="type">bool</span> &#123;
    <span class="keyword">if</span> right != <span class="literal">nil</span> && left == <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;
    <span class="keyword">if</span> right == <span class="literal">nil</span> && left != <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;
    <span class="keyword">if</span> right == <span class="literal">nil</span> && left == <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;
    <span class="keyword">if</span> right.Val != left.Val &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;

    outside := compare(left.Left, right.Right)
    inside := compare(left.Right, right.Left)
    <span class="keyword">return</span> outside && inside
&#125;

<span class="function"><span class="keyword">func</span> <span class="title">isSymmetric</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;
    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;
    <span class="keyword">return</span> compare(root.Left, root.Right)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>迭代，队列和栈均可</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">func</span> <span class="title">isSymmetric</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;
    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;
    queue := []*TreeNode&#123;&#125;
    queue = <span class="built_in">append</span>(queue, root.Left)
    queue = <span class="built_in">append</span>(queue, root.Right)

    <span class="keyword">for</span> <span class="built_in">len</span>(queue) > <span class="number">0</span> &#123;
        left := queue[<span class="number">0</span>]; queue = queue[<span class="number">1</span>:]
        right := queue[<span class="number">0</span>]; queue = queue[<span class="number">1</span>:]
        <span class="keyword">if</span> left == <span class="literal">nil</span> && right == <span class="literal">nil</span> &#123;
            <span class="keyword">continue</span>
        &#125;
        <span class="keyword">if</span> left == <span class="literal">nil</span> || right == <span class="literal">nil</span> || left.Val != right.Val &#123;
            <span class="keyword">return</span> <span class="literal">false</span>
        &#125;
        queue = <span class="built_in">append</span>(queue, left.Left)
        queue = <span class="built_in">append</span>(queue, right.Right)
        queue = <span class="built_in">append</span>(queue, left.Right)
        queue = <span class="built_in">append</span>(queue, right.Left)
    &#125;
    <span class="keyword">return</span> <span class="literal">true</span>
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二叉树的最大深度"><a class="header-anchor" href="#二叉树的最大深度">¶</a>二叉树的最大深度</h2>
<p><img src="https://img.shields.io/badge/leetcode-104-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">二叉树的最大深度</a></p>
<ul>
<li>后序遍历</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">func</span> <span class="title">Max</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;
    <span class="keyword">if</span> x < y &#123; <span class="keyword">return</span> y &#125;
    <span class="keyword">return</span> x
&#125;

<span class="function"><span class="keyword">func</span> <span class="title">depth</span><span class="params">(node *TreeNode)</span></span> <span class="type">int</span> &#123;
    <span class="keyword">if</span> node == <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;
    <span class="keyword">return</span> <span class="number">1</span> + Max(depth(node.Left), depth(node.Right))
&#125;

<span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;
    <span class="keyword">return</span> depth(root)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>层序遍历</li>
</ul>
<h2 id="N叉树的最大深度"><a class="header-anchor" href="#N叉树的最大深度">¶</a>N叉树的最大深度</h2>
<p><img src="https://img.shields.io/badge/leetcode-104-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">N叉树的最大深度</a></p>
<ul>
<li>迭代，同二叉树</li>
<li>层序遍历</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a Node.</span>
<span class="comment"> * type Node struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Children []*Node</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>

<span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *Node)</span></span> <span class="type">int</span> &#123;
    queue := []*Node&#123;&#125;
    depth := <span class="number">0</span>
    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="keyword">return</span> depth &#125;
    queue = <span class="built_in">append</span>(queue, root)
    <span class="keyword">for</span> <span class="built_in">len</span>(queue) > <span class="number">0</span> &#123;
        size := <span class="built_in">len</span>(queue)
        depth++
        <span class="keyword">for</span> i := <span class="number">0</span>; i < size; i++ &#123;
            node := queue[<span class="number">0</span>]
            queue = queue[<span class="number">1</span>:]
            <span class="keyword">for</span> _, n := <span class="keyword">range</span> node.Children &#123;
                <span class="keyword">if</span> n != <span class="literal">nil</span> &#123;
                    queue = <span class="built_in">append</span>(queue, n)
                &#125;
            &#125;
        &#125;
    &#125;
    <span class="keyword">return</span> depth
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二叉树的最小深度"><a class="header-anchor" href="#二叉树的最小深度">¶</a>二叉树的最小深度</h2>
<p><img src="https://img.shields.io/badge/leetcode-111-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">二叉树的最小深度</a></p>
<ul>
<li>递归</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">func</span> <span class="title">Min</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;
    <span class="keyword">if</span> x > y &#123; <span class="keyword">return</span> y &#125;
    <span class="keyword">return</span> x
&#125;

<span class="function"><span class="keyword">func</span> <span class="title">depth</span><span class="params">(node *TreeNode)</span></span> <span class="type">int</span> &#123;
    <span class="keyword">if</span> node == <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;
    leftDepth := depth(node.Left)
    rightDepth := depth(node.Right)

    <span class="keyword">if</span> node.Left == <span class="literal">nil</span> && node.Right != <span class="literal">nil</span> &#123;
        <span class="keyword">return</span> <span class="number">1</span> + rightDepth
    &#125;

    <span class="keyword">if</span> node.Right == <span class="literal">nil</span> && node.Left != <span class="literal">nil</span> &#123;
        <span class="keyword">return</span> <span class="number">1</span> + leftDepth
    &#125;

    <span class="keyword">return</span> <span class="number">1</span> + Min(leftDepth, rightDepth)
&#125;


<span class="function"><span class="keyword">func</span> <span class="title">minDepth</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;
    <span class="keyword">return</span> depth(root)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>层序遍历</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">func</span> <span class="title">minDepth</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;
    queue := []*TreeNode&#123;&#125;
    depth := <span class="number">0</span>
    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="keyword">return</span> depth &#125;
    queue = <span class="built_in">append</span>(queue, root)
    <span class="keyword">for</span> <span class="built_in">len</span>(queue) > <span class="number">0</span> &#123;
        size := <span class="built_in">len</span>(queue)
        depth++
        <span class="keyword">for</span> i := <span class="number">0</span>; i < size; i++ &#123;
            node := queue[<span class="number">0</span>]
            queue = queue[<span class="number">1</span>:]
            <span class="keyword">if</span> node.Left == <span class="literal">nil</span> && node.Right == <span class="literal">nil</span> &#123;
                <span class="keyword">return</span> depth
            &#125;
            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;
                queue = <span class="built_in">append</span>(queue, node.Left)
            &#125;
            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;
                queue = <span class="built_in">append</span>(queue, node.Right)
            &#125;
        &#125;
    &#125;
    <span class="keyword">return</span> depth
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="完全二叉树的节点数"><a class="header-anchor" href="#完全二叉树的节点数">¶</a>完全二叉树的节点数</h2>
<p><img src="https://img.shields.io/badge/leetcode-222-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-complete-tree-nodes/">完全二叉树的节点个数</a></p>
<ul>
<li>前序遍历递归</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">func</span> <span class="title">nodeNum</span><span class="params">(node *TreeNode)</span></span> <span class="type">int</span> &#123;
    <span class="keyword">if</span> node == <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;
    <span class="keyword">return</span> <span class="number">1</span> + nodeNum(node.Left) + nodeNum(node.Right)
&#125;

<span class="function"><span class="keyword">func</span> <span class="title">countNodes</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;
    <span class="keyword">return</span> nodeNum(root)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>层序遍历迭代</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">func</span> <span class="title">countNodes</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;
    queue := []*TreeNode&#123;&#125;
    count := <span class="number">0</span>
    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="keyword">return</span> count &#125;
    queue = <span class="built_in">append</span>(queue, root)
    <span class="keyword">for</span> <span class="built_in">len</span>(queue) > <span class="number">0</span> &#123;
        size := <span class="built_in">len</span>(queue)
        <span class="keyword">for</span> i := <span class="number">0</span>; i < size; i++ &#123;
            node := queue[<span class="number">0</span>]
            queue = queue[<span class="number">1</span>:]
            count++
            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;
                queue = <span class="built_in">append</span>(queue, node.Left)
            &#125;
            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;
                queue = <span class="built_in">append</span>(queue, node.Right)
            &#125;
        &#125;
    &#125;
    <span class="keyword">return</span> count
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="平衡二叉树"><a class="header-anchor" href="#平衡二叉树">¶</a>平衡二叉树</h2>
<p><img src="https://img.shields.io/badge/leetcode-110-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/balanced-binary-tree/">平衡二叉树</a></p>
<ul>
<li>递归</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">func</span> <span class="title">Max</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;
    <span class="keyword">if</span> x > y &#123; <span class="keyword">return</span> x &#125;
    <span class="keyword">return</span> y
&#125;

<span class="function"><span class="keyword">func</span> <span class="title">depth</span><span class="params">(node *TreeNode)</span></span> <span class="type">int</span> &#123;
    <span class="keyword">if</span> node == <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;
    leftDepth := depth(node.Left)
    <span class="keyword">if</span> leftDepth < <span class="number">0</span> &#123; <span class="keyword">return</span> <span class="number">-1</span> &#125;
    rightDepth := depth(node.Right)
    <span class="keyword">if</span> rightDepth < <span class="number">0</span> &#123; <span class="keyword">return</span> <span class="number">-1</span> &#125;
    <span class="keyword">if</span> math.Abs(<span class="type">float64</span>(leftDepth) - <span class="type">float64</span>(rightDepth)) > <span class="number">1</span> &#123;
        <span class="keyword">return</span> <span class="number">-1</span>
    &#125;
    <span class="keyword">return</span> <span class="number">1</span> + Max(leftDepth, rightDepth)
&#125;

<span class="function"><span class="keyword">func</span> <span class="title">isBalanced</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;
    <span class="keyword">return</span> depth(root) >= <span class="number">0</span>
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二叉树的所有路径"><a class="header-anchor" href="#二叉树的所有路径">¶</a>二叉树的所有路径</h2>
<p><img src="https://img.shields.io/badge/leetcode-257-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-paths/">二叉树的所有路径</a></p>
<ul>
<li>谦虚遍历递归</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">func</span> <span class="title">path</span><span class="params">(node *TreeNode, pathStr <span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;
    results := []<span class="type">string</span>&#123;&#125;
    pathStr += strconv.Itoa(node.Val)
    <span class="keyword">if</span> node.Left == <span class="literal">nil</span> && node.Right == <span class="literal">nil</span> &#123;
        results = <span class="built_in">append</span>(results, pathStr)
    &#125;
    pathStr += <span class="string">"->"</span>
    <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;
        results = <span class="built_in">append</span>(results, path(node.Left, pathStr)...)
    &#125;
    <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;
        results = <span class="built_in">append</span>(results, path(node.Right, pathStr)...)
    &#125;
    <span class="keyword">return</span> results
&#125;

<span class="function"><span class="keyword">func</span> <span class="title">binaryTreePaths</span><span class="params">(root *TreeNode)</span></span> []<span class="type">string</span> &#123;
    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="keyword">return</span> []<span class="type">string</span>&#123;&#125; &#125;
    <span class="keyword">return</span> path(root, <span class="string">""</span>)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="相同的树"><a class="header-anchor" href="#相同的树">¶</a>相同的树</h2>
<p><img src="https://img.shields.io/badge/leetcode-100-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/same-tree/">相同的树</a></p>
<ul>
<li>递归，同对称树</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">func</span> <span class="title">isSameTree</span><span class="params">(p *TreeNode, q *TreeNode)</span></span> <span class="type">bool</span> &#123;
    <span class="keyword">if</span> p != <span class="literal">nil</span> && q == <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;
    <span class="keyword">if</span> p == <span class="literal">nil</span> && q != <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;
    <span class="keyword">if</span> p == <span class="literal">nil</span> && q == <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;
    <span class="keyword">if</span> p.Val != q.Val &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;

    left := isSameTree(p.Left, q.Left)
    right := isSameTree(p.Right, q.Right)
    <span class="keyword">return</span> left && right
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>迭代，队列和栈均可，同对称树</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">func</span> <span class="title">isSameTree</span><span class="params">(p *TreeNode, q *TreeNode)</span></span> <span class="type">bool</span> &#123;
    queue := []*TreeNode&#123;&#125;
    queue = <span class="built_in">append</span>(queue, p)
    queue = <span class="built_in">append</span>(queue, q)
    <span class="keyword">for</span> <span class="built_in">len</span>(queue) > <span class="number">0</span> &#123;
        left := queue[<span class="number">0</span>]; queue = queue[<span class="number">1</span>:]
        right := queue[<span class="number">0</span>]; queue = queue[<span class="number">1</span>:]
        <span class="keyword">if</span> left == <span class="literal">nil</span> && right == <span class="literal">nil</span> &#123;
            <span class="keyword">continue</span>
        &#125;
        <span class="keyword">if</span> left == <span class="literal">nil</span> || right == <span class="literal">nil</span> || left.Val != right.Val &#123;
            <span class="keyword">return</span> <span class="literal">false</span>
        &#125;
        queue = <span class="built_in">append</span>(queue, left.Left)
        queue = <span class="built_in">append</span>(queue, right.Left)
        queue = <span class="built_in">append</span>(queue, left.Right)
        queue = <span class="built_in">append</span>(queue, right.Right)
    &#125;
    <span class="keyword">return</span> <span class="literal">true</span>
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="左叶子之和"><a class="header-anchor" href="#左叶子之和">¶</a>左叶子之和</h2>
<p><img src="https://img.shields.io/badge/leetcode-404-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-of-left-leaves/">左叶子之和</a></p>
<ul>
<li>递归</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">func</span> <span class="title">sumOfLeftLeaves</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;
    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;
    sum := <span class="number">0</span>
    <span class="keyword">if</span> root.Left != <span class="literal">nil</span> && root.Left.Left == <span class="literal">nil</span> && root.Left.Right == <span class="literal">nil</span> &#123;
        sum = root.Left.Val
    &#125;
    <span class="keyword">return</span> sum + sumOfLeftLeaves(root.Left) + sumOfLeftLeaves(root.Right)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="找树左下角的值"><a class="header-anchor" href="#找树左下角的值">¶</a>找树左下角的值</h2>
<p><img src="https://img.shields.io/badge/leetcode-513-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/">找树左下角的值</a></p>
<ul>
<li>层序遍历</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">func</span> <span class="title">findBottomLeftValue</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;
    queue := []*TreeNode&#123;root&#125;
    result := <span class="number">0</span>
    <span class="keyword">for</span> <span class="built_in">len</span>(queue) > <span class="number">0</span> &#123;
        size := <span class="built_in">len</span>(queue)
        <span class="keyword">for</span> i := <span class="number">0</span>; i < size; i++ &#123;
            node := queue[<span class="number">0</span>]
            queue = queue[<span class="number">1</span>:]
            <span class="keyword">if</span> i == <span class="number">0</span> &#123; result = node.Val &#125;
            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;
                queue = <span class="built_in">append</span>(queue, node.Left)
            &#125;
            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;
                queue = <span class="built_in">append</span>(queue, node.Right)
            &#125;
        &#125;
    &#125;
    <span class="keyword">return</span> result
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="路径总和"><a class="header-anchor" href="#路径总和">¶</a>路径总和</h2>
<p><img src="https://img.shields.io/badge/leetcode-112-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum/">路径总和</a></p>
<ul>
<li>递归</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">func</span> <span class="title">hasPathSum</span><span class="params">(root *TreeNode, targetSum <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;
    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;
    <span class="keyword">if</span> root.Left == <span class="literal">nil</span> && root.Right == <span class="literal">nil</span> && root.Val == targetSum &#123;
        <span class="keyword">return</span> <span class="literal">true</span>
    &#125;
    nextSum := targetSum - root.Val
    <span class="keyword">return</span> hasPathSum(root.Left, nextSum) || hasPathSum(root.Right, nextSum)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="路径总和II"><a class="header-anchor" href="#路径总和II">¶</a>路径总和II</h2>
<p><img src="https://img.shields.io/badge/leetcode-113-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-ii/">路径总和II</a></p>
<ul>
<li>递归，注意Go的引用</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">func</span> <span class="title">traverse</span><span class="params">(root *TreeNode, targetSum <span class="type">int</span>, res *[][]<span class="type">int</span>, path[]<span class="type">int</span>)</span></span> &#123;
    path = <span class="built_in">append</span>(path, root.Val)
    nextSum := targetSum - root.Val
    <span class="keyword">if</span> root.Left == <span class="literal">nil</span> && root.Right == <span class="literal">nil</span> &#123;
        <span class="keyword">if</span> nextSum == <span class="number">0</span> &#123;
            tmp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(path))
            <span class="built_in">copy</span>(tmp, path)
            *res = <span class="built_in">append</span>(*res, tmp)
        &#125;
        <span class="keyword">return</span>
    &#125;

    <span class="keyword">if</span> root.Left != <span class="literal">nil</span> &#123;
        traverse(root.Left, nextSum, res, path)
    &#125;
    <span class="keyword">if</span> root.Right != <span class="literal">nil</span> &#123;
        traverse(root.Right, nextSum, res, path)
    &#125;
&#125;

<span class="function"><span class="keyword">func</span> <span class="title">pathSum</span><span class="params">(root *TreeNode, targetSum <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;
    result := [][]<span class="type">int</span>&#123;&#125;
    path := []<span class="type">int</span>&#123;&#125;
    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="keyword">return</span> result &#125;
    traverse(root, targetSum, &result, path)
    <span class="keyword">return</span> result
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="从中序与后序遍历序列构造二叉树"><a class="header-anchor" href="#从中序与后序遍历序列构造二叉树">¶</a>从中序与后序遍历序列构造二叉树</h2>
<p><img src="https://img.shields.io/badge/leetcode-106-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">从中序与后序遍历序列构造二叉树</a></p>
<ul>
<li>先取后序遍历最后一个值作为当前根节点，从中序遍历比对确定左右子树切割位置，后序遍历子树大小应和中序遍历数组子序列一致，将切分出的左右子序列递归。</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>
<span class="keyword">type</span> TreeBuilder <span class="keyword">struct</span> &#123;
    inorder []<span class="type">int</span>
    postorder []<span class="type">int</span>
&#125;

<span class="function"><span class="keyword">func</span> <span class="params">(t TreeBuilder)</span></span>traverse(inStart, inEnd, poStart, poEnd <span class="type">int</span>) *TreeNode &#123;
    <span class="keyword">if</span> poStart == poEnd &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;
    rootVal := t.postorder[poEnd - <span class="number">1</span>]
    root := &TreeNode&#123;Val: rootVal&#125;
    <span class="keyword">if</span> poEnd - poStart == <span class="number">1</span> &#123; <span class="keyword">return</span> root &#125;

    <span class="keyword">var</span> inMid <span class="type">int</span>
    <span class="keyword">for</span> inMid = inStart; inMid < inEnd; inMid++ &#123;
        <span class="keyword">if</span> t.inorder[inMid] == rootVal &#123; <span class="keyword">break</span> &#125;
    &#125;

    poMid := poStart + inMid - inStart
    root.Left = t.traverse(inStart, inMid, poStart, poMid)
    root.Right = t.traverse(inMid + <span class="number">1</span>, inEnd, poMid, poEnd - <span class="number">1</span>)
    <span class="keyword">return</span> root
&#125;

<span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(inorder []<span class="type">int</span>, postorder []<span class="type">int</span>)</span></span> *TreeNode &#123;
    <span class="keyword">return</span> TreeBuilder&#123;inorder, postorder&#125;.traverse(<span class="number">0</span>, <span class="built_in">len</span>(inorder), <span class="number">0</span>, <span class="built_in">len</span>(postorder))
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="从中序与前序遍历序列构造二叉树"><a class="header-anchor" href="#从中序与前序遍历序列构造二叉树">¶</a>从中序与前序遍历序列构造二叉树</h2>
<p><img src="https://img.shields.io/badge/leetcode-105-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">从中序与前序遍历序列构造二叉树</a></p>
<ul>
<li>类似后序+中序</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>
<span class="keyword">type</span> TreeBuilder <span class="keyword">struct</span> &#123;
    inorder []<span class="type">int</span>
    preorder []<span class="type">int</span>
&#125;

<span class="function"><span class="keyword">func</span> <span class="params">(t TreeBuilder)</span></span>traverse(inStart, inEnd, prStart, prEnd <span class="type">int</span>) *TreeNode &#123;
    <span class="comment">// fmt.Printf("%v %v | %v %v \n", inStart, inEnd, prStart, prEnd)</span>

    <span class="keyword">if</span> prStart == prEnd &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;
    rootVal := t.preorder[prStart]
    root := &TreeNode&#123;Val: rootVal&#125;
    <span class="keyword">if</span> prEnd - prStart == <span class="number">1</span> &#123; <span class="keyword">return</span> root &#125;

    <span class="keyword">var</span> inMid <span class="type">int</span>
    <span class="keyword">for</span> inMid = inStart; inMid < inEnd; inMid++ &#123;
        <span class="keyword">if</span> t.inorder[inMid] == rootVal &#123; <span class="keyword">break</span> &#125;
    &#125;

    prMid := prStart + <span class="number">1</span> + inMid - inStart
    root.Left = t.traverse(inStart, inMid, prStart + <span class="number">1</span>, prMid)
    root.Right = t.traverse(inMid + <span class="number">1</span>, inEnd, prMid, prEnd)
    <span class="keyword">return</span> root
&#125;

<span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(preorder []<span class="type">int</span>, inorder []<span class="type">int</span>)</span></span> *TreeNode &#123;
    <span class="keyword">return</span> TreeBuilder&#123;inorder, preorder&#125;.traverse(<span class="number">0</span>, <span class="built_in">len</span>(inorder), <span class="number">0</span>, <span class="built_in">len</span>(preorder))
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>改写成slice更简洁</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(preorder []<span class="type">int</span>, inorder []<span class="type">int</span>)</span></span> *TreeNode &#123;
    <span class="comment">// fmt.Printf("%v | %v \n", preorder, inorder)</span>
    <span class="keyword">if</span> <span class="built_in">len</span>(preorder) == <span class="number">0</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;
    rootVal := preorder[<span class="number">0</span>]
    root := &TreeNode&#123;Val: rootVal&#125;
    <span class="keyword">if</span> <span class="built_in">len</span>(preorder) == <span class="number">1</span> &#123; <span class="keyword">return</span> root &#125;

    <span class="keyword">var</span> inMid <span class="type">int</span>
    <span class="keyword">for</span> inMid = <span class="number">0</span>; inMid < <span class="built_in">len</span>(inorder); inMid++ &#123;
        <span class="keyword">if</span> inorder[inMid] == rootVal &#123; <span class="keyword">break</span> &#125;
    &#125;

    root.Left = buildTree(preorder[<span class="number">1</span>:<span class="number">1</span>+inMid], inorder[:inMid])
    root.Right = buildTree(preorder[<span class="number">1</span>+inMid:], inorder[inMid+<span class="number">1</span>:])
    <span class="keyword">return</span> root
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="最大二叉树"><a class="header-anchor" href="#最大二叉树">¶</a>最大二叉树</h2>
<p><img src="https://img.shields.io/badge/leetcode-654-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-binary-tree/">最大二叉树</a></p>
<ul>
<li>递归</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">func</span> <span class="title">constructMaximumBinaryTree</span><span class="params">(nums []<span class="type">int</span>)</span></span> *TreeNode &#123;
    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;
    max := nums[<span class="number">0</span>]
    index := <span class="number">0</span>
    <span class="keyword">for</span> i, v := <span class="keyword">range</span> nums &#123;
        <span class="keyword">if</span> v > max &#123; 
            max = v
            index = i
        &#125;
    &#125;
    root := &TreeNode&#123;Val: max&#125;
    root.Left = constructMaximumBinaryTree(nums[:index])
    root.Right = constructMaximumBinaryTree(nums[index+<span class="number">1</span>:])
    <span class="keyword">return</span> root
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="合并二叉树"><a class="header-anchor" href="#合并二叉树">¶</a>合并二叉树</h2>
<p><img src="https://img.shields.io/badge/leetcode-617-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-binary-trees/">合并二叉树</a></p>
<ul>
<li>递归</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">func</span> <span class="title">mergeTrees</span><span class="params">(root1 *TreeNode, root2 *TreeNode)</span></span> *TreeNode &#123;
    <span class="keyword">if</span> root1 == <span class="literal">nil</span> &#123; <span class="keyword">return</span> root2 &#125;
    <span class="keyword">if</span> root2 == <span class="literal">nil</span> &#123; <span class="keyword">return</span> root1 &#125;
    root1.Val += root2.Val
    root1.Left = mergeTrees(root1.Left, root2.Left)
    root1.Right = mergeTrees(root1.Right, root2.Right)
    <span class="keyword">return</span> root1
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二叉搜索树中的搜索"><a class="header-anchor" href="#二叉搜索树中的搜索">¶</a>二叉搜索树中的搜索</h2>
<p><img src="https://img.shields.io/badge/leetcode-700-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">二叉搜索树中的搜索</a></p>
<ul>
<li>递归</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">func</span> <span class="title">searchBST</span><span class="params">(root *TreeNode, val <span class="type">int</span>)</span></span> *TreeNode &#123;
    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;
    <span class="keyword">if</span> root.Val > val &#123; <span class="keyword">return</span> searchBST(root.Left, val) &#125;
    <span class="keyword">if</span> root.Val < val &#123; <span class="keyword">return</span> searchBST(root.Right, val) &#125;
    <span class="keyword">return</span> root
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>迭代</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">func</span> <span class="title">searchBST</span><span class="params">(root *TreeNode, val <span class="type">int</span>)</span></span> *TreeNode &#123;
    <span class="keyword">for</span> root != <span class="literal">nil</span> &#123;
        <span class="keyword">if</span> root.Val > val &#123; 
            root = root.Left
        &#125; <span class="keyword">else</span> <span class="keyword">if</span> root.Val < val &#123;
            root = root.Right
        &#125; <span class="keyword">else</span> &#123;
            <span class="keyword">return</span> root
        &#125;
    &#125;
    <span class="keyword">return</span> <span class="literal">nil</span>
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="验证二叉搜索树"><a class="header-anchor" href="#验证二叉搜索树">¶</a>验证二叉搜索树</h2>
<p><img src="https://img.shields.io/badge/leetcode-98-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/validate-binary-search-tree/">验证二叉搜索树</a></p>
<ul>
<li>递归，注意子树区间必须，需要上下界来判断</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>

<span class="function"><span class="keyword">func</span> <span class="title">isValidBST</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;
    <span class="keyword">return</span> helper(root, math.MinInt64, math.MaxInt64)
&#125;

<span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(root *TreeNode, lower, upper <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;
    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;
        <span class="keyword">return</span> <span class="literal">true</span>
    &#125;
    <span class="keyword">if</span> root.Val <= lower || root.Val >= upper &#123;
        <span class="keyword">return</span> <span class="literal">false</span>
    &#125;
    <span class="keyword">return</span> helper(root.Left, lower, root.Val) && helper(root.Right, root.Val, upper)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>中序遍历，序列递增</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>

<span class="function"><span class="keyword">func</span> <span class="title">isValidBST</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;
    valid, _ := traverse(root, math.MinInt64)
    <span class="keyword">return</span> valid
&#125;

<span class="function"><span class="keyword">func</span> <span class="title">traverse</span><span class="params">(root *TreeNode, val <span class="type">int</span>)</span></span> (<span class="type">bool</span>, <span class="type">int</span>) &#123;
    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;
        <span class="keyword">return</span> <span class="literal">true</span>, val
    &#125;
    <span class="keyword">var</span> valid <span class="type">bool</span>
    valid, val = traverse(root.Left, val)
    <span class="keyword">if</span> !valid &#123;
        <span class="keyword">return</span> <span class="literal">false</span>, val
    &#125;

    <span class="keyword">if</span> root.Val <= val &#123;
        <span class="keyword">return</span> <span class="literal">false</span>, val
    &#125;
    val = root.Val

    valid, val = traverse(root.Right, val)
    <span class="keyword">if</span> !valid &#123;
        <span class="keyword">return</span> <span class="literal">false</span>, val
    &#125;
    <span class="keyword">return</span> <span class="literal">true</span>, val
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二叉搜索树的最小绝对差"><a class="header-anchor" href="#二叉搜索树的最小绝对差">¶</a>二叉搜索树的最小绝对差</h2>
<p><img src="https://img.shields.io/badge/leetcode-530-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/">二叉搜索树的最小绝对差</a></p>
<ul>
<li>中序遍历，Go的struct指针</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>
<span class="keyword">type</span> Searcher <span class="keyword">struct</span> &#123;
    min <span class="type">int</span>
    last <span class="type">int</span>
&#125;

<span class="function"><span class="keyword">func</span> <span class="title">Abs</span><span class="params">(a <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;
    <span class="keyword">if</span> a < <span class="number">0</span> &#123;
        <span class="keyword">return</span> -a
    &#125;
    <span class="keyword">return</span> a
&#125;

<span class="function"><span class="keyword">func</span> <span class="params">(s *Searcher)</span></span>traverse(root *TreeNode) &#123;
    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="keyword">return</span> &#125;
    s.traverse(root.Left)
    val := Abs(root.Val - s.last)
    <span class="keyword">if</span> val < s.min &#123;
        s.min = val
    &#125;
    s.last = root.Val
    s.traverse(root.Right)
&#125;

<span class="function"><span class="keyword">func</span> <span class="title">getMinimumDifference</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;
    s := Searcher&#123;math.MaxInt64, math.MaxInt64&#125;
    s.traverse(root)
    <span class="keyword">return</span> s.min
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二叉搜索树中的众数"><a class="header-anchor" href="#二叉搜索树中的众数">¶</a>二叉搜索树中的众数</h2>
<p><img src="https://img.shields.io/badge/leetcode-501-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/">二叉搜索树中的众数</a></p>
<ul>
<li>二叉搜索树中序遍历有序</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>
<span class="keyword">type</span> Searcher <span class="keyword">struct</span> &#123;
    Last <span class="type">int</span>
    Count <span class="type">int</span>
    MaxCount <span class="type">int</span>
    Modes []<span class="type">int</span>
&#125;

<span class="function"><span class="keyword">func</span> <span class="params">(s *Searcher)</span></span>traverse(root *TreeNode) &#123;
    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="keyword">return</span> &#125;
    s.traverse(root.Left)
    <span class="keyword">if</span> root.Val == s.Last &#123;
        s.Count++
    &#125; <span class="keyword">else</span> &#123;
        s.Last = root.Val
        s.Count = <span class="number">1</span>
    &#125;
    <span class="keyword">if</span> s.Count > s.MaxCount &#123;
        s.Modes = <span class="literal">nil</span>
        s.Modes = <span class="built_in">append</span>(s.Modes, root.Val)
        s.MaxCount = s.Count
    &#125; <span class="keyword">else</span> <span class="keyword">if</span> s.Count == s.MaxCount &#123;
        s.Modes = <span class="built_in">append</span>(s.Modes, root.Val)
    &#125;
    s.traverse(root.Right)
&#125;

<span class="function"><span class="keyword">func</span> <span class="title">findMode</span><span class="params">(root *TreeNode)</span></span> []<span class="type">int</span> &#123;
    s := Searcher&#123;
        Last: <span class="number">0</span>,
        Count: <span class="number">0</span>,
        MaxCount: <span class="number">0</span>,
    &#125;
    s.traverse(root)
    <span class="keyword">return</span> s.Modes
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二叉树的最近公共祖先"><a class="header-anchor" href="#二叉树的最近公共祖先">¶</a>二叉树的最近公共祖先</h2>
<p><img src="https://img.shields.io/badge/leetcode-236-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">二叉树的最近公共祖先</a></p>
<ul>
<li>递归</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>
 <span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(root, p, q *TreeNode)</span></span> *TreeNode &#123;
     <span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;
     <span class="keyword">if</span> root.Val == p.Val || root.Val == q.Val &#123;
         <span class="keyword">return</span> root
     &#125;
     left := lowestCommonAncestor(root.Left, p, q)
     right := lowestCommonAncestor(root.Right, p, q)
     <span class="keyword">if</span> left != <span class="literal">nil</span> && right != <span class="literal">nil</span> &#123; <span class="keyword">return</span> root &#125;
     <span class="keyword">if</span> left != <span class="literal">nil</span> && right == <span class="literal">nil</span> &#123; <span class="keyword">return</span> left &#125;
     <span class="keyword">if</span> left == <span class="literal">nil</span> && right != <span class="literal">nil</span> &#123; <span class="keyword">return</span> right &#125;
     <span class="keyword">return</span> <span class="literal">nil</span>
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二叉搜索树的最近公共祖先"><a class="header-anchor" href="#二叉搜索树的最近公共祖先">¶</a>二叉搜索树的最近公共祖先</h2>
<p><img src="https://img.shields.io/badge/leetcode-235-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">二叉搜索树的最近公共祖先</a></p>
<ul>
<li>二叉搜索树有序，前序遍历，第一个落在[p, q]或[q, p]区间的就是公共祖先</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val   int</span>
<span class="comment"> *     Left  *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>

<span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(root, p, q *TreeNode)</span></span> *TreeNode &#123;
	<span class="keyword">if</span> root.Val > p.Val && root.Val > q.Val &#123;
        <span class="keyword">return</span> lowestCommonAncestor(root.Left, p, q)
    &#125;
    <span class="keyword">if</span> root.Val < p.Val && root.Val < q.Val &#123;
        <span class="keyword">return</span> lowestCommonAncestor(root.Right, p, q)
    &#125;
    <span class="keyword">return</span> root
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>迭代</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val   int</span>
<span class="comment"> *     Left  *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>

<span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(root, p, q *TreeNode)</span></span> *TreeNode &#123;
    <span class="keyword">for</span> &#123;
        <span class="keyword">if</span> root.Val > p.Val && root.Val > q.Val &#123;
            root = root.Left
        &#125; <span class="keyword">else</span> <span class="keyword">if</span> root.Val < p.Val && root.Val < q.Val &#123;
            root = root.Right
        &#125; <span class="keyword">else</span> &#123;
            <span class="keyword">return</span> root
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二叉搜索树中的插入操作"><a class="header-anchor" href="#二叉搜索树中的插入操作">¶</a>二叉搜索树中的插入操作</h2>
<p><img src="https://img.shields.io/badge/leetcode-701-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/">二叉搜索树中的插入操作</a></p>
<ul>
<li>利用二叉搜索树的性质插入</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">func</span> <span class="title">insertIntoBST</span><span class="params">(root *TreeNode, val <span class="type">int</span>)</span></span> *TreeNode &#123;
    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;
        <span class="keyword">return</span> &TreeNode&#123;Val: val&#125;
    &#125;
    <span class="keyword">if</span> val < root.Val &#123;
        root.Left = insertIntoBST(root.Left, val)
    &#125;
    <span class="keyword">if</span> val > root.Val &#123;
        root.Right = insertIntoBST(root.Right, val)
    &#125;
    <span class="keyword">return</span> root
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="删除二叉搜索树中的节点"><a class="header-anchor" href="#删除二叉搜索树中的节点">¶</a>删除二叉搜索树中的节点</h2>
<p><img src="https://img.shields.io/badge/leetcode-450-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">删除二叉搜索树中的节点</a></p>
<ul>
<li>删除节点时分五种情况：
<ol>
<li>找不到</li>
<li>左右都为空，直接删除</li>
<li>左空右不空，等于右</li>
<li>右空左不空，等于左</li>
<li>左右都不空，有两种方案</li>
</ol>
<ul>
<li>用右子树中最小的节点替换，退化为2，因为右子树中最小节点也一定比左子树中的任意节点都大，这个节点是右子树的最左叶子节点。可以统一2/3/5。</li>
<li>把左子树挂在右子树的最左叶子节点，退化为3</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">func</span> <span class="title">deleteNode</span><span class="params">(root *TreeNode, key <span class="type">int</span>)</span></span> *TreeNode &#123;
    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="keyword">return</span> root &#125;
    <span class="keyword">if</span> root.Val == key &#123;
        <span class="keyword">if</span> root.Right == <span class="literal">nil</span> &#123;
            <span class="keyword">return</span> root.Left
        &#125;
        cur := root.Right
        <span class="keyword">for</span> cur.Left != <span class="literal">nil</span> &#123;
            cur = cur.Left
        &#125;
        root.Val, cur.Val = cur.Val, root.Val
    &#125;
    root.Left = deleteNode(root.Left, key)
    root.Right = deleteNode(root.Right, key)
    <span class="keyword">return</span> root
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="修剪二叉搜索树"><a class="header-anchor" href="#修剪二叉搜索树">¶</a>修剪二叉搜索树</h2>
<p><img src="https://img.shields.io/badge/leetcode-669-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/">修剪二叉搜索树</a></p>
<ul>
<li>前序遍历，如果节点值小于下界，左子树一定都小于下界，右子树不一定，可以先把右子树替换当前节点，递归判断。</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">func</span> <span class="title">trimBST</span><span class="params">(root *TreeNode, low <span class="type">int</span>, high <span class="type">int</span>)</span></span> *TreeNode &#123;
    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="keyword">return</span> root &#125;
    <span class="keyword">if</span> root.Val < low &#123;
        <span class="keyword">return</span> trimBST(root.Right, low, high)
    &#125;
    <span class="keyword">if</span> root.Val > high &#123;
        <span class="keyword">return</span> trimBST(root.Left, low, high)
    &#125;
    root.Left = trimBST(root.Left, low, high)
    root.Right = trimBST(root.Right, low, high)
    <span class="keyword">return</span> root
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="将有序数组转换为二叉搜索树"><a class="header-anchor" href="#将有序数组转换为二叉搜索树">¶</a>将有序数组转换为二叉搜索树</h2>
<p><img src="https://img.shields.io/badge/leetcode-108-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">将有序数组转换为二叉搜索树</a></p>
<ul>
<li>利用二叉搜索树有序特性，二分数组</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">func</span> <span class="title">sortedArrayToBST</span><span class="params">(nums []<span class="type">int</span>)</span></span> *TreeNode &#123;
    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;
    mid := <span class="built_in">len</span>(nums) / <span class="number">2</span>
    root := &TreeNode&#123;Val: nums[mid]&#125;
    root.Left = sortedArrayToBST(nums[:mid])
    root.Right = sortedArrayToBST(nums[mid+<span class="number">1</span>:])
    <span class="keyword">return</span> root
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="把二叉搜索树转换为累加树"><a class="header-anchor" href="#把二叉搜索树转换为累加树">¶</a>把二叉搜索树转换为累加树</h2>
<p><img src="https://img.shields.io/badge/leetcode-538-blue.svg" alt=""> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">把二叉搜索树转换为累加树</a></p>
<ul>
<li>反中序遍历累加即可</li>
</ul>
<pre class="line-numbers language-highlight go"><span class="comment"><code class="language-highlight go"><span class="comment">/**</span>
<span class="comment"> * Definition for a binary tree node.</span>
<span class="comment"> * type TreeNode struct &#123;</span>
<span class="comment"> *     Val int</span>
<span class="comment"> *     Left *TreeNode</span>
<span class="comment"> *     Right *TreeNode</span>
<span class="comment"> * &#125;</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">func</span> <span class="title">traverse</span><span class="params">(root *TreeNode, val <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;
    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="keyword">return</span> val &#125;
    val = traverse(root.Right, val)
    root.Val += val
    val = root.Val
    val = traverse(root.Left, val)
    <span class="keyword">return</span> val
&#125;

<span class="function"><span class="keyword">func</span> <span class="title">convertBST</span><span class="params">(root *TreeNode)</span></span> *TreeNode &#123;
    traverse(root, <span class="number">0</span>)
    <span class="keyword">return</span> root
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
</p></div><div class="share"><span>Share</span>&nbsp;<span class="soc"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></span><span class="soc"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></span><span class="soc"><a target="_blank" rel="noopener" href="http://twitter.com/home?status=https://kleon1024.github.io/cs/algo/tree/%20KLEON%20算法基础 - 树" class="fa fa-twitter"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/cs/algo/array/" title="算法基础 - 数组"><i class="fa fa-angle-double-left"></i>&nbsp;Previous post: 算法基础 - 数组</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/cs/algo/sort/" title="算法基础 - 排序">Next post: 算法基础 - 排序&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2022&nbsp;<a target="_blank" href="https://kleon1024.github.io" rel="noopener noreferrer">Kleon</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>