<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>算法基础 - 链表 · KLEON</title><meta name="description" content="表是最基础的数据结构之一，存储线性数据，内存结构不连续。

#基础
链表可通过自定义数据结构，使用指针或引用指向前后节点。
Go提供了&amp;quot;container/list&amp;quot;1标准库实现双向链表。
package main

import (
	&quot;container/list&quot;
	&quot;fm"><meta name="og:description" content="表是最基础的数据结构之一，存储线性数据，内存结构不连续。

#基础
链表可通过自定义数据结构，使用指针或引用指向前后节点。
Go提供了&amp;quot;container/list&amp;quot;1标准库实现双向链表。
package main

import (
	&quot;container/list&quot;
	&quot;fm"><meta name="twitter:site" content="KLEON"><meta name="twitter:title" content="算法基础 - 链表"><meta name="twitter:card" content="summary"><meta name="keywords" content=""><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 6.1.0"><link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div id="stage" class="container"><div class="row"><div id="side-bar" class="col-sm-3 col-xs-12 side-container invisible"><div class="vertical-text site-title"><h3 tabindex="-1" class="site-title-small"><a href="/" class="a-title"></a></h3><h1 tabindex="-1" class="site-title-large"><a href="/" class="a-title">自说自话</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div id="site-nav" class="site-title-links"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li><li><a href="/categories">Categories</a></li><li><a href="/tags">Tags</a></li><li><a href="/googlebe23cb0bc55fc412.html"></a></li><li><a href="/about/index.html"></a></li><li class="soc"><a href="https://github.com/kleon1024" target="_blank" rel="noopener noreferrer" aria-label="Github"><i class="fa fa-github">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2022&nbsp;<a target="_blank" href="https://blog.kleon.space" rel="noopener noreferrer">Kleon</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div id="main-container" class="col-sm-9 col-xs-12 main-container invisible"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>算法基础 - 链表</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2021-03-12</span><span class="meta-item"><i class="fa fa-folder"></i><span>&nbsp;</span><a href="/categories/算法/" title="算法" class="a-tag">算法</a><span>&nbsp;</span></span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a href="/tags/算法/" title="算法" class="a-tag">算法</a><span>&nbsp;</span><a href="/tags/数据结构/" title="数据结构" class="a-tag">数据结构</a><span>&nbsp;</span><a href="/tags/leetcode/" title="leetcode" class="a-tag">leetcode</a><span>&nbsp;</span></span></p><p class="post-abstract"><p>表是最基础的数据结构之一，存储线性数据，内存结构不连续。</p>
<span id="more"></span>
<h1><a href="#ji-chu" class="header-anchor">#</a><span id="ji-chu">基础</span></h1>
<p>链表可通过自定义数据结构，使用指针或引用指向前后节点。</p>
<p>Go提供了&quot;container/list&quot;<a href="#refer-1"><sup>1</sup></a>标准库实现双向链表。</p>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">package main

import (
	"container/list"
	"fmt"
)

func main() &#123;
	// Create a new list and put some numbers in it.
	l := list.New()
	e4 := l.PushBack(4)
	e1 := l.PushFront(1)
	l.InsertBefore(3, e4)
	l.InsertAfter(2, e1)

	// Iterate through list and print its contents.
	for e := l.Front(); e != nil; e = e.Next() &#123;
		fmt.Println(e.Value)
	&#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1><a href="#shi-zhan" class="header-anchor">#</a><span id="shi-zhan">实战</span></h1>
<h2><a href="#xu-ni-tou-jie-dian-yi-chu-lian-biao-zhong-zhi-ding-yuan-su" class="header-anchor">#</a><span id="xu-ni-tou-jie-dian-yi-chu-lian-biao-zhong-zhi-ding-yuan-su">虚拟头结点移除链表中指定元素</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-203-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-linked-list-elements/">移除链表元素</a></p>
<ul>
<li>基本链表操作</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for singly-linked list.
 * type ListNode struct &#123;
 *     Val int
 *     Next *ListNode
 * &#125;
 */
func removeElements(head *ListNode, val int) *ListNode &#123;
    vhead := &ListNode&#123;0,head&#125;
    head = vhead

    for head != nil && head.Next != nil &#123;
        if head.Next.Val == val &#123;
            head.Next = head.Next.Next
        &#125; else &#123;
            head = head.Next
        &#125;
    &#125;

    return vhead.Next
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><a href="#shi-xian-lian-biao-ji-ben-cao-zuo" class="header-anchor">#</a><span id="shi-xian-lian-biao-ji-ben-cao-zuo">实现链表基本操作</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-707-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/design-linked-list/">设计链表</a></p>
<ul>
<li>单向链表</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">type Node struct &#123;
	Val  int
	Next *Node
&#125;

type MyLinkedList struct &#123;
	size int
	head *Node
&#125;

/** Initialize your data structure here. */
func Constructor() MyLinkedList &#123;
	return MyLinkedList&#123;
		0,
		&Node&#123;&#125;,
	&#125;
&#125;

/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */
func (this *MyLinkedList) Get(index int) int &#123;
    if index < 0 || index >= this.size &#123;
        return -1
    &#125;

	prev := this.head
	for i := 0; i < index; i++ &#123;
		prev = prev.Next
	&#125;
	return prev.Next.Val
&#125;

/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */
func (this *MyLinkedList) AddAtHead(val int) &#123;
	this.AddAtIndex(0, val)
&#125;

/** Append a node of value val to the last element of the linked list. */
func (this *MyLinkedList) AddAtTail(val int) &#123;
	this.AddAtIndex(this.size, val)
&#125;

/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */
func (this *MyLinkedList) AddAtIndex(index int, val int) &#123;
    if index < 0 || index > this.size &#123;
        return
    &#125;

	prev := this.head
	for i := 0; i < index; i++ &#123;
		prev = prev.Next
	&#125;
	node := &Node&#123;Val: val&#125;
	node.Next = prev.Next
	prev.Next = node

	this.size++
&#125;

/** Delete the index-th node in the linked list, if the index is valid. */
func (this *MyLinkedList) DeleteAtIndex(index int) &#123;
    if index < 0 || index >= this.size &#123;
        return
    &#125;

	prev := this.head
	for i := 0; i < index; i++ &#123;
		prev = prev.Next
	&#125;
	prev.Next = prev.Next.Next

	this.size--
&#125;

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * obj := Constructor();
 * param_1 := obj.Get(index);
 * obj.AddAtHead(val);
 * obj.AddAtTail(val);
 * obj.AddAtIndex(index,val);
 * obj.DeleteAtIndex(index);
 */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>双向链表</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">type Node struct &#123;
    Val int
    Next *Node
    Prev *Node
&#125;

type MyLinkedList struct &#123;
    Head *Node
    Tail *Node
    Length int
&#125;

/** Initialize your data structure here. */
func Constructor() MyLinkedList &#123;
    head := &Node&#123;&#125;
    tail := &Node&#123;&#125;
    head.Next = tail
    tail.Prev = head
    return MyLinkedList&#123;
        Head: head,
        Tail: tail,
        Length: 0,
    &#125;
&#125;

func (this *MyLinkedList) Print(str string) &#123;
    fmt.Printf("---%v---\n", str)
    pt := this.Head
    fmt.Printf("head %v\n", pt)
    for i := 0; i <= this.length; i++&#123; pt="pt.Next" fmt.printf("%v %v\n", i, pt) &#125; fmt.printf("tail ** get the value of index-th node in linked list. if index is invalid, return -1. * func (this *mylinkedlist) get(index int) int &#123;>= this.Length &#123;
        return -1
    &#125;
    ret := this.Head
    for i := 0; i <= 0 index; i++ &#123; ret="ret.Next" &#125; return ret.val ** add a node of value val before the first element linked list. after insertion, new will be * func (this *mylinkedlist) addathead(val int) :="&Node&#123;" val: val, next: this.head.next, prev: this.head, this.head.next.prev="node" this.head.next="node" if this.tail.prev.prev="=" nil this.tail.prev="this.Head.Next" this.length++ this.print("addathead") append to last addattail(val this.tail, this.tail.prev, this.tail.prev.next="node" this.head.next.next="=" this.print("addattail") index-th in index equals length list, appended end is greater than length, not inserted. addatindex(index int, this.length this.addattail(val) < this.addathead(val) var pt *node for i pt, pt.prev, pt.prev.next="node" pt.prev="node" this.print("addatindex") delete valid. deleteatindex(index>= this.Length &#123;
        return
    &#125;

    if index < 0 &#123;
        index = this.Length + index
    &#125;

    var pt *Node
    pt = this.Head
    for i := 0; i <= index; i++ &#123; pt="pt.Next" &#125; pt.prev.next="pt.Next" pt.next.prev="pt.Prev" this.length-- this.print("deleteatindex") ** * your mylinkedlist object will be instantiated and called as such: obj :="Constructor();" param_1 obj.addathead(val); obj.addattail(val); obj.addatindex(index,val); obj.deleteatindex(index); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></=></=></=></code></pre>
<h2><a href="#fan-zhuan-lian-biao" class="header-anchor">#</a><span id="fan-zhuan-lian-biao">反转链表</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-206-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list/">反转链表</a></p>
<ul>
<li>构建新链表</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for singly-linked list.
 * type ListNode struct &#123;
 *     Val int
 *     Next *ListNode
 * &#125;
 */
func reverseList(head *ListNode) *ListNode &#123;
    pt := head
    var tail *ListNode
    for pt != nil &#123;
        tail = &ListNode&#123;
            pt.Val,
            tail,
        &#125;
        pt = pt.Next
    &#125;
    return tail
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>双指针法</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for singly-linked list.
 * type ListNode struct &#123;
 *     Val int
 *     Next *ListNode
 * &#125;
 */
func reverseList(head *ListNode) *ListNode &#123;
    var pre, temp *ListNode
    cur := head
    for cur != nil &#123;
        temp = cur.Next
        cur.Next = pre
        pre = cur
        cur = temp
    &#125;
    return pre
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><a href="#huan-xing-lian-biao-de-ru-huan-jie-dian" class="header-anchor">#</a><span id="huan-xing-lian-biao-de-ru-huan-jie-dian">环形链表的入环节点</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-141-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle/">环形链表</a><br>
<img src="https://img.shields.io/badge/leetcode-142-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">环形链表II</a></p>
<p>$$<br>
fast = x + y + n(y + z)<br>
$$</p>
<p>$$<br>
slow = x + y<br>
$$</p>
<p>$$<br>
fast = 2slow<br>
$$</p>
<p>$$<br>
x + y = n(y + z)<br>
$$</p>
<p>$$<br>
x = (n - 1)(y + z) + z<br>
$$</p>
<p>n = 1时， x = z</p>
<ul>
<li>快慢指针法</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for singly-linked list.
 * type ListNode struct &#123;
 *     Val int
 *     Next *ListNode
 * &#125;
 */
func detectCycle(head *ListNode) *ListNode &#123;
    fast := head
    slow := head
    for fast != nil && fast.Next != nil &#123;
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast &#123;
            p1 := fast
            p2 := head
            for p1 != p2 &#123;
                p1 = p1.Next
                p2 = p2.Next
            &#125;
            return p2
        &#125;
    &#125;
    return nil
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><a href="#shan-chu-pai-xu-lian-biao-zhong-de-chong-fu-yuan-su-ii" class="header-anchor">#</a><span id="shan-chu-pai-xu-lian-biao-zhong-de-chong-fu-yuan-su-ii">删除排序链表中的重复元素 II</span></h2>
<p><img src="https://img.shields.io/badge/leetcode-82-blue.svg" alt> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">删除排序链表中的重复元素 II</a></p>
<ul>
<li>操作指针，开始指针，结束指针。注意绝对不重复的条件是开始指针和结束指针相邻且不相等。</li>
</ul>
<pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">/**
 * Definition for singly-linked list.
 * type ListNode struct &#123;
 *     Val int
 *     Next *ListNode
 * &#125;
 */
func deleteDuplicates(head *ListNode) *ListNode &#123;
    if head == nil || head.Next == nil &#123; return head &#125;
    vhead := &ListNode&#123;Next:head&#125;
    cur := vhead
    start := vhead.Next
    end := vhead.Next.Next
    for start != nil && end != nil &#123;
        if start.Val != end.Val &#123;
            if end == start.Next &#123;
                cur = cur.Next
            &#125;
            start = end
            end = end.Next
        &#125; else &#123;
            end = end.Next
            cur.Next = end
        &#125;
    &#125;
    return vhead.Next
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<ul>
<li>[1] <span id="refer-1"></span> <a target="_blank" rel="noopener" href="https://golang.org/pkg/container/list/">Package list</a></li>
</ul>
</p></div><div class="share"><span>Share</span>&nbsp;<span class="soc"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></span><span class="soc"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></span><span class="soc"><a target="_blank" rel="noopener" href="http://twitter.com/home?status=https://blog.kleon.space/cs/algo/list/%20KLEON%20算法基础 - 链表" class="fa fa-twitter"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/cs/algo/sort/" title="算法基础 - 排序"><i class="fa fa-angle-double-left"></i>&nbsp;Previous post: 算法基础 - 排序</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/cs/algo/priority-queue/" title="算法基础 - 优先队列">Next post: 算法基础 - 优先队列&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2022&nbsp;<a target="_blank" href="https://blog.kleon.space" rel="noopener noreferrer">Kleon</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>