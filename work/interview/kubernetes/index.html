<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>烤面筋 - Kubernetes · KLEON</title><meta name="description" content="k8s基本常识

#基本概念
https://segmentfault.com/a/1190000039334395
https://www.kubernetes.org.cn/5578.html
https://www.qikqiak.com/k8s-book/docs/15.基本概念与组件.ht"><meta name="og:description" content="k8s基本常识

#基本概念
https://segmentfault.com/a/1190000039334395
https://www.kubernetes.org.cn/5578.html
https://www.qikqiak.com/k8s-book/docs/15.基本概念与组件.ht"><meta name="twitter:site" content="KLEON"><meta name="twitter:title" content="烤面筋 - Kubernetes"><meta name="twitter:card" content="summary"><meta name="keywords" content=""><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/github.min.css"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 6.1.0"></head><body><div id="stage" class="container"><div class="row"><div id="side-bar" class="col-sm-3 col-xs-12 side-container invisible"><div class="vertical-text site-title"><h3 tabindex="-1" class="site-title-small"><a href="/" class="a-title"></a></h3><h1 tabindex="-1" class="site-title-large"><a href="/" class="a-title">自说自话</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div id="site-nav" class="site-title-links"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li><li><a href="/categories">Categories</a></li><li><a href="/tags">Tags</a></li><li><a href="/googlebe23cb0bc55fc412.html"></a></li><li><a href="/about/index.html"></a></li><li class="soc"><a href="https://github.com/kleon1024" target="_blank" rel="noopener noreferrer" aria-label="Github"><i class="fa fa-github">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2022&nbsp;<a target="_blank" href="https://blog.kleon.space" rel="noopener noreferrer">Kleon</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div id="main-container" class="col-sm-9 col-xs-12 main-container invisible"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>烤面筋 - Kubernetes</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2021-05-25</span><span class="date meta-item">Updated at&nbsp;2021-05-15</span><span class="meta-item"><i class="fa fa-folder"></i><span>&nbsp;</span><a href="/categories/面筋/" title="面筋" class="a-tag">面筋</a><span>&nbsp;</span></span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a href="/tags/面筋/" title="面筋" class="a-tag">面筋</a><span>&nbsp;</span></span></p><p class="post-abstract"><p>k8s基本常识</p>
<span id="more"></span>
<h1><a href="#ji-ben-gai-nian" class="header-anchor">#</a><span id="ji-ben-gai-nian">基本概念</span></h1>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000039334395">https://segmentfault.com/a/1190000039334395</a></p>
<p><a target="_blank" rel="noopener" href="https://www.kubernetes.org.cn/5578.html">https://www.kubernetes.org.cn/5578.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.qikqiak.com/k8s-book/docs/15.%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%BB%84%E4%BB%B6.html">https://www.qikqiak.com/k8s-book/docs/15.基本概念与组件.html</a></p>
<h2><a href="#zi-yuan-ge-chi" class="header-anchor">#</a><span id="zi-yuan-ge-chi">资源隔离</span></h2>
<p>Linux CGROUP</p>
<h3><a href="#cpu" class="header-anchor">#</a><span id="cpu">CPU</span></h3>
<p>绑核</p>
<h3><a href="#memory" class="header-anchor">#</a><span id="memory">Memory</span></h3>
<h3><a href="#device" class="header-anchor">#</a><span id="device">Device</span></h3>
<h3><a href="#disk-io" class="header-anchor">#</a><span id="disk-io">Disk IO</span></h3>
<p><a target="_blank" rel="noopener" href="https://blog.kelu.org/tech/2019/10/11/kubernetes-Limit-iops-per-container.html">https://blog.kelu.org/tech/2019/10/11/kubernetes-Limit-iops-per-container.html</a></p>
<p>Docker中有修改dockershim，和kuberuntime的labels</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">annotations: <br>  BlkioDeviceWriteBps: &#x27;/dev/sda:31457280&#x27;<br></code></pre></td></tr></table></figure>
<h3><a href="#network-io" class="header-anchor">#</a><span id="network-io">Network IO</span></h3>
<p>kubectl apply -f <a target="_blank" rel="noopener" href="http://acs-public.oss-cn-hangzhou.aliyuncs.com/kubernetes/network/kube-tc.yml">http://acs-public.oss-cn-hangzhou.aliyuncs.com/kubernetes/network/kube-tc.yml</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/388097">https://developer.aliyun.com/article/388097</a></p>
<blockquote>
<p>部署之前，请先在集群下所有Kubernetes节点上执行modprobe sch_htb ，确保每个节点都要执行<br>
如果您用的网络插件不是flannel，请将编排文件的 args: [“-interface”, “eth0”, “-network”, “flannel”]改成 args: [“-interface”, “eth0”]</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">annotations:<br>  kubernetes.io/ingress-bandwidth: 5M  #进入到容器的最大带宽<br>  kubernetes.io/egress-bandwidth: 10M   #容器向外访问的最大带宽<br><br></code></pre></td></tr></table></figure>
<h2><a href="#jia-gou" class="header-anchor">#</a><span id="jia-gou">架构</span></h2>
<p>apiserver、controller、kubelet、scheduler</p>
<p>Kubernetes 主要由以下几个核心组件组成:</p>
<ul>
<li>etcd 保存了整个集群的状态，就是一个数据库；</li>
<li>apiserver 提供了资源操作的唯一入口，并提供认证、授权、访问控制、API 注册和发现等机制；</li>
<li>controller manager 负责维护集群的状态，比如故障检测、自动扩展、滚动更新等；</li>
<li>scheduler 负责资源的调度，按照预定的调度策略将 Pod 调度到相应的机器上；</li>
<li>kubelet 负责维护容器的生命周期，同时也负责 Volume（CSI）和网络（CNI）的管理；</li>
<li>Container runtime 负责镜像管理以及 Pod 和容器的真正运行（CRI）；</li>
<li>kube-proxy 负责为 Service 提供 cluster 内部的服务发现和负载均衡；</li>
</ul>
<p>插件：</p>
<ul>
<li>kube-dns 负责为整个集群提供 DNS 服务</li>
<li>Ingress Controller 为服务提供外网入口</li>
<li>Heapster 提供资源监控</li>
<li>Dashboard 提供 GUI</li>
</ul>
<h2><a href="#pod" class="header-anchor">#</a><span id="pod">Pod</span></h2>
<p><a target="_blank" rel="noopener" href="https://draveness.me/kubernetes-pod/">https://draveness.me/kubernetes-pod/</a></p>
<p><a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/concepts/workloads/pods/">https://kubernetes.io/zh/docs/concepts/workloads/pods/</a></p>
<p>Pod 是可以在 Kubernetes 中创建和管理的、最小的可部署的计算单元。</p>
<p>Pod （就像在鲸鱼荚或者豌豆荚中）是一组（一个或多个） 容器； 这些容器共享存储、网络、以及怎样运行这些容器的声明。 Pod 中的内容总是并置（colocated）的并且一同调度，在共享的上下文中运行。 Pod 所建模的是特定于应用的“逻辑主机”，其中包含一个或多个应用容器， 这些容器是相对紧密的耦合在一起的。 在非云环境中，在相同的物理机或虚拟机上运行的应用类似于 在同一逻辑主机上运行的云应用。</p>
<p>Pod共享网络、存储以及 CPU、内存、进程命名空间等资源。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">shareProcessNamespace: true<br></code></pre></td></tr></table></figure>
<p>Pod生命周期：</p>
<ol>
<li>Create</li>
<li>Probe</li>
<li>Running</li>
<li>Shutdown</li>
<li>Restart</li>
</ol>
<p>当 Pod 被创建之后，就会进入健康检查状态，当 Kubernetes 确定当前 Pod 已经能够接受外部的请求时，才会将流量打到新的 Pod 上并继续对外提供服务，在这期间如果发生了错误就可能会触发重启机制，在 Pod 被删除之前都会触发一个 PreStop 的钩子，其中的方法完成之后 Pod 才会被删除。</p>
<p>LivenessProbe ReadinessProbe</p>
<ul>
<li>exec</li>
<li>httpGet</li>
<li>tcpSocket</li>
</ul>
<h2><a href="#fu-wu" class="header-anchor">#</a><span id="fu-wu">服务</span></h2>
<p><a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/concepts/services-networking/service/">https://kubernetes.io/zh/docs/concepts/services-networking/service/</a></p>
<p>将运行在一组 Pods 上的应用程序公开为网络服务的抽象方法。<br>
使用 Kubernetes，你无需修改应用程序即可使用不熟悉的服务发现机制。 Kubernetes 为 Pods 提供自己的 IP 地址，并为一组 Pod 提供相同的 DNS 名， 并且可以在它们之间进行负载均衡。</p>
<p>在 Kubernetes 中创建一个新的 Service 对象需要两大模块同时协作，其中一个模块是控制器，它需要在每次客户端创建新的 Service 对象时，生成其他用于暴露一组 Pod 的 Kubernetes 对象，也就是 Endpoint 对象；另一个模块是 kube-proxy，它运行在 Kubernetes 集群中的每一个节点上，会根据 Service 和 Endpoint 的变动改变节点上 iptables 或者 ipvs 中保存的规则。</p>
<h3><a href="#servicecontroller" class="header-anchor">#</a><span id="servicecontroller">ServiceController</span></h3>
<p>每当有服务被创建或者销毁时，Informer 都会通知 ServiceController，它会将这些任务投入工作队列中并由其本身启动的 Worker 协程消费。ServiceController 主要处理的还是与 LoadBalancer 相关的逻辑。</p>
<h3><a href="#endpointcontroller" class="header-anchor">#</a><span id="endpointcontroller">EndpointController</span></h3>
<p>EndpointController 本身并没有通过 Informer 监听 Endpoint 资源的变动，但是它却同时订阅了 Service 和 Pod 资源的增删事件。</p>
<p>对于每一个 Pod 都会生成一个新的 EndpointSubset，其中包含了 Pod 的 IP 地址和端口和 Service 的规格中指定的输入端口和目标端口，在最后 EndpointSubset 的数据会被重新打包并通过客户端创建一个新的 Endpoint 资源。</p>
<h3><a href="#kube-proxy" class="header-anchor">#</a><span id="kube-proxy">Kube-Proxy</span></h3>
<p>在整个集群中另一个订阅 Service 对象变动的组件就是 kube-proxy 了，每当 kube-proxy 在新的节点上启动时都会初始化一个 ServiceConfig 对象，就像介绍 iptables 代理模式时提到的，这个对象会接受 Service 的变更事件。<br>
这些变更事件都会被订阅了集群中对象变动的 ServiceConfig 和 EndpointConfig 对象推送给启动的 Proxier 实例。<br>
收到事件变动的 Proxier 实例随后会根据启动时的配置更新 iptables 或者 ipvs 中的规则，这些应用最终会负责对进出的流量进行转发并完成一些负载均衡相关的任务。</p>
<ul>
<li>userspace 用户空间</li>
</ul>
<p>在用户空间模式中，如果一个连接被目标服务拒绝，我们的代理服务能够重新尝试连接其他的服务，除此之外用户空间模式并没有太多的优势。</p>
<ul>
<li>iptable 内核</li>
</ul>
<p>虽然相比于用户空间来说，直接运行在内核态的 iptables 能够增加代理的吞吐量，但是当集群中的节点数量非常多时，iptables 并不能达到生产级别的可用性要求，每次对规则进行匹配时都会遍历 iptables 中的所有 Service 链。</p>
<p>规则的更新也不是增量式的，当集群中的 Service 达到 5,000 个，每增加一条规则都需要耗时 11min，当集群中的 Service 达到 20,000 个时，每增加一条规则都需要消耗 5h 的时间，这也就是告诉我们在大规模集群中使用 iptables 作为代理模式是完全不可用的。</p>
<ul>
<li>ipvs 内核，更快，更复杂</li>
</ul>
<p>ipvs 就是用于解决在大量 Service 时，iptables 规则同步变得不可用的性能问题。与 iptables 比较像的是，ipvs 的实现虽然也基于 netfilter 的钩子函数，但是它却使用哈希表作为底层的数据结构并且工作在内核态，这也就是说 ipvs 在重定向流量和同步代理规则有着更好的性能。</p>
<p>除了能够提升性能之外，ipvs 也提供了多种类型的负载均衡算法，除了最常见的 Round-Robin 之外，还支持最小连接、目标哈希、最小延迟等算法，能够很好地提升负载均衡的效率。</p>
<h2><a href="#volume" class="header-anchor">#</a><span id="volume">Volume</span></h2>
<p><a target="_blank" rel="noopener" href="https://draveness.me/kubernetes-volume/">https://draveness.me/kubernetes-volume/</a></p>
<ul>
<li>Volume</li>
<li>Persistent Volume</li>
<li>Dynamic Volume Provisioning</li>
</ul>
<p>集群中的每一个卷在被 Pod 使用时都会经历四个操作，也就是附着（Attach）、挂载（Mount）、卸载（Unmount）和分离（Detach）。</p>
<p>如果 Pod 中使用的是 EmptyDir、HostPath 这种类型的卷，那么这些卷并不会经历附着和分离的操作，它们只会被挂载和卸载到某一个的 Pod 中，不过如果使用的云服务商提供的存储服务，这些持久卷只有附着到某一个节点之后才可以被挂在到相应的目录下，不过在其他节点使用这些卷时，该存储资源也需要先与当前的节点分离。</p>
<h3><a href="#mo-shi" class="header-anchor">#</a><span id="mo-shi">模式</span></h3>
<p>ReadWriteOnce 表示当前卷可以被一个节点使用读写模式挂载；<br>
ReadOnlyMany 表示当前卷可以被多个节点使用只读模式挂载；<br>
ReadWriteMany 表示当前卷可以被多个节点使用读写模式挂载；</p>
<h3><a href="#hui-shou" class="header-anchor">#</a><span id="hui-shou">回收</span></h3>
<p>Retain<br>
Delete<br>
Dynamic Provisioning</p>
<h2><a href="#statefulset" class="header-anchor">#</a><span id="statefulset">StatefulSet</span></h2>
<p><a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/concepts/workloads/controllers/statefulset/">https://kubernetes.io/zh/docs/concepts/workloads/controllers/statefulset/</a></p>
<p>StatefulSet 用来管理某 Pod 集合的部署和扩缩， 并为这些 Pod 提供持久存储和持久标识符。</p>
<p>和 Deployment 类似， StatefulSet 管理基于相同容器规约的一组 Pod。但和 Deployment 不同的是， StatefulSet 为它们的每个 Pod 维护了一个有粘性的 ID。这些 Pod 是基于相同的规约来创建的， 但是不能相互替换：无论怎么调度，每个 Pod 都有一个永久不变的 ID。</p>
<h3><a href="#gun-dong-geng-xin" class="header-anchor">#</a><span id="gun-dong-geng-xin">滚动更新</span></h3>
<p>RollingUpdate 更新策略对 StatefulSet 中的 Pod 执行自动的滚动更新。 在没有声明 .spec.updateStrategy 时，RollingUpdate 是默认配置。 当 StatefulSet 的 .spec.updateStrategy.type 被设置为 RollingUpdate 时， StatefulSet 控制器会删除和重建 StatefulSet 中的每个 Pod。 它将按照与 Pod 终止相同的顺序（从最大序号到最小序号）进行，每次更新一个 Pod。 它会等到被更新的 Pod 进入 Running 和 Ready 状态，然后再更新其前身。</p>
<h4><a href="#fen-qu" class="header-anchor">#</a><span id="fen-qu">分区</span></h4>
<p>通过声明 .spec.updateStrategy.rollingUpdate.partition 的方式，RollingUpdate 更新策略可以实现分区。 如果声明了一个分区，当 StatefulSet 的 .spec.template 被更新时， 所有序号大于等于该分区序号的 Pod 都会被更新。 所有序号小于该分区序号的 Pod 都不会被更新，并且，即使他们被删除也会依据之前的版本进行重建。 如果 StatefulSet 的 .spec.updateStrategy.rollingUpdate.partition 大于它的 .spec.replicas，对它的 .spec.template 的更新将不会传递到它的 Pod。 在大多数情况下，你不需要使用分区，但如果你希望进行阶段更新、执行金丝雀或执行 分阶段上线，则这些分区会非常有用。</p>
<h2><a href="#daemonset" class="header-anchor">#</a><span id="daemonset">DaemonSet</span></h2>
<p><a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/concepts/workloads/controllers/daemonset/">https://kubernetes.io/zh/docs/concepts/workloads/controllers/daemonset/</a></p>
<p>DaemonSet 确保全部（或者某些）节点上运行一个 Pod 的副本。 当有节点加入集群时， 也会为他们新增一个 Pod 。 当有节点从集群移除时，这些 Pod 也会被回收。删除 DaemonSet 将会删除它创建的所有 Pod。</p>
<p>DaemonSet 的一些典型用法：</p>
<p>在每个节点上运行集群守护进程<br>
在每个节点上运行日志收集守护进程<br>
在每个节点上运行监控守护进程</p>
<h2><a href="#job-cronjob" class="header-anchor">#</a><span id="job-cronjob">Job/CronJob</span></h2>
<h2><a href="#informer" class="header-anchor">#</a><span id="informer">Informer</span></h2>
<p><a target="_blank" rel="noopener" href="https://www.kubernetes.org.cn/6905.html">https://www.kubernetes.org.cn/6905.html</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000022643082">https://segmentfault.com/a/1190000022643082</a></p>
<h2><a href="#kuo-zhan" class="header-anchor">#</a><span id="kuo-zhan">扩展</span></h2>
<h3><a href="#crd" class="header-anchor">#</a><span id="crd">CRD</span></h3>
<p>operator</p>
<h3><a href="#container-plugin" class="header-anchor">#</a><span id="container-plugin">Container Plugin</span></h3>
<h3><a href="#storage-plugin" class="header-anchor">#</a><span id="storage-plugin">Storage Plugin</span></h3>
<h3><a href="#device-plugin" class="header-anchor">#</a><span id="device-plugin">Device Plugin</span></h3>
<h2><a href="#ban-ben-hao" class="header-anchor">#</a><span id="ban-ben-hao">版本号</span></h2>
<ol>
<li>高内聚、低耦合。</li>
<li>无缝的 API 集成。</li>
<li>为每一项服务分配唯一的资源标识。</li>
<li>实时流量管理。</li>
<li>最小化数据表，以优化加载。</li>
<li>通过内/外部 API，执行持续监控。</li>
<li>为每个微服务隔离数据的存储。这对于限制数据的访问和避免“服务的耦合”是非常有用的。 例如：基于用户的分类数据，我们可以实施命令查询的责任分离（Command Query Responsibility Segregation，CQRS）。</li>
<li>去中心化。设计微服务架构的首要原则是：将单体结构分解成独立的多个实体，而这些实体就被称为微服务。 这些微服务能够独立于其他的系统功能提供服务，用户对它们采取的所有编辑、删除、或在其他地方的使用，都不会影响到本系统的整体性能。</li>
<li>可扩展性。微服务的设计目标是：性能与效率。在现实世界中，解决大型系统的可扩展性问题，是任何微服务生态系统的性能体现。 虽然丰富的技术功能给大量的数据工作带来了多种数据片段，但是如果能恰当地实施、并使用各种应用程序控制器（Application Controllers），则会让微服务架构更具可扩展性。</li>
<li>通过与 DevOps 的集成，实现持续交付。DevOps 的多技术互通与融合，比较适合于微服务架构。在设计微服务架构时，我们需要关注性能和系统效率的提升，这正好契合了 DevOps 的更快交付出方案的理念。 相对于传统的单体式设计，它更适合于部署性、可靠的和可扩展性的方案管理。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/setup/release/version-skew-policy/">https://kubernetes.io/zh/docs/setup/release/version-skew-policy/</a></p>
<h1><a href="#tensorflow" class="header-anchor">#</a><span id="tensorflow">Tensorflow</span></h1>
<h2><a href="#https-blog-csdn-net-zvayivqt0ufji-article-details-78126173" class="header-anchor">#</a><span id="https-blog-csdn-net-zvayivqt0ufji-article-details-78126173"></span></h2>
</p></div><div class="share"><span>Share</span>&nbsp;<span class="soc"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></span><span class="soc"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></span><span class="soc"><a target="_blank" rel="noopener" href="http://twitter.com/home?status=https://blog.kleon.space/work/interview/kubernetes/%20KLEON%20烤面筋 - Kubernetes" class="fa fa-twitter"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/work/interview/dart/" title="烤面筋 - Dart"><i class="fa fa-angle-double-left"></i>&nbsp;Previous post: 烤面筋 - Dart</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/work/interview/python/" title="烤面筋 - Python">Next post: 烤面筋 - Python&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2022&nbsp;<a target="_blank" href="https://blog.kleon.space" rel="noopener noreferrer">Kleon</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>