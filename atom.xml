<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KLEON</title>
  
  
  <link href="https://blog.kleon.space/atom.xml" rel="self"/>
  
  <link href="https://blog.kleon.space/"/>
  <updated>2022-04-22T22:10:44.000Z</updated>
  <id>https://blog.kleon.space/</id>
  
  <author>
    <name>Kleon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Tech - Operating System</title>
    <link href="https://blog.kleon.space/interview/tech/operating_system/"/>
    <id>https://blog.kleon.space/interview/tech/operating_system/</id>
    <published>2022-04-22T22:10:47.000Z</published>
    <updated>2022-04-22T22:10:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>Q &amp; A of Operating System.</p><span id="more"></span><p>Q: The difference between the process, the thread and the coroutine.<br>A:</p><p>Q: Thead Modeling of Linux<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>?<br>A:</p><p>Q: Multithreading, lock?<br>A:</p><p>Q: Describe the process of memory allocation (malloc) <sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup><sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>.<br>A:</p><hr><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://www.jianshu.com/p/6c507b966ad1">【译】Linux 线程模型比较：LinuxThreads 和 NPTL</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://www.linuxidc.com/Linux/2016-01/127559.htm">Linux历史上线程的3种实现模型</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="https://blog.51cto.com/u_10125763/3705688">浅析动态内存分配及Malloc/free的实现</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p><a href="https://www.51cto.com/article/659137.html">你真的理解内存分配吗？</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">&lt;p&gt;Q &amp;amp; A of Operating System.&lt;/p&gt;</summary>
    
    
    
    <category term="interview" scheme="https://blog.kleon.space/categories/interview/"/>
    
    
    <category term="interview" scheme="https://blog.kleon.space/tags/interview/"/>
    
    <category term="tech" scheme="https://blog.kleon.space/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>Tech - Outline</title>
    <link href="https://blog.kleon.space/interview/tech/outline/"/>
    <id>https://blog.kleon.space/interview/tech/outline/</id>
    <published>2022-04-22T22:10:38.000Z</published>
    <updated>2022-04-22T22:10:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>Q &amp; A of tech.</p><span id="more"></span><h1>Programming Languages</h1><ul><li><a href="/interview/tech/golang">Golang</a></li><li>Python</li><li>C++</li></ul><h1>Middleware</h1><ul><li>MessageQueue<ul><li>Kafka</li></ul></li><li>Cache<ul><li>Redis</li></ul></li><li>NoSQL</li><li>Database<ul><li>MySQL</li><li>Postgres</li></ul></li></ul><p><a href="https://github.com/arialdomartini/Back-End-Developer-Interview-Questions">https://github.com/arialdomartini/Back-End-Developer-Interview-Questions</a></p><h1>Design Pattern</h1><h1>Code Design</h1><h1>Web</h1><h1>Code Versioning</h1><h1>Concurrency</h1><h1>Distributed System</h1><h1>Software Lifecycle and Team management</h1><h1>Logic and algorithms</h1><h1>Software architecture</h1><h1>Microservices</h1><h1>Security</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;Q &amp;amp; A of tech.&lt;/p&gt;</summary>
    
    
    
    <category term="interview" scheme="https://blog.kleon.space/categories/interview/"/>
    
    
    <category term="interview" scheme="https://blog.kleon.space/tags/interview/"/>
    
    <category term="tech" scheme="https://blog.kleon.space/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>Tech - Golang</title>
    <link href="https://blog.kleon.space/interview/tech/golang/"/>
    <id>https://blog.kleon.space/interview/tech/golang/</id>
    <published>2022-04-22T20:18:13.000Z</published>
    <updated>2022-04-22T20:18:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>Interview questions of golang.</p><span id="more"></span><h1>Language basics</h1><p>Q: What is Golang?<br>A: Go is a high level, general-purpose programming language that is very strongly and <strong>statically typed</strong> by providing support for <strong>garbage collection</strong> and <strong>concurrent programming</strong>.<br>In Go, the programs are built by using packages that help in managing the dependencies efficiently. It also uses a <strong>compile-link model</strong> for generating executable binaries from the source code. Go is a simple language with elegant and easy to understand syntax structures. It has a built-in collection of powerful standard libraries that helps developers in solving problems without the need for third party packages. Go has <strong>first-class support for Concurrency</strong> having the ability to use multi-core processor architectures to the advantage of the developer and utilize memory efficiently. This helps the applications scale in a simpler way.</p><p>Q: Why should one use Golang? What are the advantages of Golang over other languages?<br>A:</p><ul><li><strong>Simple and Understandable</strong>: Go is very simple to learn and understand. There are no unnecessary features included. Every single line of the Go code is very easily readable and thereby easily understandable irrespective of the size of the codebase. Go was developed by keeping simplicity, maintainability and readability in mind.</li><li><strong>Standard Powerful Library</strong>: Go supports all standard libraries and packages that help in writing code easily and efficiently.</li><li><strong>Support for concurrency</strong>: Go provides very good support for concurrency using Go Routines or channels. They take advantage of efficient memory management strategies and multi-core processor architecture for implementing concurrency.</li><li><strong>Static Type Checking</strong>: Go is a very strong and statically typed programming language. Statically typed means every variable has types assigned to it. The data type cannot be changed once created and strongly typed means that there are rules and restrictions while performing type conversion. This ensures that the code is type-safe and all type conversions are handled efficiently. This is done for reducing the chances of errors at runtime.</li><li><strong>Easy to install Binaries</strong>: Go provides support for generating binaries for the applications with all required dependencies. These binaries help to install tools or applications written in Go very easily without the need for a Go compiler or package managers or runtimes.</li><li><strong>Good Testing Support</strong>: Go has good support for writing unit test cases along with our code. There are libraries that support checking code coverage and generating code documentation.</li></ul><p>Q: What are the cons/defects/disadvantages of Golang?<br>A:</p><ul><li>Lack of Function Overloading and Default Values for Arguments. A lots of code.</li><li>Lack of Generics. A lots of duplicated code.</li><li>Error Handling. Lack of exception.</li><li>Absence of manual memory management. GC is not suit for some time-sensitive application.</li><li>Runtime safety is not that good. Golang only provides compiled-time safety rather than runtime-safety.</li></ul><p>Q: What are Golang packages?<br>A: Go Packages (in short pkg) are nothing but directories in the Go workspace that contains Go source files or other Go packages themselves. Every single piece of code starting from variables to functions are written in the source files are in turn stored in a linked package. Every source file should belong to a package.<br>From the image below, we can see that a Go Package is represented as a box where we can store multiple Go source files of the .go extension. We can also store Go packages as well within a package.</p><p>Q: What are Golang pointers?<br>A: Go Pointers are those variables that hold the address of any variables. Due to this, they are called special variables. Pointers support two operators:</p><ul><li><code>*</code> operator: This operator is called a dereferencing operator and is used for accessing the value in the address stored by the pointer.</li><li><code>&amp;</code> operator: This operator is called the address operator and is used for returning the address of the variable stored in the pointer.<br>Pointers are used for the following purposes:</li><li>Allowing function to directly mutate value passed to it. That is achieving pass by reference functionality.</li><li>For increasing the performance in the edge cases in the presence of a large data structure. Using pointers help to copy large data efficiently.</li><li>Helps in signifying the lack of values. For instance, while unmarshalling JSON data into a struct, it is useful to know if the key is present or absent then the key is present with 0 value.</li></ul><p>Q: What do you understand by Golang string literals?<br>A: String literals are those variables storing string constants that can be a single character or that can be obtained as a result of the concatenation of a sequence of characters. Go provides two types of string literals. They are:</p><ul><li>Raw string literals: Here, the values are uninterrupted character sequences between backquotes.</li><li>Interpreted string literals: Here, the character sequences are enclosed in double quotes. The value may or may not have new lines. For example:</li></ul><p>Q: What do you understand by the scope of variables in Go?<br>A: The variable scope is defined as the part of the program where the variable can be accessed. Every variable is statically scoped (meaning a variable scope can be identified at compile time) in Go which means that the scope is declared at the time of compilation itself. There are two scopes in Go, they are:</p><ul><li>Local variables - These are declared inside a function or a block and is accessible only within these entities.</li><li>Global variables - These are declared outside function or block and is accessible by the whole source file.</li></ul><p>Q: What do you understand by goroutine in Golang?<br>A goroutine is nothing but a function in Golang that usually runs concurrently or parallelly with other functions. They can be imagined as a lightweight thread that has independent execution and can run concurrently with other routines. Goroutines are entirely managed by Go Runtime. Goroutines help Golang achieve concurrency.</p><ul><li>In Golang, the main function of the main package is considered the main goroutine. It is the starting point of all other goroutines. These goroutines have the power to start their goroutines. Once the execution of the main goroutine is complete, it means that the program has been completed.</li><li>We can start a goroutine by just specifying the go keyword before the method call. The method will now be called and run as a goroutine.</li></ul><p>Q: Is it possible to declare variables of different types in a single line of code in Golang?<br>A:</p><pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">var a,b,c= 9, 7.1, "interviewbit"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Q: What is “slice” in Go?<br>A: Slice in Go is a lightweight data structure of variable length sequence for storing homogeneous data. It is more convenient, powerful and flexible than an array in Go. Slice has 3 components:</p><ul><li>Pointer: This is used for pointing to the first element of the array accessible via slice. The element doesn’t need to be the first element of the array.</li><li>Length: This is used for representing the total elements count present in the slice.</li><li>Capacity: This represents the capacity up to which the slice can expand.</li></ul><p>Q: What are Go Interfaces?<br>A: Go interfaces are those that have a defined set of method signatures. It is a custom type who can take values that has these methods implementation.  The interfaces are abstract which is why we cannot create its instance. But we can create a variable of type interface and that variable can then be assigned to a concrete value that has methods required by the interface. Due to these reasons, an interface can act as two things:</p><ul><li>Collection of method signatures</li><li>Custom types</li></ul><p>Q: Why is Golang fast compared to other languages?<br>A: Golang is faster than other programming languages because of its simple and efficient memory management and concurrency model. The compilation process to machine code is very fast and efficient. Additionally, the dependencies are linked to a single binary file thereby putting off dependencies on servers.</p><p>Q: What are Go channels and how are channels used in Golang?<br>A: Go channel is a medium using which goroutines communicate data values with each other. It is a technique that allows data transfer to other goroutines. A channel can transfer data of the same type. The data transfer in the channel is bidirectional meaning the goroutines can use the same channel for sending or receiving the data.</p><p>Q: What do you understand by Type Assertion in Go?<br>A: The type assertion takes the interface value and retrieves the value of the specified explicit data type. The syntax of Type Assertion is:</p><pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">t := i.(T)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Here, the statement asserts that the interface value i has the concrete type T and assigns the value of type T to the variable t. In case i does not have concrete type T, then the statement will result in panic.<br>For testing, if an interface has the concrete type, we can do it by making use of two values returned by type assertion. One value is the underlying value and the other is a bool value that tells if the assertion is completed or not. The syntax would be:</p><pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">t, isSuccess := i.(T)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Here, if the interface value i have T, then the underlying value will be assigned to t and the value of isSuccess becomes true. Else, the isSuccess statement would be false and the value of t would have the zero value corresponding to type T. This ensures there is no panic if the assertion fails.</p><p>Q: How will you check the type of a variable at runtime in Go?<br>A: In Go, we can use a special type of switch for checking the variable type at runtime. This switch statement is called a “type switch”.</p><p>Consider the following piece of code where we are checking for the type of variable v and performing some set of operations.</p><pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">switch v := param.(type) &#123; default:    fmt.Printf("Unexpected type %T", v)case uint64:    fmt.Println("Integer type")case string:    fmt.Println("String type")&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>In the above code, we are checking for the type of variable v, if the type of variable is uint64, then the code prints “Integer type”. If the type of variable is a string, the code prints “String type”. If the type doesn’t match, the default block is executed and it runs the statements in the default block.</p><h1>Code Reading</h1><p>Q: What do you understand by each of the functions demo_func() as shown in the below code?</p><pre class="line-numbers language-highlight plaintext"><code class="language-highlight plaintext">//DemoStruct definitiontype DemoStruct struct &#123;    Val int&#125;//A.func demo_func() DemoStruct &#123;    return DemoStruct&#123;Val: 1&#125;&#125;//B.func demo_func() *DemoStruct &#123;    return &DemoStruct&#123;&#125;&#125;//C.func demo_func(s *DemoStruct) &#123;    s.Val = 1&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>A:<br>A. Since the function has a return type of the struct, the function returns a copy of the struct by setting the value as 1.<br>B. Since the function returns *DemoStruct, which is a pointer to the struct, it returns a pointer to the struct value created within the function.<br>C. Since the function expects the existing struct object as a parameter and in the function, we are setting the value of its attribute, at the end of execution the value of Val variable of the struct object is set to 1.</p><h1>Dive into the deep</h1><p>Q: Why is Golang so fast?<br>A:</p><ul><li>Because Go is statically typed and compiled to <strong>machine code</strong>, it will naturally outperform languages that are interpreted or have virtual runtimes.</li><li>Efficient memory management<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>. The golang runtime manages memories in a hierarchical structure. It allocates a large piece of memory at a time to avoid the overhead and the fragmentation of memory allocation. The core idea of TCMalloc (thread cache malloc) is to divide the memory into multiple levels to reduce the granularity of the lock. Inside TCMalloc Memory management is divided into two parts: <strong>thread memory</strong> and <strong>page heap</strong>.<ul><li><strong>thread memory</strong> Each memory page divided into — Free List of multiple fixed allocatable size-classes, which helps in reducing fragmentation. So each thread will have a cache for small objects without locks, which makes it very efficient to allocate small objects (&lt;=32k) under parallel programs.</li><li><strong>page heap</strong> The heap managed by TCMalloc consists of a collection of pages, where a set of consecutive pages can be represented by span. When allocated Object is larger than 32K, Pages Heap is used for allocation.<br>When there is not enough memory to allocate small objects, go to page heap for memory. If there is not enough, page heap will ask more memory from the Operating System.<br>As such an allocation model maintains a user-spaced memory pool, it greatly improves the efficiency of memory allocation and release.</li></ul></li><li>Efficient concurrency model<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup><sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>. The Golang runtime manages all goroutines, which avoids the context switch overhead than the thread or the process.<ul><li><strong>Concurrency</strong>. Go implements a variant of the <strong>CSP model</strong>, in which channels are the preferred method for two Goroutines (a user space thread-like, with a few kilobytes in its stack) to share data. This approach is actually the opposite of that frequently used with other languages like Ruby or Python—a global shared data structure, with synchronization primitives for exclusive access (semaphores, locks, queues, etc.). Keeping these global data structures consistent across all units involves a lot of overhead.<br>By following the CSP model, Go makes it possible to have concurrent constructions as primitives of the language. By default, Go knows how to deal with multiple tasks at once, and knows how to pass data between them. This, of course, translates to low latency with intercommunicating Goroutines. In Go, in the context of multithreading, you don’t write data to common storage. You create Goroutines to share data via channels. And because there is no need for exclusive access to global data structures, you gain speed.<br>It is important to note that you can also use mutex (or lock) mechanisms in Go, but that isn’t the default approach for a concurrent program.</li><li><strong>Threading model</strong>. Go operates under an <strong>M:N threading model</strong>. In an M:N model, there are units of work under the user space (the Goroutines or G in the scheduler lexicon) which are scheduled to be run by the language runtime on OS threads (or M in the scheduler lexicon) on machine processors (or P in the scheduler lexicon). A Goroutine is defined as a lightweight thread managed by the Go runtime. Different Goroutines (G) can be executed on different OS threads (M), but at any given time, only one OS thread can be run on a CPU §. In the user space, you achieve concurrency as the Goroutines work cooperatively. In the presence of a blocking operation (network, I/O or system call), another Goroutine can be assigned to the OS thread.<br>Once the blocking call ends, the runtime will try to reassign the previous Goroutine to an available OS thread. It’s possible to achieve parallelism here, because once the Goroutines are assigned to an OS thread, the OS can decide to distribute its threads’ execution through its multiple cores.<br>By having multiple Goroutines assigned to OS threads—thus being run cooperatively (or in parallel if two OS threads are run simultaneously on different cores)—you get an efficient use of your machine’s CPUs, because all cores will be available for running your program’s functions.</li><li><strong>Goroutines</strong>. Goroutines live within the user thread space. In comparison to OS threads, their operations cost less: The overhead for assigning them, suspending them, and resuming them is lower than the overhead required by OS threads. Goroutines and channels are two of the most important primitives Go offers for concurrency. One important aspect of Goroutines is that expressing them in terms of code is fairly easy. You simply put the keyword go before the function you want to schedule to be run outside of the main thread.<br>But how do Goroutines help make Go more performant? The minimal stack required for a Goroutine to exist is 2 KB. Goroutines can increase their stack on runtime if they see the need for more space, but overall, they are memory-friendly. This means their management overhead is minimal. In other words, you can have more working units being processed with a decent quantity of memory, and that translates into efficiency and speed.</li><li><strong>Task Scheduling</strong>. Go comes with its own runtime scheduler. The language does not rely on the native OS thread/process scheduler, but it cooperates with it. Because the scheduler is an independent component, it has the flexibility for implementing optimizations. All these optimizations aim for one thing: to avoid too much preemption of the OS Goroutines, which would result in suspending and resuming the functions’ execution, an expensive operation.<br>Next, we are going to highlight some specific optimizations done by the scheduler in order to avoid preemption.</li><li><strong>Work Stealing</strong>. Generally, there are two ways to distribute workloads across CPUs. The first one is work sharing, in which busy processors send threads to other, less busy processors with the hope they will be taken and executed. The second method is work stealing, in which an idle processor is constantly looking to steal other processor threads. Go uses work stealing.<br>How does the work stealing approach help make Go faster? The migration of threads between processors is expensive, as it involves context switch operations. Under the stealing paradigm, this phenomenon occurs less frequently, resulting in less overhead.</li><li><strong>Spinning Threads</strong>. The scheduler also implements a particular strategy called spinning threads, which tries to fairly distribute as many OS threads across processors as possible. Go runtime not only reduces the frequency of thread migrations between processors, it is also capable of moving an OS thread with no work assigned to another processor. This can balance CPU usage and power.<br>When you have all CPUs working with fairly distributed workloads, you are avoiding resource underutilization, which, again, translates to resource efficiency and speed.</li><li><strong>System Calls</strong>. What strategy does the Go scheduler follow for handling system calls? It turns out that it also helps reduce overhead overall. Let’s see how.<br>For system calls expected to be slow, the scheduler applies a pessimistic approach. It makes the OS thread release the processor in which it’s been running, just before the system call. Then, after the system call ends, the scheduler tries to reacquire the processor if it’s available. Otherwise, it’s enqueued by the scheduler until it finds a new available processor. The inconvenience of this approach is the overhead required for dropping and reacquiring a processor.<br>However, the scheduler uses a second approach for system calls that are known to be fast—an optimistic approach. With this approach, the OS thread running the Goroutine with the system call does not release the processor, but it flags it.<br>Then, after a few microseconds (20 to be precise), another independent special Goroutine (the sysmon Goroutine) checks for all flagged processors. If they are still running the heavy Goroutine that involves the system call, the scheduler takes their processors away, so they’re suspended. If the stolen processor is still available once the system call ends, the Goroutine can continue executing. Otherwise, it will need to be scheduled for execution again (until a processor becomes available).</li></ul></li></ul><p>Q: Describe Golang’s CSP Model?<br>A:</p><p>Q: Describe the process of the garbage collection of Golang.<br>A:</p><p>Q: What’s the data structure of <code>map</code>?<br>A: A linked hash table.</p><p>Q: How is <code>channel</code> implemented <sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>?<br>A:</p><hr><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://medium.com/@ankur_anand/a-visual-guide-to-golang-memory-allocator-from-ground-up-e132258453ed">A visual guide to Go Memory Allocator from scratch (Golang)</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://zhuanlan.zhihu.com/p/76802887">详解Go语言的内存模型及堆的分配管理</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="https://granulate.io/deep-dive-into-golang-performance/">Deep Dive into Golang Performance</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p><a href="https://huweicai.com/process-thread-goroutine/">进程线程协程的本质区别</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p></li><li id="fn5" class="footnote-item"><p><a href="https://i6448038.github.io/2019/04/11/go-channel/">图解Go的channel底层实现</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">&lt;p&gt;Interview questions of golang.&lt;/p&gt;</summary>
    
    
    
    <category term="interview" scheme="https://blog.kleon.space/categories/interview/"/>
    
    
    <category term="interview" scheme="https://blog.kleon.space/tags/interview/"/>
    
    <category term="tech" scheme="https://blog.kleon.space/tags/tech/"/>
    
    <category term="golang" scheme="https://blog.kleon.space/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm Outline</title>
    <link href="https://blog.kleon.space/interview/algo/outline/"/>
    <id>https://blog.kleon.space/interview/algo/outline/</id>
    <published>2022-04-22T19:55:46.000Z</published>
    <updated>2022-04-22T19:55:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>Typical algorithm problem.</p><span id="more"></span><p><a href="https://github.com/shomali11/go-interview">https://github.com/shomali11/go-interview</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Typical algorithm problem.&lt;/p&gt;</summary>
    
    
    
    <category term="interview" scheme="https://blog.kleon.space/categories/interview/"/>
    
    
    <category term="interview" scheme="https://blog.kleon.space/tags/interview/"/>
    
    <category term="algorithm" scheme="https://blog.kleon.space/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>System Design Outline</title>
    <link href="https://blog.kleon.space/interview/system/outline/"/>
    <id>https://blog.kleon.space/interview/system/outline/</id>
    <published>2022-04-22T19:55:46.000Z</published>
    <updated>2022-04-22T19:55:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>Q &amp; A of system design.</p><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;p&gt;Q &amp;amp; A of system design.&lt;/p&gt;</summary>
    
    
    
    <category term="interview" scheme="https://blog.kleon.space/categories/interview/"/>
    
    
    <category term="interview" scheme="https://blog.kleon.space/tags/interview/"/>
    
    <category term="system design" scheme="https://blog.kleon.space/tags/system-design/"/>
    
  </entry>
  
  <entry>
    <title>Tech - Database</title>
    <link href="https://blog.kleon.space/interview/tech/database/"/>
    <id>https://blog.kleon.space/interview/tech/database/</id>
    <published>2022-04-22T19:55:46.000Z</published>
    <updated>2022-04-22T19:55:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>Q &amp; A of databases.</p><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;p&gt;Q &amp;amp; A of databases.&lt;/p&gt;</summary>
    
    
    
    <category term="interview" scheme="https://blog.kleon.space/categories/interview/"/>
    
    
    <category term="interview" scheme="https://blog.kleon.space/tags/interview/"/>
    
    <category term="tech" scheme="https://blog.kleon.space/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>Resume</title>
    <link href="https://blog.kleon.space/interview/resume/"/>
    <id>https://blog.kleon.space/interview/resume/</id>
    <published>2022-04-20T10:41:40.000Z</published>
    <updated>2022-04-20T10:41:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>Resumes.</p><span id="more"></span><h1>Backend Developer</h1><h2 id="Education"><a class="header-anchor" href="#Education">¶</a>Education</h2><p>2012-2016 Fudan University, China. Bachelor’s degree in Microelectronics.<br>2016-2018 Fudan University, China. Master’s degree in Integrated Circuit Design.</p><h2 id="Experience"><a class="header-anchor" href="#Experience">¶</a>Experience</h2><p><strong>Alibaba Group</strong>, China 2018.7-present</p><p><strong>Senior Software Engineer</strong>, Platform of AI (August 2020 - present)</p><ul><li>Backend architecture and developer for AI application and SaaS, including recommendation engine, marketing platform with SMS ability. Integrated into Ali Cloud’s finance system.</li></ul><p><strong>Software Engineer</strong>, Platform of AI (July 2018 - July 2020)</p><ul><li>Participated in the development of hardware accelerator of deep learning model. Designed and developed the hardware logic in Verilog, the universal runtime adapting different hardware arch and model in C++, integrated into Tensorflow and more.</li><li>Model optimization on Intel CPU.</li></ul><h2 id="Skills"><a class="header-anchor" href="#Skills">¶</a>Skills</h2><ul><li>Programming language of Golang, Python, C++.</li><li>Knowledge of deep learning, including recommendation engine.</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Resumes.&lt;/p&gt;</summary>
    
    
    
    <category term="interview" scheme="https://blog.kleon.space/categories/interview/"/>
    
    
    <category term="interview" scheme="https://blog.kleon.space/tags/interview/"/>
    
    <category term="resume" scheme="https://blog.kleon.space/tags/resume/"/>
    
  </entry>
  
  <entry>
    <title>Knowledge from internet</title>
    <link href="https://blog.kleon.space/interview/basics/"/>
    <id>https://blog.kleon.space/interview/basics/</id>
    <published>2022-04-19T09:39:17.000Z</published>
    <updated>2022-04-19T09:39:21.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/CyC2018/CS-Notes">https://github.com/CyC2018/CS-Notes</a></p><p><a href="https://github.com/arialdomartini/Back-End-Developer-Interview-Questions">https://github.com/arialdomartini/Back-End-Developer-Interview-Questions</a></p><p><a href="https://github.com/jwasham/coding-interview-university">https://github.com/jwasham/coding-interview-university</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/CyC2018/CS-Notes&quot;&gt;https://github.com/CyC2018/CS-Notes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/arialdomartini/B</summary>
      
    
    
    
    <category term="interview" scheme="https://blog.kleon.space/categories/interview/"/>
    
    
    <category term="interview" scheme="https://blog.kleon.space/tags/interview/"/>
    
    <category term="basics" scheme="https://blog.kleon.space/tags/basics/"/>
    
  </entry>
  
  <entry>
    <title>Interview Experience</title>
    <link href="https://blog.kleon.space/interview/experience/"/>
    <id>https://blog.kleon.space/interview/experience/</id>
    <published>2022-04-19T09:39:17.000Z</published>
    <updated>2022-04-19T09:39:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>From internet.</p><span id="more"></span><ul><li>HR</li><li>Tech-1</li><li>Tech-2</li><li>Manager</li></ul><p>[校招] Shopee 新加坡 后端面经 已意向 <a href="https://www.nowcoder.com/discuss/764317?type=all&amp;order=recall&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_all_nctrack&amp;gio_id=3672D0C1D489548E5D07D61ACA2D0F92-1650352686302">link</a></p><p>[社招][junior] <a href="http://pony.ai">pony.ai</a>,币安,字节新加坡,shopee新加坡 面经 <a href="https://www.nowcoder.com/discuss/776016?type=all&amp;order=recall&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_all_nctrack&amp;gio_id=3672D0C1D489548E5D07D61ACA2D0F92-1650352686302">link</a></p><p>[校招][产品] 已***掉@1面/2面 Shopee产品经理新加坡面经 <a href="https://www.nowcoder.com/discuss/225066?type=all&amp;order=recall&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_all_nctrack&amp;gio_id=3672D0C1D489548E5D07D61ACA2D0F92-1650353674798">link</a></p><p>[社招] 新加坡虾皮 Shopee 后端开发 面经 <a href="https://www.nowcoder.com/discuss/828077?type=all&amp;order=recall&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_all_nctrack&amp;gio_id=3672D0C1D489548E5D07D61ACA2D0F92-1650353674798">link</a></p><p>[社招] shopee不知道是面经还是凉经 <a href="https://www.nowcoder.com/discuss/863844?type=post&amp;order=recall&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_post_nctrack&amp;gio_id=3672D0C1D489548E5D07D61ACA2D0F92-1650353866968">link</a></p><p>[社招] 新加坡虾皮backend ng全程面经 <a href="https://www.1point3acres.com/bbs/thread-746745-1-1.html">link</a></p><p>[社招] Shopee新加坡面经 <a href="https://www.1point3acres.com/bbs/thread-591386-1-1.html">link</a></p><p>[社招] Shopee面经 <a href="https://www.nowcoder.com/discuss/717400?type=post&amp;order=recall&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_post_nctrack&amp;gio_id=3672D0C1D489548E5D07D61ACA2D0F92-1650354638798">link</a></p><p>[社招] Shopee backend 新加坡一面 <a href="https://www.1point3acres.com/bbs/thread-722089-1-1.html">link</a></p><p>[社招] 狗家新加坡虚拟表演面经 <a href="https://www.1point3acres.com/bbs/thread-830145-1-1.html">link</a></p><p>[社招] 新加坡shopee backend oa <a href="https://www.1point3acres.com/bbs/thread-724075-1-1.html">link</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;From internet.&lt;/p&gt;</summary>
    
    
    
    <category term="interview" scheme="https://blog.kleon.space/categories/interview/"/>
    
    
    <category term="interview" scheme="https://blog.kleon.space/tags/interview/"/>
    
    <category term="exp" scheme="https://blog.kleon.space/tags/exp/"/>
    
  </entry>
  
  <entry>
    <title>Intro</title>
    <link href="https://blog.kleon.space/interview/intro/"/>
    <id>https://blog.kleon.space/interview/intro/</id>
    <published>2022-04-19T09:39:17.000Z</published>
    <updated>2022-04-19T09:39:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>Intros and common questions in non-technical interview.</p><span id="more"></span><p>Q: Tell me about yourself.<br>A: OK. I’m Li Ding. I get both the bachelor’s degree and the master’s degree from Fudan University in 2016 and 2018 separately. And now I’ve worked in the PAI department in Alibaba Group for almost 4 years. The PAI is the short of Platform of Artificial Intelligence.<br>Duration these time, there are two major stages which could be separated roughly according my promotion. As written in the resume, in the software engineer stage, from 2018 to 2020, I worked mainly on two projects. The first is the hardware accelerator of the deep learning model. We accelerated several models mainly on CV, TTS, NLP and recommendation based on Tensorflow model. I wrote the logic of hardware in Verilog and the code of runtime capable of data manipulation in C++. And we use Tensorflow as a complement handling the operations which our hardware accelerators not supported. The second is the optimization of the inference performance. We’ve tried different ways for both GPU and CPU, including TensorRT, TVM and so on. We packed different methods into a tool called Blade, which is now been used in company.<br>In the second stage as a senior software engineer, I worked mainly on the application of AI, which consists of tuning model, developing SDK and service’s backend, commercialize product by integrating with Ali Cloud’s infrastructures. There are three projects I worked on. The first is the light-weighted recommendation system for medium and small companies. (why?) The second is the marketing platform using AI to predict the probability of user’s certain behavior and helping to increase the rate of click, recall and conversion. (more detail?) The third is the video processing platform with the ability of AI enhancement. (how do you deal with the thousands of jobs concurrently)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Intros and common questions in non-technical interview.&lt;/p&gt;</summary>
    
    
    
    <category term="interview" scheme="https://blog.kleon.space/categories/interview/"/>
    
    
    <category term="interview" scheme="https://blog.kleon.space/tags/interview/"/>
    
    <category term="intro" scheme="https://blog.kleon.space/tags/intro/"/>
    
  </entry>
  
  <entry>
    <title>Jobs - Software Development Engineer</title>
    <link href="https://blog.kleon.space/interview/jobs/"/>
    <id>https://blog.kleon.space/interview/jobs/</id>
    <published>2022-04-19T09:39:17.000Z</published>
    <updated>2022-04-19T09:39:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>All about jobs.</p><span id="more"></span><h1>Dimensions</h1><ul><li>Company</li><li>Focus of tech</li></ul><h1>Company</h1><p>Basically, there are 4 types of companies:</p><ul><li>Local company, have greater chance issue worker visa, higher payment. Shopee, Zalora, Carousell, Grab, Lazada, SeaMoney.</li><li>Local institution, have greater chance issue worker visa, usually in university or government institutions. ntu, nus.</li><li>Chinese company, may experience unknown risks, may run out of worker visa. TikTok, ByteDance, XiaoMi, Alibaba, Tencent, SHEIN.</li><li>International company. Google, Facebook, Amazon, Apple, Microsoft, IBM.</li></ul><p><a href="https://interactive.zaobao.com/unicorn-companies/">https://interactive.zaobao.com/unicorn-companies/</a></p><ul><li>unicorns, trax(cv), advanced intelligence(fin-tech), carro(car-trade), carousell(shop), moglix(b2b commence), nium(fin-tech), matrix port(crypto), patsnap(ai), acronis(web-security), ninjavan(transport), hyalroute(telecom), property guru(real-estate), just go(shared workspace)</li></ul><h1>Focus of tech</h1><ul><li>Backend developer in confluent golang/python/c++. Interested in rust/java/dart.</li><li>Machine learning platform engineer with the knowledge and experience in tensorflow, cuda or performance optimization.</li><li>Full stack engineer familiar with backend, docker, devops, k8s, vue.js, flutter.</li><li>Software developer experienced in recommendation engine, computer vision, video enhancement and related AI applications.</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;All about jobs.&lt;/p&gt;</summary>
    
    
    
    <category term="interview" scheme="https://blog.kleon.space/categories/interview/"/>
    
    
    <category term="interview" scheme="https://blog.kleon.space/tags/interview/"/>
    
    <category term="job" scheme="https://blog.kleon.space/tags/job/"/>
    
    <category term="sde" scheme="https://blog.kleon.space/tags/sde/"/>
    
  </entry>
  
  <entry>
    <title>Interview</title>
    <link href="https://blog.kleon.space/interview/overview/"/>
    <id>https://blog.kleon.space/interview/overview/</id>
    <published>2022-04-19T09:38:53.000Z</published>
    <updated>2022-04-19T09:38:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>The process of interview.</p><span id="more"></span><ul><li>Job opportunities.</li><li>Resumes.</li><li>Algorithms.</li><li>System design.</li><li>Professional knowledge.</li><li>Non-technical interview.</li><li>Passport and visa.</li></ul><h1>Media</h1><p>码农下南洋 - 华尔街见闻<br><a href="https://wallstreetcn.com/articles/3654009">https://wallstreetcn.com/articles/3654009</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;The process of interview.&lt;/p&gt;</summary>
    
    
    
    <category term="interview" scheme="https://blog.kleon.space/categories/interview/"/>
    
    
    <category term="interview" scheme="https://blog.kleon.space/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>游戏设计 1 - 玩法类型</title>
    <link href="https://blog.kleon.space/game-design/1-type/"/>
    <id>https://blog.kleon.space/game-design/1-type/</id>
    <published>2021-10-26T14:00:01.000Z</published>
    <updated>2021-10-26T20:00:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>制作游戏的第一步就是设计游戏玩法，从前人的游戏中，有不少成熟的模式值得借鉴。</p><span id="more"></span><p>参考<a href="https://en.wikipedia.org/wiki/List_of_video_game_genres">维基</a>的定义。</p><h1>动作</h1><h2 id="平台"><a class="header-anchor" href="#平台">¶</a>平台</h2><p>平台游戏（或平台游戏）的游戏玩法主要围绕跳跃和攀爬来导航玩家的环境。他们可能有敌人或障碍需要避开和战斗，或者可能只是纯粹的跳跃拼图。通常，平台游戏中的可玩角色能够跳跃数倍于自身高度的高度，玩家可以控制他们在半空中的移动以及跳跃的高度和距离。设置往往在垂直方向上被夸大了，玩家可以跳上或掉下很多不平坦的地形。</p><h2 id="射击"><a class="header-anchor" href="#射击">¶</a>射击</h2><p>在射击游戏（或简称为射击游戏）中，玩家使用远程武器来参与远距离发生的动作。大多数射击游戏都涉及暴力游戏；致命武器用于伤害对手。</p><h3 id="第一人称射击"><a class="header-anchor" href="#第一人称射击">¶</a>第一人称射击</h3><h3 id="第三人称射击"><a class="header-anchor" href="#第三人称射击">¶</a>第三人称射击</h3><h2 id="格斗"><a class="header-anchor" href="#格斗">¶</a>格斗</h2><p>格斗游戏以近距离格斗为核心，通常是一对一格斗或与少数同样强大的对手进行格斗，经常涉及暴力和夸张的徒手攻击。大多数格斗游戏都具有大量可玩角色和竞争性多人游戏模式。</p><h2 id="敌潮"><a class="header-anchor" href="#敌潮">¶</a>敌潮</h2><p>Beat 'em ups（或brawler）是与格斗游戏相关但又截然不同的类型。虽然它们都涉及近距离战斗，但击败他们会让玩家对抗一大波对手而不是少数对手。</p><h2 id="潜入"><a class="header-anchor" href="#潜入">¶</a>潜入</h2><p>这些游戏倾向于强调偷偷摸摸和避免直接冲突的敌人注意到。</p><h2 id="生存"><a class="header-anchor" href="#生存">¶</a>生存</h2><p>生存游戏让玩家在敌对的开放世界环境中以最少的资源开始，并要求他们收集资源、工艺工具、武器和住所，以便尽可能长时间地生存。许多设置在程序生成的环境中，并且是开放式的，没有设定目标。它们可能与生存恐怖类型重叠，其中玩家必须在超自然环境中生存，例如僵尸启示录。</p><h2 id="节奏"><a class="header-anchor" href="#节奏">¶</a>节奏</h2><p>节奏游戏或节奏动作是一种以音乐为主题的动作视频游戏 ，它挑战玩家的节奏感。包括舞蹈游戏和基于音乐的游戏。此类游戏要求玩家在精确的时间按下按钮：屏幕显示玩家需要按下哪个按钮，游戏会根据准确度和与节拍的同步来奖励积分。</p><h2 id="大逃杀"><a class="header-anchor" href="#大逃杀">¶</a>大逃杀</h2><p>一个大逃杀游戏是一个流派，与最后的生还游戏和生存游戏的共混物的生存，探索和清除构件。大逃杀游戏挑战大量玩家，从最少的装备开始，寻找武器和盔甲并消灭其他对手，同时试图留在随着时间推移而缩小的安全可玩区域，获胜者是最后的竞争者游戏。</p><h1>动作冒险</h1><p>虽然动作冒险游戏可以分为动作游戏或冒险游戏，但它们结合了这两种组成类型的元素，通常具有必须使用工具或物品作为杠杆来克服的长期障碍（之前收集的），以及许多较小的障碍几乎一直在路上，需要动作游戏的元素来克服。动作冒险游戏往往侧重于探索，通常涉及物品收集、简单的解谜和战斗。“动作冒险”已成为一种标签，有时会附加到与另一种众所周知的类型不完全匹配的游戏上。因为它们在电子游戏机上很流行，而且没有典型的冒险游戏，动作冒险游戏通常被现代游戏玩家称为“冒险游戏”。</p><h2 id="生存恐怖"><a class="header-anchor" href="#生存恐怖">¶</a>生存恐怖</h2><p>生存恐怖游戏专注于恐惧，并试图通过传统的恐怖小说元素，如气氛、死亡、亡灵、鲜血和血腥来吓唬玩家。许多此类游戏中的一个关键游戏元素是弹药数量或易碎近战武器数量少。著名的例子包括寂静岭和生化危机。</p><h2 id="银河恶魔城"><a class="header-anchor" href="#银河恶魔城">¶</a>银河恶魔城</h2><p>Metroidvania游戏是平台游戏的一个子类型，以其两个著名的特许经营权命名，即银河战士和恶魔城。它们具有玩家可以探索的大型互连世界地图，但进入世界部分地区受到门或其他障碍的限制，只有在玩家获得游戏中的特殊工具、武器或能力后才能打开这些障碍。获得这些改进还有助于玩家击败更难对付的敌人并定位捷径和秘密区域，并且通常包括在地图上追溯自己的脚步。Metroidvanias 通常不包含任何线性游戏，并且经常涉及很多回溯 - 特别是在获得新的电源或工具之后。</p><h1>冒险</h1><p>冒险游戏是最早创建的一些游戏，从1970 年代的文字冒险Colossal Cave Adventure开始。该游戏最初的名称简单地称为“冒险”，并且是该类型的同名游戏。随着时间的流逝，图形已被引入该类型，并且界面也在不断发展。</p><p>与冒险电影不同，冒险游戏不是由故事或内容来定义的。相反，冒险描述了一种没有反射性挑战或行动的游戏方式。它们通常要求玩家通过与人或环境互动来解决各种难题，最常见的是以非对抗的方式。它被认为是一种“纯粹的”类型，并且倾向于排除任何包含迷你游戏以外的动作元素的内容。</p><p>由于它们以基于动作的挑战或时间限制的形式对玩家施加的压力很小，因此冒险游戏具有吸引通常不玩电子游戏的人的独特能力。</p><h2 id="文字冒险"><a class="header-anchor" href="#文字冒险">¶</a>文字冒险</h2><p>最早的冒险游戏是文字冒险，也称为互动小说。1970 年代末和 1980 年代初流行的Zork系列等游戏允许玩家使用键盘输入诸如“拿绳子”或“向西”之类的命令，而计算机则描述正在发生的事情。大量的编程用于解析玩家的文本输入。</p><h2 id="图形冒险"><a class="header-anchor" href="#图形冒险">¶</a>图形冒险</h2><p>随着图形变得越来越普遍，冒险游戏应运而生。冒险游戏开始补充，后来用视觉效果（例如，当前位置的图片）替换文字描述。早期的图形冒险游戏使用文本解析器来输入命令。越来越多地使用鼠标导致了冒险游戏的“点击式”类型，玩家不再需要输入命令。例如，玩家可以点击一个手形图标，然后点击一根绳子来拿起绳子。</p><h2 id="视觉小说（很多是GAL）"><a class="header-anchor" href="#视觉小说（很多是GAL）">¶</a>视觉小说（很多是GAL）</h2><p>甲视觉小说（ビジュアルノベル，bijuaru noberu）是一种游戏，大多静态图形，通常与动画式的技术。顾名思义，它们类似于混合媒体小说或生动活泼的舞台剧。许多视觉小说跟踪玩家为了推进情节而必须建立的统计数据，并允许各种结局，允许对玩家的行为做出比典型的线性冒险情节更动态的反应。许多视觉小说都是约会模拟游戏，包括美少女游戏。视觉小说在日本尤为盛行，占 PC 游戏发行量的近 70%。[36]它们很少为视频游戏机生产，但更受欢迎的游戏有时会移植到Dreamcast或PlayStation 2 等系统。然而，在任天堂 DS成功之前，日本以外的视觉小说市场几乎不存在，为此在西方发行了几部日本视觉小说，例如逆转裁判系列。</p><h2 id="互动电影"><a class="header-anchor" href="#互动电影">¶</a>互动电影</h2><p>在互动电影流派是约与本发明镭射。互动电影包含预先拍摄的全动态 卡通片或真人动作序列，玩家可以在其中控制主角的一些动作。例如，当遇到危险时，玩家决定选择哪种移动、动作或组合。在这些游戏中，玩家唯一的活动就是选择或猜测设计师打算他采取的行动。互动电影通常不同于仅使用全动态视频的游戏，FMV，广泛在场景之间，因为他们试图将其整合到游戏本身中。这已被用于从赛车游戏到格斗游戏的所有领域。一些冒险游戏试图使用这个术语来将他们游戏的故事讲述与电影中的故事相提并论，最显着的是后来的Tex Murphy游戏和最近的Fahrenheit（Indigo Prophecy），尽管它们被更恰当地归类为类型杂种。互动电影元素都被改编为游戏场景剪辑，在形式快速反应事件，让玩家警惕。类似生化危机4的游戏呈现明显的游戏内提示，让玩家做出反应。不这样做通常会导致玩家角色受伤或直接死亡。</p><h2 id="实时-3D-冒险"><a class="header-anchor" href="#实时-3D-冒险">¶</a>实时 3D 冒险</h2><p>大约在这个时候，出现了实时 3D 冒险游戏。其中包括1998 年的Nightfall、1999年的莎木、2000年的realMyst、2001 年的Shadow of Memories和2003年的Uru: Ages Beyond Myst。它们增加了一些与动作游戏更常见的属性，例如自由运动和基于物理的行为。</p><h1>角色扮演（RPG）</h1><p>角色扮演视频游戏从传统的桌面角色扮演游戏（如龙与地下城）中汲取游戏玩法。这些游戏中的大多数都让玩家扮演一个角色，在游戏过程中力量和经验不断增长。通过克服困难的挑战和/或击败怪物，玩家可以获得代表角色在所选职业或职业（例如近战或远程魔法）中的进步的经验值，并允许玩家在获得一定数量后获得新能力. 许多 RPG 都包含一个被称为主世界的开放世界，通常有怪物居住，可以访问更重要的游戏地点，例如城镇、地牢和城堡。</p><p>早期很多是回合制，现在有很多是实时的。</p><h2 id="动作角色扮演"><a class="header-anchor" href="#动作角色扮演">¶</a>动作角色扮演</h2><p>该动作角色扮演游戏或动作RPG是一个类型的角色扮演视频游戏，其采用了即时战斗，而不是回合制或基于菜单的，经常借用元素的动作游戏或动作冒险游戏。一些最早的动作角色扮演游戏是由Nihon Falcom在 1980 年代制作的，例如Dragon Slayer系列和Ys系列。后来所谓的“暗黑破坏神”“克隆人”也是这一类型的一部分。尽管该类型的确切定义各不相同，但典型的动作 RPG 都非常强调战斗，通常会简化或删除非战斗属性和统计数据以及它们对角色发展的影响。[ 38]此外，战斗总是使用实时系统（因此称为“动作”）进行，该系统依赖于玩家以速度和准确性执行特定动作的能力来确定成功，而不是主要使用玩家角色的属性来确定这一点.</p><h2 id="MMORPG"><a class="header-anchor" href="#MMORPG">¶</a>MMORPG</h2><p>大型多人在线角色扮演游戏(MMORPG) 于 1990 年代中后期出现，作为自 1978 年以来一直存在的基于文本的MUD的商业图形变体。总的来说，MMORPG 具有完成任务和加强一个人的玩家角色，但涉及多达数百名玩家在同一个持久世界上实时互动。</p><h2 id="Roguelikes"><a class="header-anchor" href="#Roguelikes">¶</a>Roguelikes</h2><p>该roguelike视频游戏体裁借用1980年的电脑游戏的名称和游戏元素盗贼（Rogue)。从表面上看，roguelike 是一种二维地牢爬行，通过程序生成具有高度的随机性，强调统计角色发展，并使用permadeath。虽然传统上以文本用户界面为特色，但许多此类游戏利用图块来克服字符集限制。远离传统黑客和斜线元素但保留程序生成和永久死亡功能的较新游戏有时被称为“Rogue-Lite”</p><h2 id="战术角色扮演游戏"><a class="header-anchor" href="#战术角色扮演游戏">¶</a>战术角色扮演游戏</h2><p>该战略角色扮演游戏体裁主要是指从游戏了结合游戏策略游戏，以替代传统的RPG系统。与标准 RPG 一样，玩家控制有限的队伍并与数量相似的敌人作战，但这种类型融合了战略游戏玩法，例如等距网格上的战术移动。该类型起源于桌面角色扮演游戏，每个玩家都有时间决定他或她的角色的行动。</p><h2 id="沙盒角色扮演游戏"><a class="header-anchor" href="#沙盒角色扮演游戏">¶</a>沙盒角色扮演游戏</h2><p>沙盒 RPG 或开放世界 RPG允许玩家有很大的自由度，并且通常包含一个更开放的自由漫游（意味着玩家不受岩石或围栏等限制的单一路径）世界。沙盒 RPG 与其他沙盒游戏（如侠盗猎车手系列）有很多相似之处，具有大量可交互的非玩家角色、大量内容，通常还有一些最大的世界可供探索，并且由于令人印象深刻的游戏时间最长，因此游戏时间最长。对游戏主要故事情节不重要的次要内容的数量。沙盒 RPG 经常尝试模拟其设置的整个区域。这个子类型的流行例子包括Nihon Falcom的Dragon Slayer系列，早期的勇者斗恶龙游戏由CHUNSOFT，塞尔达II由任天堂，荒地通过获得Interplay Entertainment，在沙加和法力系列史克威尔，网络奇兵2由非理性的游戏和窥镜影城，杀出重围的离子风暴，上古卷轴和辐射系列的贝塞斯达软件并获得Interplay Entertainment，寓言由Lionhead工作室的哥特式系列的食人鱼字节，以及异域神剑通过系列整体式软。</p><h2 id="第一人称派对角色扮演游戏"><a class="header-anchor" href="#第一人称派对角色扮演游戏">¶</a>第一人称派对角色扮演游戏</h2><p>也称为 DRPG（地牢 RPG），这个子类型由 RPG 组成，玩家以第一人称视角带领一群冒险家穿过地牢或迷宫，通常是在基于网格的环境中。例子包括前面提到的巫术、魔法门和巴德的故事系列；以及Etrian Odyssey和Elminage系列。这种类型的游戏也被称为“blobbers”，因为玩家将整个团队作为一个单元或“blob”在比赛场地周围移动。</p><p>大多数“blobbers”都是回合制的，但一些游戏，如地下城主、Grimrock 传说和Beholder 之眼系列是实时播放的。这种类型的早期游戏缺乏自动地图功能，迫使玩家绘制自己的地图以跟踪他们的进度。环境和空间谜题很常见，这意味着玩家可能必须，例如，在关卡的一个部分移动一块石头，以便在关卡的另一部分打开一扇门。</p><h2 id="日式RPG（JRPG）"><a class="header-anchor" href="#日式RPG（JRPG）">¶</a>日式RPG（JRPG）</h2><p>日本角色扮演游戏往往有一个更线性的故事和一组角色。他们通常会遇到大量敌人，可能需要磨练才能进一步进入游戏。这种类型的例子包括Chrono Trigger和Final Fantasy VII。</p><h2 id="怪物驯兽师"><a class="header-anchor" href="#怪物驯兽师">¶</a>怪物驯兽师</h2><p>RPG 公式的一种变体，玩家可以招募怪物为他们战斗或与他们并肩作战。收集到的生物通常可以被饲养或繁殖以创造更强大的怪物或提高他们在战斗中的能力。怪物驯服游戏的一个例子是神奇宝贝。</p><h1>模拟</h1><p>模拟视频游戏是一个多样化的超级游戏类别，通常旨在密切模拟真实或虚构现实的各个方面。</p><h2 id="建设和管理模拟（CMS）"><a class="header-anchor" href="#建设和管理模拟（CMS）">¶</a>建设和管理模拟（CMS）</h2><p>建设和管理模拟（或 CMS）是一种模拟游戏，它要求玩家以有限的资源建立、扩展或管理虚构的社区或项目。</p><h3 id="城市建设"><a class="header-anchor" href="#城市建设">¶</a>城市建设</h3><p>在城市建设游戏中，玩家扮演总体规划者或领导者的角色，通过启动食物、住所、健康、精神关怀、经济增长等结构来满足游戏角色的需求。当城市预算不断增长时，成功就实现了利润和公民在住房、健康和商品方面体验到升级的生活方式。虽然通常包括军事发展，但重点是经济实力。这种类型的游戏最广为人知的可能是SimCity，它仍然很受欢迎，并且对后来的城市建设游戏产生了很大的影响。然而，模拟城市也属于上帝游戏类型，因为它赋予玩家操纵世界的能力。凯撒 是这一类型的长期系列，原始游戏产生了三部续集。</p><h3 id="商业模拟"><a class="header-anchor" href="#商业模拟">¶</a>商业模拟</h3><p>商业模拟游戏通常试图模拟经济或商业，玩家控制游戏的经济。</p><h3 id="政治模拟"><a class="header-anchor" href="#政治模拟">¶</a>政治模拟</h3><p>一个政府的模拟游戏（或“政治游戏”）涉及的政策，政府或国家的政治，但通常不包括战争的模拟。最近，这类游戏获得了“严肃游戏”的称号。</p><h2 id="生命模拟"><a class="header-anchor" href="#生命模拟">¶</a>生命模拟</h2><p>生命模拟游戏（或人造生命游戏）涉及生活或控制一个或多个人造生命。生活模拟游戏可以围绕个人和关系展开，也可以是对生态系统的模拟。</p><h3 id="生物模拟"><a class="header-anchor" href="#生物模拟">¶</a>生物模拟</h3><p>生物模拟可以让玩家尝试遗传学、生存或生态系统，通常以教育包的形式。一个早期的例子是SimLife，而相对较新的是侏罗纪公园：Operation Genesis和Spore。在诸如《狼》等其他教育模拟游戏中，玩家以一种相对真实的方式“过着个体动物的生活”。然而，被誉为最伟大的生命模拟游戏之一的是《Creatures、Creatures 2、Creatures 3》，其中玩家在极其详细的生态系统中繁殖了一代又一代的物种。</p><h3 id="上帝游戏"><a class="header-anchor" href="#上帝游戏">¶</a>上帝游戏</h3><p>与其他类型的游戏不同，上帝游戏通常没有允许玩家赢得游戏的设定目标。上帝游戏的重点往往是控制人们的生活，从微观管理家庭到监督文明的兴起。</p><h3 id="电子宠物"><a class="header-anchor" href="#电子宠物">¶</a>电子宠物</h3><p>宠物饲养模拟（或数字宠物）更多地关注玩家与一种或几种生命形式之间的关系。与其他生物模拟相比，它们的范围通常更有限。这包括虚拟宠物的流行示例，例如Tamagotchi、Petz系列和Nintendogs。</p><h3 id="社交模拟"><a class="header-anchor" href="#社交模拟">¶</a>社交模拟</h3><p>社交模拟游戏的玩法基于多个人工生命之间的社交互动。这一类型最著名的例子是威尔·赖特的《模拟人生》。约会模拟游戏和浪漫模拟游戏属于这一类。</p><h2 id="载具模拟"><a class="header-anchor" href="#载具模拟">¶</a>载具模拟</h2><h3 id="飞行模拟"><a class="header-anchor" href="#飞行模拟">¶</a>飞行模拟</h3><p>飞行模拟任务玩家驾驶飞机，通常是飞机，尽可能逼真。战斗飞行模拟器是最流行的模拟子类型。玩家控制飞机，不仅可以模拟飞行的动作，还可以模拟战斗情况。还有一些没有战斗方面的民用飞行模拟器。</p><h3 id="赛车"><a class="header-anchor" href="#赛车">¶</a>赛车</h3><p>赛车游戏通常将玩家置于高性能车辆的驾驶座上，并要求玩家与其他车手或有时只是时间赛跑。这种类型的游戏是电脑游戏世界的主要内容之一，许多最早的电脑游戏都是这种类型的一部分。这种类型出现在 1970 年代后期，今天仍然非常流行，并继续在图形和性能方面突破极限。这些游戏“往往属于有组织的赛车和虚构的赛车类别”。有组织的赛车模拟器试图“重现在现有赛车类中驾驶赛车或摩托车的体验：印地赛车、纳斯卡、一级方程式，等等。”另一方面，虚拟赛车游戏涉及“想象的情况，疯狂地穿越城市或乡村甚至幻想环境”。这些“想象”的赛车游戏有时被称为街机赛车游戏，与之相反的是更多逼真的“赛车模拟”对应物。其中包括极品飞车、马里奥赛车和Gran Turismo。Rollings 和 Adams 指出“赛车游戏通常在体育类别中出售”，但“从设计的角度来看，它们确实属于…车辆模拟”。[42]</p><h3 id="太空飞行模拟"><a class="header-anchor" href="#太空飞行模拟">¶</a>太空飞行模拟</h3><p>太空飞行模拟器游戏是涉及驾驶航天器的一个子类型。空间模拟器不同于其他子类型，通常不被认为是模拟器，因为它们的模拟对象并不总是存在并且经常无视物理定律。</p><h3 id="火车模拟"><a class="header-anchor" href="#火车模拟">¶</a>火车模拟</h3><p>火车模拟器模拟与铁路运输相关的车辆、环境和经济。这些往往是历史性的，让人想起各国铁路的演变和出现，以及经常伴随着它们的经济繁荣。</p><h3 id="载具格斗"><a class="header-anchor" href="#载具格斗">¶</a>载具格斗</h3><p>车辆格斗或汽车格斗游戏侧重于快节奏的动作，因为玩家驾驶汽车或其他车辆并试图禁用或摧毁CPU或人类对手。载具格斗游戏通常允许玩家从多种潜在载具中进行选择，每种载具都有自己的长处和短处。车辆战斗诞生于Spy Hunter、RoadBlasters和Rock ‘N’ Roll Racing等赛车/射击游戏组合，但不同之处在于，如果需要，玩家可以将车辆驶离预定路线并随心所欲地进行战斗。载具战斗的一个子类型是机甲 战斗中，车辆通常包括巨大的机器人式坦克。</p><h1>策略</h1><p>战略视频游戏专注于需要仔细和熟练的思考和计划以取得胜利的游戏玩法，以及从世界统治到基于小队的战术的行动规模。战略视频游戏通常采用四种原型形式中的一种，这取决于游戏是回合制还是实时游戏，以及游戏的重点是战略还是战术. 即时战略游戏通常是一种多单元选择游戏（可以一次选择多个游戏角色来执行不同的任务，而不是一次只选择一个角色），具有天空视图（从上方俯视）但最近的一些游戏Tom Clancy’s EndWar等游戏都是单人选择和第三人称视角。与许多RPG游戏一样，许多策略游戏正逐渐从回合制系统转向更加实时的系统。</p><h2 id="4X游戏"><a class="header-anchor" href="#4X游戏">¶</a>4X游戏</h2><p>4X是指具有四个主要目标的战略视频游戏类型：eXplore、eXpand、eXploit 和 eXterminate。一个4X游戏可以回合制或实时的。也许这种类型最著名的例子是席德梅尔的文明系列。4X 游戏通常涵盖很长一段时间，让玩家可以控制整个文明或物种。通常这些游戏有一个历史背景，包括大量的人类历史（地球帝国、文明、文明黄金时代）或科幻小说背景，玩家控制一个物种主宰银河系（猎户座大师、银河文明）。</p><h2 id="火炮"><a class="header-anchor" href="#火炮">¶</a>火炮</h2><p>Artillery是早期的两人或三人（通常是回合制）电脑游戏的总称，这些游戏涉及坦克在战斗或类似的衍生游戏中相互战斗。炮兵游戏是最早开发的电脑游戏之一，可以被认为是电脑最初用途的延伸，电脑曾经用于军事计算，例如绘制火箭的轨迹。火炮游戏被认为是一种回合制战术游戏，尽管它们也被描述为一种“射击游戏”。这种类型的例子有Pocket Tanks、Hogs of War、Scorched 3D和Worms系列。</p><h2 id="自走棋"><a class="header-anchor" href="#自走棋">¶</a>自走棋</h2><p>自动对战，又称“自走棋”，是一种具有类似国际象棋元素的策略游戏，玩家在准备阶段将角色放置在网格状的战场上，然后与对方的角色进行战斗，无需任何进一步的直接输入从播放器。它由Dota Auto Chess于 2019 年初创建和推广，并在不久之后发布了其他工作室的更多此类游戏，例如Teamfight Tactics、Dota Underlords和Hearthstone Battlegrounds。</p><h2 id="多人在线战斗竞技场（MOBA）"><a class="header-anchor" href="#多人在线战斗竞技场（MOBA）">¶</a>多人在线战斗竞技场（MOBA）</h2><p>多人在线战斗竞技场(MOBA) 是一种策略视频游戏，其中每个玩家控制一个具有一组独特能力的角色，这些能力在游戏过程中不断提高，并有助于团队的整体战略。[48]玩家作为一个团队一起工作，以达到胜利条件，即摧毁对方球队的主要结构，同时保护自己的结构。玩家角色，通常被称为“英雄”或“冠军”，由定期生成的计算机控制单位协助成群结队地沿着既定的路径（称为“车道”）向敌人的基地前进。防御结构通常是自动“塔”，可以防止这种情况发生。最先摧毁对手主体结构的队伍赢得比赛。[49]该类型被视为实时战略游戏、角色扮演游戏和动作游戏的融合，然而，玩家通常不会建造建筑物或单位。[50]</p><h2 id="实时策略-RTS"><a class="header-anchor" href="#实时策略-RTS">¶</a>实时策略 (RTS)</h2><p>绰号“实时战略”（RTS），通常只适用于某些计算机战略游戏，（然而，这种类型可能是最著名的战略游戏，也是大多数网站在说“战略游戏”时的意思）表明游戏中的动作是连续的，玩家必须在不断变化的游戏状态背景下做出决定和行动。即时战略游戏的特点是获取资源、建立基地、研究技术和生产单位。暴雪娱乐的星际争霸是一款在韩国进行竞技并面向大量观众进行电视转播的流行即时战略游戏。其他著名游戏包括魔兽系列、帝国时代系列，战争黎明，英雄连队，命令与征服，和沙丘II（基本上是第一个RTS游戏）。在 PC 之外，很少有策略游戏是实时的；一些例子是中土之战 II、Pikmin和Halo Wars。更少的人使用物理件，例如Icehouse。</p><h2 id="实时战术-RTT"><a class="header-anchor" href="#实时战术-RTT">¶</a>实时战术 (RTT)</h2><p>实时战术（缩写RTT [56]和以下通常被称为“固定部即时战略” [57] ）是体裁的战术战争游戏中演奏的实时模拟的考虑因素和情况操作战和军事战术。它有时也被认为是实时战略的一个子类型，因此在这种情况下可能作为游戏玩法的元素或作为整个游戏的基础而存在。与即时战略玩法的区别在于缺乏资源微管理和基地或单位建设，以及单个单位的更大重要性[56] [58]和对复杂战场战术的关注。示例标题包括Warhammer: Dark Omen、World In Conflict、Close Combat系列以及早期的战术角色扮演游戏，如Bokosuka Wars、Silver Ghost和First Queen。</p><h2 id="塔防"><a class="header-anchor" href="#塔防">¶</a>塔防</h2><p>塔防游戏的布局非常简单。通常，计算机控制的怪物沿着设定的路径移动，玩家必须沿着这条路径放置或“建造”塔来杀死敌人。在某些游戏中，塔沿着敌人设定的路径放置，而在其他游戏中，塔可以中断敌人的移动并改变他们的路径。在大多数塔防游戏中，不同的塔有不同的能力，例如使敌人中毒或减速。玩家因杀死敌人而获得金钱，这笔钱可用于购买更多的塔，或为塔购买升级，例如增加功率或射程。</p><h2 id="回合制策略-TBS"><a class="header-anchor" href="#回合制策略-TBS">¶</a>回合制策略 (TBS)</h2><p>术语回合制策略(TBS) 通常保留给某些计算机策略游戏，以将它们与实时策略游戏区分开来。回合制游戏的玩家在进行游戏动作之前被允许进行一段时间的分析，并且一些游戏允许在回合中进行一定数量的移动或动作。与即时战略游戏一样，这一类型可以包括许多不仅仅是回合制游戏的战略游戏，以及可能包含与游戏是否回合制无关的其他功能的游戏。这种类型的例子有《文明》、《魔法门之英雄无敌》、《创造历史》和《猎户座大师》。</p><p>最近的一些回合制策略游戏的玩法机制不同，回合同时解决，每个玩家在计划阶段准备自己的未来行动，然后让游戏同时执行命令，导致命令被打断通过对手的动作，将游戏玩法从对对手动作的反应转变为猜测他们。</p><h2 id="回合制战术-TBT"><a class="header-anchor" href="#回合制战术-TBT">¶</a>回合制战术 (TBT)</h2><p>回合制战术游戏 (TBT)的游戏玩法的特点是期望玩家使用提供给他们的作战力量来完成他们的任务，并且通常通过提供真实（或至少可信）的军事战术和行动表示. 这种类型的例子包括战争、铁血联盟和X-COM系列，以及战术角色扮演游戏，如火焰纹章和最终幻想战术。</p><h2 id="战争游戏"><a class="header-anchor" href="#战争游戏">¶</a>战争游戏</h2><p>兵棋是战略视频游戏的一个子类型，强调地图上的战略或战术战争。兵棋推演通常采用四种原型形式中的一种，这取决于游戏是回合制还是实时游戏，以及游戏的重点是军事战略还是战术。</p><h2 id="大战略兵棋"><a class="header-anchor" href="#大战略兵棋">¶</a>大战略兵棋</h2><p>一个大战略战争游戏是一个战争游戏是地方集中在大战略：军事战略，在移动和使用整个的水平民族国家或帝国的资源。</p><h1>体育</h1><h2 id="赛车-v2"><a class="header-anchor" href="#赛车-v2">¶</a>赛车</h2><h2 id="体育比赛"><a class="header-anchor" href="#体育比赛">¶</a>体育比赛</h2><h2 id="竞技"><a class="header-anchor" href="#竞技">¶</a>竞技</h2><h2 id="运动基础格斗"><a class="header-anchor" href="#运动基础格斗">¶</a>运动基础格斗</h2><h1>MMO</h1><h1>棋牌</h1><h1>突围克隆（打砖块）</h1><h1>赌场</h1><h2 id="游戏机"><a class="header-anchor" href="#游戏机">¶</a>游戏机</h2><p>老虎机和弹球机</p><h2 id="赌桌"><a class="header-anchor" href="#赌桌">¶</a>赌桌</h2><p>21点和掷骰子</p><h2 id="随机数"><a class="header-anchor" href="#随机数">¶</a>随机数</h2><p>基诺和宾果</p><h1>休闲</h1><p>休闲游戏被设计为易于拿起和再次放下，允许潜在的短时间游戏，例如使命召唤和大多数移动平台上的游戏。这种类型的游戏是一种短暂而轻松的消遣，是其他职业之间的休息，因此最受空闲时间较少的人群欢迎。出于这个原因，游戏通常具有自动保存和同步作为标准，因此可以将游戏最小化、进入睡眠状态或以其他方式放下，而不会对玩家造成任何损失。这一类型的市场领导者通常颜色大胆，专为直观互动而设计，并在奖励与时间之间保持高度平衡，以保持人们的回头率。这些游戏的设计者应该加入很多“果汁”（刺激感官的声音和动作元素），让它们在高度相似的游戏海洋中脱颖而出。</p><p>由于上述要求，其中许多游戏都非常容易上手和玩，无需冗长的教程。留住玩家需要精心设计关卡、挑战和事件。</p><h1>数字收藏卡（DCCG）</h1><p>万智牌和炉石传说</p><h1>扭蛋</h1><p>克金游戏</p><h1>恐怖</h1><p>恐怖游戏是将恐怖小说元素融入叙事的游戏，通常与游戏类型无关。它是唯一通过叙事元素而不是游戏玩法、游戏模式或平台来识别的主要视频游戏类型。生存恐怖是恐怖游戏的一个子类型，专注于动作冒险风格的游戏玩法。</p><h1>放置（点曲奇）</h1><p>这种类型的游戏以简单的任务为导向，例如点击 cookie；并且随着游戏的进行，玩家完成上述任务会逐渐获得一定的升级奖励。总之，这些游戏几乎不需要玩家参与，而且在大多数情况下他们自己玩；因此使用“空闲”一词</p><h1>益智（解密）</h1><p>逻辑游戏需要玩家解决逻辑谜题或在迷宫等复杂位置导航。它们非常适合休闲游戏，拼图益智游戏是最受欢迎的休闲游戏之一。这种类型经常与冒险和教育游戏交叉。俄罗斯方块，标记为益智游戏，因革新游戏和普及益智类型而受到赞誉。</p><h1>派对</h1><p>派对游戏是专为多人游戏而开发的视频游戏。通常，派对游戏有各种各样的迷你游戏，包括比其他玩家收集更多特定物品或在某事上拥有最快的时间。此类游戏包括Mario Party系列、Crash Bash和Rayman Raving Rabbids。对战多人游戏通常不被视为派对游戏。</p><h1>摄影</h1><p>一个摄影比赛任务的球员使用拍照在游戏摄像系统，通常授予更好的合成图像更多的积分。摄影机制通常作为其他类型游戏的支线任务来实现，但也有摄影是主要游戏模式的游戏。其中包括Pokémon Snap、Afrika和Fatal Frame系列。</p><h1>编程</h1><p>一个游戏编程是一个电脑游戏，玩家对游戏的过程中没有直接的影响。相反，计算机程序或脚本是用某种特定领域的编程语言编写的，以控制角色的动作（通常是机器人、坦克或细菌，它们试图相互摧毁）。例如，在SpaceChem 中，玩家设计用于从原材料制造分子的电路。最终幻想 XII还包括一些编程游戏的元素，因为玩家可以创建他的角色的 AI，尽管玩家也可以选择直接控制动作。</p><h1>社会演绎</h1><h1>益智问答游戏</h1><p>琐事游戏越来越受欢迎，尤其是在手机上，人们可能只有几分钟的时间来玩游戏。在琐事游戏中，目的是为了获得积分而回答问题。它们可能基于现实生活中的琐事游戏节目，例如你比五年级学生更聪明吗？或家庭不和。</p><h1>打字</h1><p>打字游戏是使用任何游戏打字作为相互作用的主要方法。虽然它们最初是作为一种教育游戏开始的，但随着独立开发者探索该类型的可能性，它们后来变得更加注重娱乐性。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;制作游戏的第一步就是设计游戏玩法，从前人的游戏中，有不少成熟的模式值得借鉴。&lt;/p&gt;</summary>
    
    
    
    <category term="游戏设计" scheme="https://blog.kleon.space/categories/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="游戏设计" scheme="https://blog.kleon.space/tags/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>普惠自动化 - 零代码/低代码/RPA/学Python</title>
    <link href="https://blog.kleon.space/product/research/general-automation/"/>
    <id>https://blog.kleon.space/product/research/general-automation/</id>
    <published>2021-06-30T10:21:08.000Z</published>
    <updated>2021-06-30T10:27:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>如何应对普遍存在的自动化需求？</p><span id="more"></span><h1>需求</h1><p>数字化进程不断加深，自动化的需求日益增长。计算设备从诞生起，不断从底层革新实现方式，交互形式上也不断简化。初代程序员需要熟悉二进制打孔纸带，化身人肉解码器。随后是128个字符，直接访问内存，操作寄存器。之后是更高层的抽象，使用函数、对象等模型屏蔽对底层硬件的关注，辅以编译优化技术自动生成指令。最近很火的编程语言是Python，提供了一套极简的动态模型，掌握条件、循环、函数、对象即可上手。</p><p>但如此还是不够，编程仍然是一小部分人掌握的能力，但自动化的需求是普遍存在的。越来越多的人需要通过各式各样的接口操作数据，即便是那些现在还没有数字化的产业，也在积极拥抱数字化。数字化是自动化的前提，数字化的核心围绕三点：IO，数据，计算。</p><p>IO是数字世界的大门，输入I包括人机交互设备，数据采集设备，输出O包括人机显示设备，机械装置。<br>数据是数字世界的核心建筑，数据库是广为采用的存储形式，绝大部分系统只是对数据库的包装。<br>计算是数字世界的建设演化的动力，从数据中提取模式，分析相关因果，预测未知，生成无在。</p><p>编程是少数人的能力，程序员，研究员，分析员，与数字世界的交互并不干净，脏活累活不少，系统中的缺陷更多。其他大部分人都在通过有限的交互方式使用系统，绝大部分是重复性劳动，自动化的需求是普遍存在的，但绝大部分需求是个性化、定制化的，不足以专门为此开发一套系统。</p><h1>解法</h1><p>那么有什么方案来满足普遍存在的轻量的定制化的自动化需求呢？目前可以看到几种方向：零代码、低代码、RPA、学Python。</p><h2 id="零代码"><a class="header-anchor" href="#零代码">¶</a>零代码</h2><p>零代码就是不写代码，使用完全图形化的交互形式。在工业系统如LabView等工具上已经可以看到应用。但是零代码并不是完全不需要理解程序化流程，而是提供了一套形象化的操作方式。本身仍然是编程，要看提供的可用模块丰富度，各类模块的连线繁琐程度并不比直接写代码更方便，在版本管理上，使用序列化配置文件描述连接关系，颇有硬件设计语言的形式。</p><h2 id="低代码"><a class="header-anchor" href="#低代码">¶</a>低代码</h2><p>在零代码的基础上，增加了模块内代码描述。还是得学的JavaScript或者Python，操作JSON文件。</p><h2 id="RPA"><a class="header-anchor" href="#RPA">¶</a>RPA</h2><p>主要解决的是自动化人机交互问题，使用模拟输入固化操作，集按键精灵和爬虫为一体，兼容传统文件：Word，Excel。更智能等解决方案包括：语音识别、NLP语义分析、知识问答、语音合成、OCR识别、图像检测等。</p><h2 id="学Python"><a class="header-anchor" href="#学Python">¶</a>学Python</h2><p>花了十天看完Python入门，写个应用，基本会被淹没在文件系统、网络、数据格式、前后端等等各类操作细节中。</p><h1>趋势</h1><p>单机-&gt;联机-&gt;多人协作</p><p>关注数据不关注操作细节</p><p>自动化流程的构建、调试、维护、版本管理</p><h1>拆解</h1><p>零代码平台主要功能：</p><ul><li>表单，收集信息</li><li>流程，审批，API调用</li><li>报表，数据分析</li><li>文档，内部归纳</li></ul><h1>WHY</h1><p>更低门槛的普惠自动化可以带来什么？</p><h2 id="个人"><a class="header-anchor" href="#个人">¶</a>个人</h2><p>传统上，使用TODO、笔记本、文档、Excel完成任务进度规划、事项提醒、资料收集、头脑风暴、论文编写、知识记忆。</p><p>论道与术。多种工具结合，有清晰的目的。对多数人来说，TODO List足以，以纸质书为基础、以视频课程为辅，以课后习题和考前刷题为核心。</p><p>这里有低代码、RPA的空间吗？这里更像是时间规划、项目管理、资源整合的需求。</p><p>重复性程度低，创造性程度高。以外界目标为基准的学习行为往往非常耗能。</p><p>将TODO、笔记、数据、文档、项目整合，增强跨功能体验。</p><h2 id="团队"><a class="header-anchor" href="#团队">¶</a>团队</h2><p>项目、订单、产品、项目、客户，一切皆表、一切皆对象。ORM可以解决大部分。</p><h2 id="微型公司"><a class="header-anchor" href="#微型公司">¶</a>微型公司</h2><p>流程审批</p><p>权限</p><p>数据安全</p><h1>产品</h1><p>UniPath<br>影刀<br>简道云</p><h1>功能</h1><p>多个产品揉在了一起，需要分解</p><h2 id="ORM"><a class="header-anchor" href="#ORM">¶</a>ORM</h2><p>mark</p><p>一切皆对象，用于建立项目、任务、TODO、书单，anything关联表。</p><p>感觉很好，比直接操作数据库好。其他产品应该有类似功能或跟进。</p><h2 id="Workflow"><a class="header-anchor" href="#Workflow">¶</a>Workflow</h2><p>不做，属于0代码范畴，过于复杂。流程审批也不做，交给企业OA。</p><p>操作出入数据，0代码，需要宏模块。</p><h2 id="多媒体Chat"><a class="header-anchor" href="#多媒体Chat">¶</a>多媒体Chat</h2><p>mark，基本聊天功能。</p><ol><li>支持和doc互动。</li><li>支持orm引用。</li><li>-todo 支持自定义交互组件</li></ol><p>基本功能，支持更多样的显示，貌似没啥用。</p><h2 id="多媒体Doc"><a class="header-anchor" href="#多媒体Doc">¶</a>多媒体Doc</h2><p>基本功能，支持更多样的显示，貌似没啥用。</p><p>互动式文档，比如旅游规划，可显示定位，跳转。</p><p>动态规划行程插件，支持修改文档显示内容，不影响文档实际内容。实际内容需要编辑权限。</p><p>和notion有什么区别。</p><p>不打算支持完整的文档功能。</p><ol><li>和channel的互动。拖拽到doc，或直接转换为doc引用。</li><li>-todo 支持自定义交互组件，属于表单的功能，可delay。</li><li>支持ORM引用（一个引用，复用channel的引用，layout可能差点）和图表（点状图）。</li></ol><h2 id="表单发布"><a class="header-anchor" href="#表单发布">¶</a>表单发布</h2><p>暂时不做，功能较简单，考虑是否与doc合并</p><p>单独拆解，不与文档耦合。</p><h2 id="数据库-v3"><a class="header-anchor" href="#数据库-v3">¶</a>数据库</h2><p>可直接操作的数据库，可连外接数据源。</p><p>可暴露直接操作，也可限制权限，通过ORM操作。</p><ol><li>基本操作。</li></ol><h2 id="信息整合Inbox"><a class="header-anchor" href="#信息整合Inbox">¶</a>信息整合Inbox</h2><p>手机share、webhook发送等。</p><p>使用Channel。</p><ol><li>支持一个极简trigger，从消息提取文本，生成ORM。</li></ol><h2 id="订阅中心"><a class="header-anchor" href="#订阅中心">¶</a>订阅中心</h2><p>订阅RSS、爬虫，各类自媒体消息。</p><p>不做，属于RPA功能，使用Webhook推送。</p><h2 id="过滤"><a class="header-anchor" href="#过滤">¶</a>过滤</h2><p>不做，消息过载，过滤。从各类消息中过滤，FearOfMissing。</p><p>属于应用开发，可以在trigger增加关键字。</p><h2 id="个人助手-v2"><a class="header-anchor" href="#个人助手-v2">¶</a>个人助手</h2><p>不做，命题过大。</p><p>今日代办、行程指引、自动规划、知识抽取、场景推荐。通常意味着在OS层获取其他应用信息。</p><p>助手的便携体现在什么地方？</p><p>不同的人有不同要求。</p><p>对于公司职员，更好更快地处理琐碎的劳动细节，避免重复性劳动更有价值。出于数据安全性的问题，可能单机版RPA工具可能更适合。<br>对于自由职业，管理项目排期，客户关系，外包税帐更有价值，积累核心库。<br>对于学生，更高效低达成目标更关键，通常自我约束能力差的人，也不太会因为用了工具而更好。</p><h2 id="简易应用builder"><a class="header-anchor" href="#简易应用builder">¶</a>简易应用builder</h2><p>不做，用ORM吧。</p><p>7个习惯中有很多表，可以快速build上线使用。</p><h2 id="Application-v2"><a class="header-anchor" href="#Application-v2">¶</a>Application</h2><p>使用H2O做的挑瓜神器。</p><p>西瓜ORM</p><ul><li>西瓜保持在中心：图片</li><li>敲打声：音频</li><li>创建</li></ul><p>trigger</p><ul><li>call api</li><li>insert into orm 好瓜</li><li>insert after 好瓜</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;如何应对普遍存在的自动化需求？&lt;/p&gt;</summary>
    
    
    
    <category term="科技" scheme="https://blog.kleon.space/categories/%E7%A7%91%E6%8A%80/"/>
    
    
    <category term="科技" scheme="https://blog.kleon.space/tags/%E7%A7%91%E6%8A%80/"/>
    
    <category term="零代码" scheme="https://blog.kleon.space/tags/%E9%9B%B6%E4%BB%A3%E7%A0%81/"/>
    
    <category term="低代码" scheme="https://blog.kleon.space/tags/%E4%BD%8E%E4%BB%A3%E7%A0%81/"/>
    
    <category term="RPA" scheme="https://blog.kleon.space/tags/RPA/"/>
    
  </entry>
  
  <entry>
    <title>机器学习系统 5-1 - 数据系统</title>
    <link href="https://blog.kleon.space/ai/ml-system/big-data/1-overview/"/>
    <id>https://blog.kleon.space/ai/ml-system/big-data/1-overview/</id>
    <published>2021-05-12T12:58:36.000Z</published>
    <updated>2021-05-12T12:58:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>高效稳健的数据系统是保障各项业务运行的基石。</p><span id="more"></span><p>数据系统主要可以划分为：</p><ul><li>分布式文件系统，如HDFS。</li><li>数据收集，包括移动端埋点，服务端日志，第三方数据等</li><li>数据仓库，长期保存结构化数据，Hive，提供数据清洗，特征工程等功能。</li><li>数据湖，长期保存非结构化数据，如S3,Minio。</li><li>数据库，线上服务使用的数据源，按性能分关系型（MySQL，PostgreSQL），键值型（Redis内存），文档型（MongoDB，CouchBase内存），列存储（HBase）。</li><li>消息队列，模块解耦，如Kafka。</li><li>日志系统，ELK（ElasticSearch, LogStash, Kibana）。</li><li>计算引擎，按功能分实时（Flink，Spark Streaming），离线（Spark，Hadoop）。</li><li>ETL，日志抽取。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;高效稳健的数据系统是保障各项业务运行的基石。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://blog.kleon.space/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习" scheme="https://blog.kleon.space/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="大数据" scheme="https://blog.kleon.space/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>机器学习系统 4-10 - 逻辑回归</title>
    <link href="https://blog.kleon.space/ai/ml-system/recommender/10-logistic-regression/"/>
    <id>https://blog.kleon.space/ai/ml-system/recommender/10-logistic-regression/</id>
    <published>2021-05-02T12:25:10.000Z</published>
    <updated>2021-05-12T12:24:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>Logistic Regression</p><span id="more"></span><p>–</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Logistic Regression&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://blog.kleon.space/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习" scheme="https://blog.kleon.space/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="推荐系统" scheme="https://blog.kleon.space/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>机器学习系统 4-11 - 因子分解机</title>
    <link href="https://blog.kleon.space/ai/ml-system/recommender/11-factor-machine/"/>
    <id>https://blog.kleon.space/ai/ml-system/recommender/11-factor-machine/</id>
    <published>2021-05-02T12:25:10.000Z</published>
    <updated>2021-05-12T12:24:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>因子分解机</p><span id="more"></span><h1>原理</h1><ol><li>FM能处理数据高度稀疏场景，SVM则不能；</li><li>FM具有线性的计算复杂度，而SVM依赖于support vector。</li><li>FM能够在任意的实数特征向量中生效。</li></ol><p>–</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;因子分解机&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://blog.kleon.space/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习" scheme="https://blog.kleon.space/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="推荐系统" scheme="https://blog.kleon.space/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>机器学习系统 4-12 - GBDR+LR</title>
    <link href="https://blog.kleon.space/ai/ml-system/recommender/12-gbdt-lr/"/>
    <id>https://blog.kleon.space/ai/ml-system/recommender/12-gbdt-lr/</id>
    <published>2021-05-02T12:25:10.000Z</published>
    <updated>2021-05-12T12:24:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>GBDT+LR</p><span id="more"></span><p>–</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;GBDT+LR&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://blog.kleon.space/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习" scheme="https://blog.kleon.space/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="推荐系统" scheme="https://blog.kleon.space/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>机器学习系统 4-13 - 深度学习模型</title>
    <link href="https://blog.kleon.space/ai/ml-system/recommender/13-deep-model/"/>
    <id>https://blog.kleon.space/ai/ml-system/recommender/13-deep-model/</id>
    <published>2021-05-02T12:25:10.000Z</published>
    <updated>2021-05-02T12:24:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>深度模型主要是在深度学习后崛起的，主要通过深度学习网络做了自动特征交叉。</p><span id="more"></span><h1>模型</h1><ul><li>AutoRec</li><li>Deep Crossing</li><li>NeuralCF</li><li>PNN</li><li>WDL</li><li>FNN</li><li>DeepFM</li><li>NFM</li><li>AFM</li><li>DIN</li><li>DIEN</li><li>DRN</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;深度模型主要是在深度学习后崛起的，主要通过深度学习网络做了自动特征交叉。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://blog.kleon.space/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习" scheme="https://blog.kleon.space/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="推荐系统" scheme="https://blog.kleon.space/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>机器学习系统 4-15 - 树模型</title>
    <link href="https://blog.kleon.space/ai/ml-system/recommender/15-tree/"/>
    <id>https://blog.kleon.space/ai/ml-system/recommender/15-tree/</id>
    <published>2021-05-02T12:25:10.000Z</published>
    <updated>2021-05-02T12:24:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>树模型以决策树为基本原型。</p><span id="more"></span><p>树模型<a href="#refer-5"><sup>5</sup></a> <a href="#refer-6"><sup>6</sup></a></p><h2 id="DT"><a class="header-anchor" href="#DT">¶</a>DT</h2><p>决策树是一种基本的分类和回归方法。和我们之前学过的逻辑斯特回归，线性回归等算法不同，他们要么只能做回归要么只能做分类，而决策树既可以做分类也可以做回归。主要包括：ID3，C4.5，CART。</p><p>物理含义：表示定义在特征空间上的条件概率分布，也就是把$$P(y)$$转化为$$P(y|X)$$。同时也可以理解为 if-then 规则的集合。如下图左图所示。</p><p>几何含义： “分而治之”的思想，即把特征空间划分为一系列的矩形区域，然后再每一个区域拟合一个简单的模型。如下图右图所示。本文将用决策树的几何含义对决策树进行讲解。</p><h3 id="过拟合"><a class="header-anchor" href="#过拟合">¶</a>过拟合</h3><p>原因：<br>在决策树构建的过程中，对决策树的生长没有进行合理的限制（剪枝）；<br>样本中有一些噪声数据，没有对噪声数据进行有效的剔除；<br>在构建决策树过程中使用了较多的输出变量，变量较多也容易产生过拟合。<br>解决办法：<br>选择合理的参数进行剪枝，可以分为预剪枝和后剪枝，我们一般采用后剪枝的方法；<br>利用K−folds交叉验证，将训练集分为K份，然后进行K次交叉验证，每次使用K−1份作为训练样本数据集，另外一份作为测试集；<br>减少特征，计算每一个特征和响应变量的相关性，常见得为皮尔逊相关系数，将相关性较小的变量剔除；当然还有一些其他的方法来进行特征筛选，比如基于决策树的特征筛选，通过正则化的方式来进行特征选取等（决策的正则化，例如，L1和L2正则，具体是对谁的正则呢？怎样正则的呢？）。</p><h3 id="剪枝"><a class="header-anchor" href="#剪枝">¶</a>剪枝</h3><p>预剪枝：在决策树生成初期就已经设置了决策树的参数，决策树构建过程中，满足参数条件就提前停止决策树的生成。<br>后剪枝：后剪枝是一种全局的优化方法，它是在决策树完全建立之后再返回去对决策树进行剪枝。<br>参数：树的高度、叶子节点的数目、最大叶子节点数、限制不纯度。</p><p>预剪枝使得决策树的很多分支都没有“展开”，这不仅降低了过拟合的风险，还显著减少了决策树的训练时间开销和测试时间开销。但是，另一方面，因为预剪枝是基于“贪心”的，所以，虽然当前划分不能提升泛华性能，但是基于该划分的后续划分却有可能导致性能提升，因此预剪枝决策树有可能带来欠拟合的风险。</p><p>后剪枝决策树通常比预剪枝决策树保留了更多的分支，一般情形下，后剪枝决策树的欠拟合风险小，泛华性能往往也要优于预剪枝决策树。但后剪枝过程是在构建完全决策树之后进行的，并且要自底向上的对树中的所有非叶结点进行逐一考察，因此其训练时间开销要比未剪枝决策树和预剪枝决策树都大得多。</p><ul><li>REP-错误率降低剪枝</li><li>PEP-悲观剪枝<a href="#refer-13"><sup>13</sup></a></li><li>CCP-代价复杂度剪枝<a href="#refer-13"><sup>13</sup></a></li></ul><p>后剪枝会减少欠拟合的风险，但训练时间相对于预剪枝会长很多。</p><p>REP方法是通过一个新的验证集来纠正树的过拟合问题。对于决策树中的每一个非叶子节点的子树，我们将它替换成一个叶子节点，该叶子节点的类别用大多数原则来确定，这样就产生了一个新的相对简化决策树，然后比较这两个决策树在验证集中的表现。如果新的决策树在验证集中的正确率较高，那么该子树就可以替换成叶子节点，从而达到决策树剪枝的目的。该算法是从下往上依次遍历所有的子树，直至没有任何子树可以替换使得在验证集上的表现得以改进时，算法就可以终止。</p><h3 id="改进"><a class="header-anchor" href="#改进">¶</a>改进</h3><p>ID3以信息增益作为特征划分依据。信息增益表示由于得知特征a的信息后儿时的数据集D的分类不确定性减少的程度，后面部分越小,减小的程度越小,增益越大。选择划分后信息增益大的作为划分特征，说明使用该特征后划分得到的子集纯度越高，即不确定性越小。因此我们总是选择当前使得信息增益最大的特征来划分数据集。缺点是信息增益偏向取值较多的特征（原因：当特征的取值较多时，根据此特征划分更容易得到纯度更高的子集，因此划分后的熵更低，即不确定性更低，因此信息增益更大）</p><p>C4.5以信息增益率作为特征划分依据。可以利用连续特征，同时还增加了处理缺失值的方法和剪枝。需要注意的是，C4.5使用信息增益比对特征进行选择又会出现对特征取值较少的特征有偏好的问题。因此 C4.5 并不是直接用增益率最大的特征进行划分，而是使用一个启发式方法：先从候选划分特征中找到信息增益高于平均值的特征，再从中选择增益率最高的。C4.5处理连续特征方法是首先对连续特征进行排序，然后选择相邻值得中点作为分割点，需要注意的是，C4.5处理连续值是二分，并且该连续特征在接下来也可以继续使用。其余就和处理离散特征没有太大的区别了。</p><p>CART以基尼系数作为特征划分依据。无论是 ID3 还是 C4.5 都会涉及大量的对数运算。CART 分类树算法使用基尼系数，基尼系数代表了模型的不纯度，基尼系数越小，则不纯度越低，特征越好。</p><p>$$<br>Gini§ = \sum_{k=1}^{K} p_{k} (1-p_{k}) = 1 - \sum_{k=1}^{K} p_{k}^2<br>$$</p><p>如果是二类分类问题，计算就更加简单了，如果属于第一个样本输出的概率是 p，则基尼系数的表达式为：</p><p>$$<br>Gini§ = 2p(1 - p)<br>$$</p><p>对于个给定的样本D，假设有 K 个类别, 第 k 个类别的数量为 $$C_{k}$$ ,则样本 D 的基尼系数表达式为：<br>$$<br>Gini(D) = 1 - \sum_{k=1}^{K} (\frac{|C_k|}{|D|})^2<br>$$</p><p>特别的，对于样本 D，如果根据特征 A 的某个值 a，把 D 分成 D1 和 D2 两部分，则在特征 A 的条件下，D 的基尼系数表达式为：</p><p>$$<br>Gini(D|A) = \frac{|D_1|}{|D|}Gini(D_1) + \frac{|D_2|}{|D|}Gini(D_2)<br>$$</p><ul><li>采用基尼系数可以降低计算量</li><li>连续值处理：其思想和 C4.5 是相同的，都是将连续的特征离散化。唯一的区别在于在选择划分点时的度量方式不同，C4.5 使用的是信息增益比，则 CART 分类树使用的是基尼系数。</li><li>采用二叉树：ID3 或者 C4.5采用的是多叉树；CART树采用的是二叉树。在 ID3 或者 C4.5 的一棵子树中，离散特征只会参与一层节点的建立；CART树中离散的特征可能参与多层节点的建立。</li></ul><h2 id="Random-Forest"><a class="header-anchor" href="#Random-Forest">¶</a>Random Forest</h2><p>随机森林是集成学习中的Bagging方法。提到随机森林，就不得不提Bagging，Bagging可以简单的理解为：放回抽样，多数表决（分类）或简单平均（回归）,同时Bagging的基学习器之间属于并列生成，不存在强依赖关系。</p><p>Random Forest（随机森林）是Bagging的扩展变体，它在以决策树 为基学习器构建Bagging集成的基础上，进一步在决策树的训练过程中引入了随机特征选择，因此可以概括RF包括四个部分：1、随机选择样本（放回抽样）；2、随机选择特征；3、构建决策树；4、随机森林投票（平均）。</p><p>RF和Bagging对比：RF的起始性能较差，特别当只有一个基学习器时，随着学习器数目增多，随机森林通常会收敛到更低的泛化误差。随机森林的训练效率也会高于Bagging，因为在单个决策树的构建中，Bagging使用的是‘确定性’决策树，在选择特征划分结点时，要对所有的特征进行考虑，而随机森林使用的是‘随机性’特征数，只需考虑特征的子集。</p><h2 id="GBDT"><a class="header-anchor" href="#GBDT">¶</a>GBDT</h2><p>GBDT是集成学习中的Boosting方法。提GBDT之前，谈一下Boosting，Boosting是一种与Bagging很类似的技术。不论是Boosting还是Bagging，所使用的多个分类器类型都是一致的。但是在前者当中，不同的分类器是通过串行训练而获得的，每个新分类器都根据已训练的分类器的性能来进行训练。Boosting是通过关注被已有分类器错分的那些数据来获得新的分类器。</p><p>GBDT与传统的Boosting区别较大，它的每一次计算都是为了减少上一次的残差，而为了消除残差，我们可以在残差减小的梯度方向上建立模型,所以说，在GradientBoost中，每个新的模型的建立是为了使得之前的模型的残差往梯度下降的方法，与传统的Boosting中关注正确错误的样本加权有着很大的区别。</p><p>在GradientBoosting算法中，关键就是利用损失函数的负梯度方向在当前模型的值作为残差的近似值，进而拟合一棵CART回归树。</p><p>GBDT的会累加所有树的结果，而这种累加是无法通过分类完成的，因此GBDT的树都是CART回归树，而不是分类树（尽管GBDT调整后也可以用于分类但不代表GBDT的树为分类树）。</p><p>GBDT的性能在RF的基础上又有一步提升，因此其优点也很明显，1、它能灵活的处理各种类型的数据；2、在相对较少的调参时间下，预测的准确度较高。</p><p>当然由于它是Boosting，因此基学习器之前存在串行关系，难以并行训练数据。</p><h2 id="XGBoost"><a class="header-anchor" href="#XGBoost">¶</a>XGBoost</h2><p>XGBoost的性能在GBDT上又有一步提升，而其性能也能通过各种比赛管窥一二。坊间对XGBoost最大的认知在于其能够自动地运用CPU的多线程进行并行计算，同时在算法精度上也进行了精度的提高。</p><p>由于GBDT在合理的参数设置下，往往要生成一定数量的树才能达到令人满意的准确率，在数据集较复杂时，模型可能需要几千次迭代运算。但是XGBoost利用并行的CPU更好的解决了这个问题。</p><p>其实XGBoost和GBDT的差别也较大，这一点也同样体现在其性能表现上，详见XGBoost与GBDT的区别。</p><ul><li>与GBDT的区别</li></ul><p>传统的GBDT以CART树作为基学习器，XGBoost还支持线性分类器，这个时候XGBoost相当于L1和L2正则化的逻辑斯蒂回归（分类）或者线性回归（回归）；传统的GBDT在优化的时候只用到一阶导数信息，XGBoost则对代价函数进行了二阶泰勒展开，得到一阶和二阶导数；</p><p>XGBoost在代价函数中加入了正则项，用于控制模型的复杂度。从权衡方差偏差来看，它降低了模型的方差，使学习出来的模型更加简单，放置过拟合，这也是XGBoost优于传统GBDT的一个特性；shrinkage（缩减），相当于学习速率（XGBoost中的eta）。XGBoost在进行完一次迭代时，会将叶子节点的权值乘上该系数，主要是为了削弱每棵树的影响，让后面有更大的学习空间。（GBDT也有学习速率）；</p><p>列抽样。XGBoost借鉴了随机森林的做法，支持列抽样，不仅防止过 拟合，还能减少计算；</p><p>对缺失值的处理。对于特征的值有缺失的样本，XGBoost还可以自动 学习出它的分裂方向；</p><p>XGBoost工具支持并行。Boosting不是一种串行的结构吗？怎么并行的？注意XGBoost的并行不是tree粒度的并行，XGBoost也是一次迭代完才能进行下一次迭代的（第t次迭代的代价函数里包含了前面t-1次迭代的预测值）。XGBoost的并行是在特征粒度上的。我们知道，决策树的学习最耗时的一个步骤就是对特征的值进行排序（因为要确定最佳分割点），XGBoost在训练之前，预先对数据进行了排序，然后保存为block结构，后面的迭代 中重复地使用这个结构，大大减小计算量。这个block结构也使得并行成为了可能，在进行节点的分裂时，需要计算每个特征的增益，最终选增益最大的那个特征去做分裂，那么各个特征的增益计算就可以开多线程进行。</p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;树模型以决策树为基本原型。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://blog.kleon.space/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习" scheme="https://blog.kleon.space/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="推荐系统" scheme="https://blog.kleon.space/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
