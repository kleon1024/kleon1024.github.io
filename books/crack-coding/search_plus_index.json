{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Cracking the coding interview. "},"concurrency/concurrency.html":{"url":"concurrency/concurrency.html","title":"Concurrency","keywords":"","body":"Concurrency Concurrency involves multi-threading, coroutine, lock and atomic operations. First, explain how process, thread and coroutine work and are implemented in different operating systems and languages. Process Thread Couroutine Locks Atomic "},"linked-list/linked-list.html":{"url":"linked-list/linked-list.html","title":"Linked List","keywords":"","body":"Linked List Linked List is a list of uncontigous memory blocks. Singly Linked List Singly linked list has a pointer next pointing to the successor of the current node in the linked list. G A A B B B --> A->B next C C C --> B->C next null null null --> C->null next Traversion We can traverse through the linked list using a pointer. G head head A A A --> head->A B B B --> A->B next C C C --> B->C next null null null --> C->null next Reversion We can use three pointer to reverse the order of the linked list. cur, pre := head, nil for cur.Next != nil { cur, cur.Next, pre = cur.Next, pre, cur } Before G cur cur A A A --> cur->A B B B --> A->B pre pre cur --> null2 null null2 --> pre->null2 A --> C C C --> B->C next null null null --> C->null next After G null2 null null2 --> pre pre pre --> A A A --> null2->A cur cur B B B --> cur->B C C C --> B->C next cur --> A --> pre->A B --> null null null --> C->null next Nth node from the end To find the Nth node from the tail of the linked list, we can use two pointers. First move the faster pointer N steps and then move both pointers until the faster pointer reach the end of the linked list. This can save us one time of full traversion. slow, fast := head, head for i := 0; i Double Linked List Double linked list has another pointer prev pointing to the predecessor of the current node as well. G head head head --> nullh null nullh --> tmp --> A A A --> head->A tail tail tail --> tmpt --> C C C --> tail->C nullt null nullt --> B B B --> A->B next B --> B --> A->B prev nullt --> C->nullt next nullt --> nullt --> C->nullt prev A --> nullh->A next A --> A --> nullh->A prev C --> B->C next C --> C --> B->C prev Circular Linked List The head and tail of a circular linked list are linked together. G A A B B B --> A->B C C C --> B->C D D D --> C->D A --> D->A "},"concurrency/load-balancer.html":{"url":"concurrency/load-balancer.html","title":"Load Balancer","keywords":"","body":"Load Balancer Strategy Suppose you are implementing the load balancing strategy for a nginx-liked web server. Given a list of ip [1, 2, 3], return the next round-robined result. Basic Version At the first glance, we can use a counter to track the number of the next ip. package main import \"fmt\" func main() { \tips := []int{1, 2, 3} \tlb := NewLB(ips) \tfor i := 0; i lb.go Concurrency Version We could use a mutex lock to protect the counter. package main import ( \t\"fmt\" \t\"sync\" ) func main() { \tips := []int{1, 2, 3} \tlb := NewLB(ips) \twg := &sync.WaitGroup{} \tfor j := 0; j lb-con.go Grouped Ips Follow-Up: Suppose ips are grouped. e.g. A: [1, 2, 3], B: [1, 4, 5]. Get the next round-robined result for the specified group combination. Input A means selecting from the group A. Input B means select from the group B. Input AB means select from the intersection of group A and B. Empty means select from all ips. "}}