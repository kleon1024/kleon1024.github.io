{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Cracking the coding interview. "},"linked-list/merge-lists.html":{"url":"linked-list/merge-lists.html","title":"Merge Lists","keywords":"","body":"Merge Lists Basic operation of merging two or more linked list. Merge Two Sorted Lists lc21 Time Complexity: O(N) Space Complexity: O(N) Merge k Sorted Lists lc23 Assuming N(n*k) is the total number of nodes, n is the size of each linked list, and k is the total number of linked lists. Time Complexity: O(Nlogk) or O(nklogk) Space Complexity: O(N) or O(nk) "},"linked-list/reverse-list.html":{"url":"linked-list/reverse-list.html","title":"Reverse List","keywords":"","body":"Reserve List Reverse Linked List lc206 Reverse Linked List II lc92 Reverse Nodes in k-Group lc25 Reverse Nodes in Even Length Groups lc2074 "},"hash-table/bloom-filter.html":{"url":"hash-table/bloom-filter.html","title":"Bloom Filter","keywords":"","body":"Bloom Filter "},"concurrency/concurrency.html":{"url":"concurrency/concurrency.html","title":"Concurrency","keywords":"","body":"Concurrency Concurrency involves multi-threading, coroutine, lock and atomic operations. First, explain how process, thread and coroutine work and are implemented in different operating systems and languages. Process Thread Couroutine Locks Atomic "},"hash-table/hash-table.html":{"url":"hash-table/hash-table.html","title":"Hash Table","keywords":"","body":"Hash Table Hash table is a data structure using a small amount of space to store the values which in a large space. The access time is constant. G Hash function x % 2 h 0 1 2 3 4 5 6 7 l 0 1 l --> h:0->l:0 l --> h:1->l:1 l --> h:2->l:0 l --> h:3->l:1 l --> h:4->l:0 l --> h:5->l:1 l --> h:6->l:0 l --> h:7->l:1 Hash Function Hash Confliction Progressive Migration Consistant Hashing "},"linked-list/linked-list.html":{"url":"linked-list/linked-list.html","title":"Linked List","keywords":"","body":"Linked List Linked List is a list of uncontigous memory blocks. Singly Linked List Singly linked list has a pointer next pointing to the successor of the current node in the linked list. G A A B B B --> A->B next C C C --> B->C next null null null --> C->null next Traversion We can traverse through the linked list using a pointer. G head head A A A --> head->A B B B --> A->B next C C C --> B->C next null null null --> C->null next Reversion We can use three pointer to reverse the order of the linked list. cur, pre := head, nil for cur.Next != nil { cur, cur.Next, pre = cur.Next, pre, cur } Before G cur cur A A A --> cur->A B B B --> A->B pre pre cur --> null2 null null2 --> pre->null2 A --> C C C --> B->C next null null null --> C->null next After G null2 null null2 --> pre pre pre --> A A A --> null2->A cur cur B B B --> cur->B C C C --> B->C next cur --> A --> pre->A B --> null null null --> C->null next Nth node from the end To find the Nth node from the tail of the linked list, we can use two pointers. First move the faster pointer N steps and then move both pointers until the faster pointer reach the end of the linked list. This can save us one time of full traversion. slow, fast := head, head for i := 0; i Doubly Linked List Doubly linked list has another pointer prev pointing to the predecessor of the current node as well. G head head head --> nullh null nullh --> tmp --> A A A --> head->A tail tail tail --> tmpt --> C C C --> tail->C nullt null nullt --> B B B --> A->B next B --> B --> A->B prev nullt --> C->nullt next nullt --> nullt --> C->nullt prev A --> nullh->A next A --> A --> nullh->A prev C --> B->C next C --> C --> B->C prev Circular Linked List The head and tail of a circular linked list are linked together. G A A B B B --> A->B C C C --> B->C D D D --> C->D A --> D->A "},"concurrency/load-balancer.html":{"url":"concurrency/load-balancer.html","title":"Load Balancer","keywords":"","body":"Load Balancer Strategy Suppose you are implementing the load balancing strategy for a nginx-liked web server. Given a list of ip [1, 2, 3], return the next round-robined result. Basic Version At the first glance, we can use a counter to track the number of the next ip. package main import \"fmt\" func main() { \tips := []int{1, 2, 3} \tlb := NewLB(ips) \tfor i := 0; i lb.go Concurrency Version We could use a mutex lock to protect the counter. package main import ( \t\"fmt\" \t\"sync\" ) func main() { \tips := []int{1, 2, 3} \tlb := NewLB(ips) \twg := &sync.WaitGroup{} \tfor j := 0; j lb-con.go Grouped Ips Follow-Up: Suppose ips are grouped. e.g. A: [1, 2, 3], B: [1, 4, 5]. Get the next round-robined result for the specified group combination. Input A means selecting from the group A. Input B means select from the group B. Input AB means select from the intersection of group A and B. Empty means select from all ips. "}}