{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Cracking the coding interview. "},"array/array.html":{"url":"array/array.html","title":"Array","keywords":"","body":"Array An array is a piece of data continously spreaded which commonly used to save data with preallocated space or known size. A dynamic array, also called vector, slice, handled the expansion of the array with pre-defined threshold. Sort Bubble Sort The basic idea of bubble sort is: Start from the first two element, compare and swap them until all elements are compared. Repeat 1 but each time the start position adds one. Quick Sort The basic idea of quick sort is: Select the first or the last element of to-be-sorted array as a pivot. Compare and swap the rest elements until the elements reside on the left of the pivot are less than the pivot and the elements reside on the right of the pivot are greater than the pivot. sort the left and right subarray reside on both side of the pivot. Reverse Double Pointer Binary Search "},"stack/stack.html":{"url":"stack/stack.html","title":"Stack","keywords":"","body":"Stack A stack is a linear data structure only access the data from one side, which operation is also known as first in last out (FILO). "},"queue/queue.html":{"url":"queue/queue.html","title":"Queue","keywords":"","body":"Queue A queue is a linear data structure only write (push) the data from one side but read (pop) the data from the other side, which operation is also known as first in last out (FIFO). A dequeue is a queue which push and pop data from both sides. "},"linked-list/merge-lists.html":{"url":"linked-list/merge-lists.html","title":"Merge Lists","keywords":"","body":"Merge Lists Basic operation of merging two or more linked list. Merge Two Sorted Lists 游릭lc21 Time Complexity: O(N) Space Complexity: O(N) Merge k Sorted Lists 游댮lc23 Assuming N(n*k) is the total number of nodes, n is the size of each linked list, and k is the total number of linked lists. Time Complexity: O(Nlogk) or O(nklogk) Space Complexity: O(N) or O(nk) "},"tree/tree.html":{"url":"tree/tree.html","title":"Tree","keywords":"","body":"Tree A tree is used to represent a hierarchical tree structure with a set of connected nodes. Each node in the tree can be connected to many children (depending on the type of tree), but must be connected to exactly one parent, except for the root node, which has no parent. wiki) Classification Binary Tree Complete Binary Tree Perfect Binary Tree Balanced Tree (B-Tree) Binary Search Tree AVL Tree Red Black Tree B+ Tree MySQL B* Tree Heap Trie, Prefix Tree, Digital Tree Traversal Pre-order Post-order Mid-order Layer-order Reconstruction "},"hash-table/bloom-filter.html":{"url":"hash-table/bloom-filter.html","title":"Bloom Filter","keywords":"","body":"Bloom Filter "},"hash-table/cache.html":{"url":"hash-table/cache.html","title":"Cache","keywords":"","body":"Cache Cache is a in-memory data structure to reuse accessed data from database, disk or some other low-speed sources. LRU Remove the least recently used element when cache is full. We can combine a hash-map and a linked-list to implement a cache with O(1) time complexity. LFU Remove the least frequently used element when cache is full. We can combine a hash-map and a heap to implement a cache with O(logN) time complexity. Or we can combine two doubly linked list to implement a cache with O(1) time complexity. Redis "},"recursion/recursion.html":{"url":"recursion/recursion.html","title":"Recursion","keywords":"","body":"Recursion "},"greedy/greedy.html":{"url":"greedy/greedy.html","title":"Greedy","keywords":"","body":"Greedy "},"dp/dp.html":{"url":"dp/dp.html","title":"Dynamic Programming","keywords":"","body":"Dynamic Programming "},"concurrency/concurrency.html":{"url":"concurrency/concurrency.html","title":"Concurrency","keywords":"","body":"Concurrency Concurrency involves multi-threading, coroutine, lock and atomic operations. First, explain how process, thread and coroutine work and are implemented in different operating systems and languages. Process Thread Couroutine Locks Atomic "},"array/maximum.html":{"url":"array/maximum.html","title":"Find Maximum","keywords":"","body":"Fint the Maximum LC363 Max Sum of Rectangle No Larger Than K 游댮lc363 brute force Gofunc maxSumSubmatrix(matrix [][]int, k int) int { n, m := len(matrix), len(matrix[0]) maxSum := math.MinInt for row := 0; row b { return a } return b } "},"array/rotate.html":{"url":"array/rotate.html","title":"Rotate","keywords":"","body":"Rotate LC48. Rotate Image 游리lc48 A common method to solve the image rotation problem. /* * clockwise rotate * first reverse up to down, then swap the symmetry * 1 2 3 7 8 9 7 4 1 * 4 5 6 => 4 5 6 => 8 5 2 * 7 8 9 1 2 3 9 6 3 */ /* * anticlockwise rotate * first reverse left to right, then swap the symmetry * 1 2 3 3 2 1 3 6 9 * 4 5 6 => 6 5 4 => 2 5 8 * 7 8 9 9 8 7 1 4 7 */ GoJavaRustfunc rotate(matrix [][]int) { for i, j := 0, len(matrix)-1; i void rotate(vector > &matrix) { reverse(matrix.begin(), matrix.end()); for (int i = 0; i impl Solution { pub fn rotate(matrix: &mut Vec>) { matrix.reverse(); for i in 0..matrix.len() { for j in i+1 .. matrix[i].len() { let tmp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = tmp; } } } } "},"linked-list/reverse-list.html":{"url":"linked-list/reverse-list.html","title":"Reverse List","keywords":"","body":"Reserve List Reverse Linked List 游릭lc206 Reverse Linked List II 游리lc92 Reverse Nodes in k-Group 游댮lc25 Reverse Nodes in Even Length Groups 游리lc2074 "},"linked-list/numbers.html":{"url":"linked-list/numbers.html","title":"Numbers","keywords":"","body":"Numbers 2. Add Two Numbers Basic decimal addition. GoRust/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { head := &ListNode{} current := head carry := 0 for carry > 0 || l1 != nil || l2 != nil { if l1 != nil { carry += l1.Val l1 = l1.Next } if l2 != nil { carry += l2.Val l2 = l2.Next } current.Next = &ListNode{ Val: carry % 10, } carry /= 10 current = current.Next } return head.Next } // Definition for singly-linked list. // #[derive(PartialEq, Eq, Clone, Debug)] // pub struct ListNode { // pub val: i32, // pub next: Option> // } // // impl ListNode { // #[inline] // fn new(val: i32) -> Self { // ListNode { // next: None, // val // } // } // } impl Solution { pub fn add_two_numbers(l1: Option>, l2: Option>) -> Option> { let mut l1 = l1.clone(); let mut l2 = l2.clone(); let mut head = Box::new(ListNode::new(0)); let mut carry = 0; let mut current = &mut head; while carry > 0 || l1.is_some() || l2.is_some() { if let Some(node) = l1 { carry += node.val; l1 = node.next; } if let Some(node) = l2 { carry += node.val; l2 = node.next; } current.next = Some(Box::new(ListNode::new(carry % 10))); carry /= 10; current = current.next.as_mut().unwrap(); } return head.next; } } "},"hash-table/hash-table.html":{"url":"hash-table/hash-table.html","title":"Hash Table","keywords":"","body":"Hash Table Hash table is a data structure using a small amount of space to store the values which in a large space. The access time is constant. G Hash function x % 2 h 0 1 2 3 4 5 6 7 l 0 1 l --> h:0->l:0 l --> h:1->l:1 l --> h:2->l:0 l --> h:3->l:1 l --> h:4->l:0 l --> h:5->l:1 l --> h:6->l:0 l --> h:7->l:1 Hash Function Hash Confliction Progressive Migration Consistant Hashing "},"hash-table/sum.html":{"url":"hash-table/sum.html","title":"Sum","keywords":"","body":"Sum 1. Two Sum 游릭lc1 The basic idea is using a hash map to store the {v, i}. If (target - v) is in the map, if means the we find the results with current index and the previous index. GoRustfunc twoSum(nums []int, target int) []int { m := map[int]int{} for i, n := range nums { if v, ok := m[target - n]; ok { return []int{v, i} } m[n] = i } return []int{} } use std::collections::HashMap; impl Solution { pub fn two_sum(nums: Vec, target: i32) -> Vec { let mut m: HashMap = HashMap::new(); for (i, v) in nums.iter().enumerate() { match m.get(&(target - v)) { Some(i2) => return vec![i as i32, *i2], None => m.insert(*v, i as i32), }; } vec![] } } 167. Two Sum II - Input Array Is Sorted 游리lc167 We can use the solution from Two Sum, or we can just use two pointers to get close to the target. GoRustfunc twoSum(numbers []int, target int) []int { l, r := 0, len(numbers) - 1 for l impl Solution { pub fn two_sum(numbers: Vec, target: i32) -> Vec { let mut left = 0; let mut right = numbers.len() - 1; while left LC1546 Maximum Number of Non-Overlapping Subarrays With Sum Equals Target 游리lc1546 The basic idea is using a map to store the prefix sum and the target = prefixSum[0...i] - prefixSum[0...j] use a map to store prefixSum and it's rightMost index initialize sum with O, available Index with -1, which means index bigger than -1 are unused initialize map with {0:-1}, which means the initial sum is 0 for each nums[il in the array: update prefixSum with nums[il Let's say there's a subarray from index j to current index i whose sum is target, prefixSum[0...i] - prefixSum[0...j] = target, which means prefixSum - remain = target if remain = prefixSum-target exists, and it's starting index is bigger than availablelndex, it means a valid subarray exists: res++ update availablelndex with i, because subarray from j to i is used always update map with prefixSum and i, so that it is guaranteed that the starting index j above is the rightMost index for prefixSum so that the subarray is as short as possible return res in the end GoJavafunc maxNonOverlapping(nums []int, target int) int { m := map[int]int{} prefixSum, availableIdx, res := 0, -1, 0 m[0] = -1 for i := 0; i = availableIdx { res++ availableIdx = i } } m[prefixSum] = i } return res } class Solution { public int maxNonOverlapping(int[] nums, int target) { Map map= new HashMap<>(); int prefixSum=0, availableIdx=-1, res=0; map.put(0,-1); for (int i=0; i=availableIdx){ res++; availableIdx=i; } map.put(prefixSum, i); } return res; } } "},"linked-list/linked-list.html":{"url":"linked-list/linked-list.html","title":"Linked List","keywords":"","body":"Linked List Linked List is a list of uncontigous memory blocks. Singly Linked List Singly linked list has a pointer next pointing to the successor of the current node in the linked list. G A A B B B --> A->B next C C C --> B->C next null null null --> C->null next Traversion We can traverse through the linked list using a pointer. G head head A A A --> head->A B B B --> A->B next C C C --> B->C next null null null --> C->null next Reversion We can use three pointer to reverse the order of the linked list. cur, pre := head, nil for cur.Next != nil { cur, cur.Next, pre = cur.Next, pre, cur } Before G cur cur A A A --> cur->A B B B --> A->B pre pre cur --> null2 null null2 --> pre->null2 A --> C C C --> B->C next null null null --> C->null next After G null2 null null2 --> pre pre pre --> A A A --> null2->A cur cur B B B --> cur->B C C C --> B->C next cur --> A --> pre->A B --> null null null --> C->null next Nth node from the end To find the Nth node from the tail of the linked list, we can use two pointers. First move the faster pointer N steps and then move both pointers until the faster pointer reach the end of the linked list. This can save us one time of full traversion. slow, fast := head, head for i := 0; i Doubly Linked List Doubly linked list has another pointer prev pointing to the predecessor of the current node as well. G head head head --> nullh null nullh --> tmp --> A A A --> head->A tail tail tail --> tmpt --> C C C --> tail->C nullt null nullt --> B B B --> A->B next B --> B --> A->B prev nullt --> C->nullt next nullt --> nullt --> C->nullt prev A --> nullh->A next A --> A --> nullh->A prev C --> B->C next C --> C --> B->C prev Circular Linked List The head and tail of a circular linked list are linked together. G A A B B B --> A->B C C C --> B->C D D D --> C->D A --> D->A "},"concurrency/load-balancer.html":{"url":"concurrency/load-balancer.html","title":"Load Balancer","keywords":"","body":"Load Balancer Strategy Suppose you are implementing the load balancing strategy for a nginx-liked web server. Given a list of ip [1, 2, 3], return the next round-robined result. Basic Version At the first glance, we can use a counter to track the number of the next ip. GoLang C++ package main import \"fmt\" func main() { \tips := []int{1, 2, 3} \tlb := NewLB(ips) \tfor i := 0; i lb.go package main import ( \t\"fmt\" \t\"sync\" ) func main() { \tips := []int{1, 2, 3} \tlb := NewLB(ips) \twg := &sync.WaitGroup{} \tfor j := 0; j lb-con.go Concurrency Version We could use a mutex lock to protect the counter. package main import ( \t\"fmt\" \t\"sync\" ) func main() { \tips := []int{1, 2, 3} \tlb := NewLB(ips) \twg := &sync.WaitGroup{} \tfor j := 0; j lb-con.go Grouped Ips Follow-Up: Suppose ips are grouped. e.g. A: [1, 2, 3], B: [1, 4, 5]. Get the next round-robined result for the specified group combination. Input A means selecting from the group A. Input B means select from the group B. Input AB means select from the intersection of group A and B. Empty means select from all ips. "}}