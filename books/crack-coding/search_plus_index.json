{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Cracking the coding interview. "},"concurrency/concurrency.html":{"url":"concurrency/concurrency.html","title":"Concurrency","keywords":"","body":"Concurrency Concurrency involves multi-threading, coroutine, lock and atomic operations. First, explain how process, thread and coroutine work and are implemented in different operating systems and languages. Process Thread Couroutine Locks Atomic "},"concurrency/load-balancer.html":{"url":"concurrency/load-balancer.html","title":"Load Balancer","keywords":"","body":"Load Balancer Strategy Suppose you are implementing the load balancing strategy for a nginx-liked web server. Given a list of ip [1, 2, 3], return the next round-robined result. Basic Version At the first glance, we can use a counter to track the number of the next ip. package main import \"fmt\" func main() { \tips := []int{1, 2, 3} \tlb := NewLB(ips) \tfor i := 0; i Concurrency Version We could use a mutex lock to protect the counter. package main import ( \t\"fmt\" \t\"sync\" ) func main() { \tips := []int{1, 2, 3} \tlb := NewLB(ips) \twg := &sync.WaitGroup{} \tfor j := 0; j Grouped Ips Follow-Up: Suppose ips are grouped. e.g. A: [1, 2, 3], B: [1, 4, 5]. Get the next round-robined result for the specified group combination. Input A means selecting from the group A. Input B means select from the group B. Input AB means select from the intersection of group A and B. Empty means select from all ips. "}}