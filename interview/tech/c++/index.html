<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>Tech - C++ · KLEON</title><meta name="description" content="Q &amp;amp; A of C++ [1].
C++ is a powerful and all-purpose programming tool developed by Bjarne Stroustrup at Bell Labs. This language is an extension of"><meta name="og:description" content="Q &amp;amp; A of C++ [1].
C++ is a powerful and all-purpose programming tool developed by Bjarne Stroustrup at Bell Labs. This language is an extension of"><meta name="twitter:site" content="KLEON"><meta name="twitter:title" content="Tech - C++"><meta name="twitter:card" content="summary"><meta name="keywords" content=""><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/github.min.css"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.10.2/katex.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 6.2.0"></head><body><div id="stage" class="container"><div class="row"><div id="side-bar" class="col-sm-3 col-xs-12 side-container invisible"><div class="vertical-text site-title"><h3 tabindex="-1" class="site-title-small"><a href="/" class="a-title"></a></h3><h1 tabindex="-1" class="site-title-large"><a href="/" class="a-title">吹拉弹唱</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div id="site-nav" class="site-title-links"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li><li><a href="/categories">Categories</a></li><li><a href="/tags">Tags</a></li><li><a href="/books">Books</a></li><li><a href="/googlebe23cb0bc55fc412.html"></a></li><li><a href="/books/index.html"></a></li><li><a href="/about/index.html"></a></li><li class="soc"><a href="https://github.com/kleon1024" target="_blank" rel="noopener noreferrer" aria-label="Github"><i class="fa fa-github">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2022&nbsp;<a target="_blank" href="https://blog.kleon.space" rel="noopener noreferrer">Kleon</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div id="main-container" class="col-sm-9 col-xs-12 main-container invisible"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>Tech - C++</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2022-04-29</span><span class="date meta-item">Updated at&nbsp;2022-05-04</span><span class="meta-item"><i class="fa fa-folder"></i><span>&nbsp;</span><a href="/categories/interview/" title="interview" class="a-tag">interview</a><span>&nbsp;</span></span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a href="/tags/interview/" title="interview" class="a-tag">interview</a><span>&nbsp;</span><a href="/tags/tech/" title="tech" class="a-tag">tech</a><span>&nbsp;</span></span></p><p class="post-abstract"><p>Q &amp; A of C++ <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>.</p>
<p>C++ is a powerful and all-purpose programming tool developed by Bjarne Stroustrup at Bell Labs. This language is an extension of C and is by far one of the fastest object-oriented programming languages. C++ is super popular because of its high speed and compatibility.</p>
<div class="toc">
<!-- toc -->
<ul>
<li><a href="#basics">Basics</a>
<ul>
<li><a href="#what-are-the-different-data-types-present-in-c">What are the different data types present in C++?</a></li>
<li><a href="#what-is-the-difference-between-c-and-c">What is the difference between C and C++?</a></li>
<li><a href="#what-are-class-and-object-in-c">What are class and object in C++?</a></li>
<li><a href="#what-is-the-difference-between-struct-and-class">What is the difference between struct and class?</a></li>
<li><a href="#what-is-operator-overloading">What is operator overloading?</a></li>
<li><a href="#what-is-polymorphism-in-c">What is polymorphism in C++?</a></li>
<li><a href="#explain-constructor-in-c">Explain constructor in C++</a></li>
<li><a href="#tell-me-about-virtual-function">Tell me about virtual function</a></li>
<li><a href="#compare-compile-time-polymorphism-and-runtime-polymorphism">Compare compile time polymorphism and Runtime polymorphism</a></li>
<li><a href="#what-do-you-know-about-friend-class-and-friend-function">What do you know about friend class and friend function?</a></li>
<li><a href="#what-are-the-c-access-specifiers">What are the C++ access specifiers?</a></li>
<li><a href="#define-inline-function">Define inline function</a></li>
<li><a href="#what-is-a-reference-in-c">What is a reference in C++?</a></li>
<li><a href="#what-do-you-mean-by-abstraction-in-c">What do you mean by abstraction in C++?</a></li>
<li><a href="#is-deconstructor-overloading-possible-if-yes-then-explain-and-if-no-then-why">Is deconstructor overloading possible? If yes then explain and if no then why?</a></li>
<li><a href="#what-do-you-mean-by-call-by-value-and-call-by-reference">What do you mean by call by value and call by reference?</a></li>
<li><a href="#what-is-an-abstract-class-and-when-do-you-use-it">What is an abstract class and when do you use it?</a></li>
<li><a href="#what-are-destructors-in-c">What are destructors in C++?</a></li>
<li><a href="#what-are-the-static-members-and-static-member-functions">What are the static members and static member functions?</a></li>
<li><a href="#explain-inheritance">Explain inheritance</a></li>
<li><a href="#how-do-you-allocate-and-deallocate-memory-in-c">How do you allocate and deallocate memory in C++?</a></li>
<li><a href="#what-is-this-pointer-in-c">What is this pointer in C++?</a></li>
</ul>
</li>
<li><a href="#advanced">Advanced</a>
<ul>
<li><a href="#what-is-a-copy-constructor">What is a copy constructor?</a></li>
<li><a href="#what-is-the-difference-between-shallow-copy-and-deep-copy">What is the difference between shallow copy and deep copy?</a></li>
<li><a href="#what-is-the-difference-between-virtual-functions-and-pure-virtual-functions">What is the difference between virtual functions and pure virtual functions?</a></li>
<li><a href="#if-class-d-is-derived-from-a-base-class-b-when-creating-an-object-of-type-d-in-what-order-would-the-constructors-of-these-classes-get-called">If class D is derived from a base class B. When creating an object of type D in what order would the constructors of these classes get called?</a></li>
<li><a href="#can-we-call-a-virtual-function-from-a-constructor">Can we call a virtual function from a constructor?</a></li>
<li><a href="#what-are-void-pointers">What are void pointers?</a></li>
<li><a href="#what-is-const-keyword-used-for">What is const keyword used for?</a></li>
<li><a href="#what-is-volatile">What is volatile?</a></li>
<li><a href="#how-virtual-function-is-achieved">How virtual function is achieved?</a></li>
<li><a href="#what-s-the-common-bug-in-c">What’s the common bug in C++?</a></li>
<li><a href="#how-to-enhance-the-safety-of-pointer">How to enhance the safety of pointer?</a></li>
<li><a href="#difference-between-shared-ptr-unique-ptr-weak-ptr">Difference between shared_ptr, unique_ptr, weak_ptr.</a></li>
<li><a href="#what-is-virtual-inheritance">What is virtual inheritance?</a></li>
<li><a href="#what-is-std-move">What is std::move?</a></li>
<li><a href="#what-is-the-difference-between-static-cast-const-cast-reinterpret-cast-dynamic-cast-bad-cast">What is the difference between static_cast, const_cast, reinterpret_cast, dynamic_cast, bad_cast?</a></li>
<li><a href="#what-are-the-common-stl-what-are-the-underlying-data-structures-of-these-stl">What are the common STL? What are the underlying data structures of these STL?</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div>
<h1><a href="#basics" class="header-anchor">#</a><span id="basics"> Basics</span></h1>
<h2><a href="#what-are-the-different-data-types-present-in-c" class="header-anchor">#</a><span id="what-are-the-different-data-types-present-in-c"> What are the different data types present in C++?</span></h2>
<ul>
<li>Primitive Datatype(basic datatype). Example- char, short, int, float, long, double, bool, etc.</li>
<li>Derived datatype. Example- array, pointer, etc.</li>
<li>Enumeration. Example- enum</li>
<li>User-defined data types. Example- structure, class, etc.</li>
</ul>
<h2><a href="#what-is-the-difference-between-c-and-c" class="header-anchor">#</a><span id="what-is-the-difference-between-c-and-c"> What is the difference between C and C++?</span></h2>
<td> C </td><td> C++ </td><td>
</td><td>---</td><td>-----</td><td>
</td><td>C is a procedure-oriented programming language. </td><td> C++ is an object-oriented programming language. </td><td>
</td><td>C does not support data hiding. </td><td> Data is hidden by encapsulation to ensure that data structures and operators are used as intended. </td><td>
</td><td>C is a subset of C++ </td><td> C++ is a superset of C. </td><td>
</td><td>Function and operator overloading are not supported in C </td><td> Function and operator overloading is supported in C++ </td><td>
</td><td>Namespace features are not present in C </td><td> Namespace is used by C++, which avoids name collisions. </td><td>
</td><td>Functions can not be defined inside structures. </td><td> Functions can be defined inside structures. </td><td>
</td><td>*calloc()* and *malloc()* functions are used for memory allocation and free() function is used for memory deallocation. </td><td> *new* operator is used for memory allocation and *delete* operator is used for memory deallocation. </td><td>
<h2><a href="#what-are-class-and-object-in-c" class="header-anchor">#</a><span id="what-are-class-and-object-in-c"> What are class and object in C++?</span></h2>
<p>A class is a user-defined data type that has data members and member functions. Data members are the data variables and member functions are the functions that are used to perform operations on these variables.</p>
<p>An object is an instance of a class. Since a class is a user-defined data type so an object can also be called a variable of that data type.</p>
<p>A class is defined as:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">private</span>:<br> <span class="hljs-type">int</span> data;<br><span class="hljs-keyword">public</span>:<br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2><a href="#what-is-the-difference-between-struct-and-class" class="header-anchor">#</a><span id="what-is-the-difference-between-struct-and-class"> What is the difference between struct and class?</span></h2>
<p>In C++ a structure is the same as a class except for a few differences like security. The difference between struct and class are given below:</p>
</td><td> Structure                                                                                               </td><td> Class                                                         </td><td>
</td><td>-----------                                                                                              </td><td>-------                                                        </td><td>
</td><td> Members of the structure are public by default.                                                         </td><td> Members of the class are private by default.                  </td><td>
</td><td> When deriving a struct from a class/struct, default access specifiers for base class/struct are public. </td><td> When deriving a class, default access specifiers are private. </td><td>
<h2><a href="#what-is-operator-overloading" class="header-anchor">#</a><span id="what-is-operator-overloading"> What is operator overloading?</span></h2>
<p>Operator Overloading is a very essential element to perform the operations on user-defined data types. By operator overloading we can modify the default meaning to the operators like +, -, *, /, &lt;=, etc.</p>
<p>For example:</p>
<p>The following code is for adding two complex number using operator overloading-</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span>&#123;<br><span class="hljs-keyword">private</span>:<br> <span class="hljs-type">float</span> r, i;<br><span class="hljs-keyword">public</span>:<br> <span class="hljs-built_in">complex</span>(<span class="hljs-type">float</span> r, <span class="hljs-type">float</span> i)&#123;<br>  <span class="hljs-keyword">this</span>-&gt;r=r;<br>  <span class="hljs-keyword">this</span>-&gt;i=i;<br> &#125;<br><br> <span class="hljs-built_in">complex</span>()&#123;&#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">displaydata</span><span class="hljs-params">()</span></span>&#123;<br>  cout &lt;&lt; <span class="hljs-string">&quot;real part = &quot;</span>&lt;&lt; r &lt;&lt; endl;<br>  cout &lt;&lt; <span class="hljs-string">&quot;imaginary part = &quot;</span> &lt;&lt; i &lt;&lt; endl;<br> &#125;<br><br> complex <span class="hljs-keyword">operator</span>+(complex c)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">complex</span>(r+c.r, i+c.i);<br> &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-function">complex <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)</span></span>;<br>  <span class="hljs-function">complex <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)</span></span>;<br>  complex c=a+b;<br>  c.<span class="hljs-built_in">displaydata</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#what-is-polymorphism-in-c" class="header-anchor">#</a><span id="what-is-polymorphism-in-c"> What is polymorphism in C++?</span></h2>
<p>Polymorphism in simple means having many forms. Its behavior is different in different situations. And this occurs when we have multiple classes that are related to each other by inheritance.</p>
<p>For example, think of a base class called a car that has a method called car brand(). Derived classes of cars could be Mercedes, BMW, Audi - And they also have their own implementation of a cars</p>
<p>The two types of polymorphism in c++ are:</p>
<ul>
<li>Compile Time Polymorphism
<ul>
<li>Method Overload</li>
<li>Operator Overloading</li>
</ul>
</li>
<li>Runtime Polymorphism
<ul>
<li>Virtual Function</li>
<li>Function Overloading</li>
</ul>
</li>
</ul>
<h2><a href="#explain-constructor-in-c" class="header-anchor">#</a><span id="explain-constructor-in-c"> Explain constructor in C++</span></h2>
<p>The constructor is a member function that is executed automatically whenever an object is created. Constructors have the same name as the class of which they are members so that compiler knows that the member function is a constructor. And no return type is used for constructors.</p>
<p>Example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> val;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> x)&#123; <span class="hljs-comment">//one argument constructor</span><br>   val=x;<br>  &#125;<br><br>  <span class="hljs-built_in">A</span>()&#123; <span class="hljs-comment">//zero argument constructor</span><br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br> <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;     <br><br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#tell-me-about-virtual-function" class="header-anchor">#</a><span id="tell-me-about-virtual-function"> Tell me about virtual function</span></h2>
<p>Virtual function is a member function in the base class that you redefine in a derived class. A virtual function is declared using the virtual keyword. When the function is made virtual, C++ determines which function is to be invoked at the runtime based on the type of the object pointed by the base class pointer.</p>
<h2><a href="#compare-compile-time-polymorphism-and-runtime-polymorphism" class="header-anchor">#</a><span id="compare-compile-time-polymorphism-and-runtime-polymorphism"> Compare compile time polymorphism and Runtime polymorphism</span></h2>
<table>
<tr><td> Compile-time polymorphism </td><td> Run time polymorphism </td></tr>
<tr><td> In this method, we would come to know at compile time which method will be called. And the call is resolved by the compiler. </td><td> In this method, we come to know at run time which method will be called. The call is not resolved by the compiler. </td></tr>
<tr><td> It provides fast execution because it is known at the compile time. </td><td> It provides slow execution compared to compile-time polymorphism because it is known at the run time. </td></tr>
<tr><td> It is achieved by function overloading and operator overloading. </td><td> It can be achieved by virtual functions and pointers. </td></tr>
<tr>
<td>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;<br>      <span class="hljs-keyword">return</span> a+b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span>&#123;<br>      <span class="hljs-keyword">return</span> a+b+c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-built_in">add</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-built_in">add</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)&lt;&lt;endl;<br><br><br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</td>
<td>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>     <span class="hljs-keyword">public</span>:<br>          <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;<br>               cout&lt;&lt;<span class="hljs-string">&quot;base &quot;</span>;<br>          &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A&#123;<br>     <span class="hljs-keyword">public</span>:<br>          <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;<br>               cout&lt;&lt;<span class="hljs-string">&quot;derived &quot;</span>;<br>          &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>     A *a=<span class="hljs-keyword">new</span> B;<br>     a-&gt;<span class="hljs-built_in">fun</span>();<br><br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</td>
</tr>
</table>
<h2><a href="#what-do-you-know-about-friend-class-and-friend-function" class="header-anchor">#</a><span id="what-do-you-know-about-friend-class-and-friend-function"> What do you know about friend class and friend function?</span></h2>
<p>A friend class can access private, protected, and public members of other classes in which it is declared as friends.</p>
<p>Like friend class, friend function can also access private, protected, and public members. But, Friend functions are not member functions.</p>
<p>For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> data_a;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> x)&#123;<br>   data_a = x;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">int</span> <span class="hljs-title">fun</span><span class="hljs-params">(A, B)</span></span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>&#123;<br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> data_b;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> x)&#123;<br>   data_b = x;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">int</span> <span class="hljs-title">fun</span><span class="hljs-params">(A, B)</span></span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fun</span><span class="hljs-params">(A a, B b)</span></span>&#123;<br> <span class="hljs-keyword">return</span> a.data_a+b.data_b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br> <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br> <span class="hljs-function">B <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br> cout &lt;&lt; <span class="hljs-built_in">fun</span>(a,b) &lt;&lt; endl;<br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#what-are-the-c-access-specifiers" class="header-anchor">#</a><span id="what-are-the-c-access-specifiers"> What are the C++ access specifiers?</span></h2>
<p>In C++ there are the following access specifiers:</p>
<ul>
<li>Public: All data members and member functions are accessible outside the class.</li>
<li>Protected: All data members and member functions are accessible inside the class and to the derived class.</li>
<li>Private: All data members and member functions are not accessible outside the class.</li>
</ul>
<h2><a href="#define-inline-function" class="header-anchor">#</a><span id="define-inline-function"> Define inline function</span></h2>
<p>If a function is inline, the compiler places a copy of the code of that function at each point where the function is called at compile time. One of the important advantages of using an inline function is that it eliminates the function calling overhead of a traditional function.</p>
<h2><a href="#what-is-a-reference-in-c" class="header-anchor">#</a><span id="what-is-a-reference-in-c"> What is a reference in C++?</span></h2>
<p>A reference is like a pointer. It is another name of an already existing variable. Once a reference name is initialized with a variable, that variable can be accessed by the variable name or reference name both.</p>
<p>For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x=<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> &amp;ref=x;           <span class="hljs-comment">//reference variable</span><br></code></pre></td></tr></table></figure>
<p>If we change the value of ref it will be reflected in x. Once a reference variable is initialized it cannot refer to any other variable. We can declare an array of pointers but an array of references is not possible.</p>
<h2><a href="#what-do-you-mean-by-abstraction-in-c" class="header-anchor">#</a><span id="what-do-you-mean-by-abstraction-in-c"> What do you mean by abstraction in C++?</span></h2>
<p>Abstraction is the process of showing the essential details to the user and hiding the details which we don’t want to show to the user or hiding the details which are irrelevant to a particular user.</p>
<h2><a href="#is-deconstructor-overloading-possible-if-yes-then-explain-and-if-no-then-why" class="header-anchor">#</a><span id="is-deconstructor-overloading-possible-if-yes-then-explain-and-if-no-then-why"> Is deconstructor overloading possible? If yes then explain and if no then why?</span></h2>
<p>No destructor overloading is not possible. Destructors take no arguments, so there’s only one way to destroy an object. That’s the reason destructor overloading is not possible.</p>
<h2><a href="#what-do-you-mean-by-call-by-value-and-call-by-reference" class="header-anchor">#</a><span id="what-do-you-mean-by-call-by-value-and-call-by-reference"> What do you mean by call by value and call by reference?</span></h2>
<p>In call by value method, we pass a copy of the parameter is passed to the functions. For these copied values a new memory is assigned and changes made to these values do not reflect the variable in the main function.<br>
In call by reference method, we pass the address of the variable and the address is used to access the actual argument used in the function call. So changes made in the parameter alter the passing argument.</p>
<h2><a href="#what-is-an-abstract-class-and-when-do-you-use-it" class="header-anchor">#</a><span id="what-is-an-abstract-class-and-when-do-you-use-it"> What is an abstract class and when do you use it?</span></h2>
<p>A class is called an abstract class whose objects can never be created. Such a class exists as a parent for the derived classes. We can make a class abstract by placing a pure virtual function in the class.</p>
<h2><a href="#what-are-destructors-in-c" class="header-anchor">#</a><span id="what-are-destructors-in-c"> What are destructors in C++?</span></h2>
<p>A constructor is automatically called when an object is first created. Similarly when an object is destroyed a function called destructor automatically gets called. A destructor has the same name as the constructor (which is the same as the class name) but is preceded by a tilde.</p>
<p>Example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> val;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> x)&#123;           <br>   val=x;<br>  &#125;<br>  <span class="hljs-built_in">A</span>()&#123;                <br>  &#125;<br>  ~<span class="hljs-built_in">A</span>()&#123;                  <span class="hljs-comment">//destructor</span><br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br> <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;     <br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#what-are-the-static-members-and-static-member-functions" class="header-anchor">#</a><span id="what-are-the-static-members-and-static-member-functions"> What are the static members and static member functions?</span></h2>
<p>When a variable in a class is declared static, space for it is allocated for the lifetime of the program. No matter how many objects of that class have been created, there is only one copy of the static member. So same static member can be accessed by all the objects of that class.</p>
<p>A static member function can be called even if no objects of the class exist and the static function are accessed using only the class name and the scope resolution operator ::</p>
<h2><a href="#explain-inheritance" class="header-anchor">#</a><span id="explain-inheritance"> Explain inheritance</span></h2>
<p>Inheritance is the process of creating new classes, called derived classes, from existing classes. These existing classes are called base classes. The derived classes inherit all the capabilities of the base class but can add new features and refinements of their own.</p>
<h2><a href="#how-do-you-allocate-and-deallocate-memory-in-c" class="header-anchor">#</a><span id="how-do-you-allocate-and-deallocate-memory-in-c"> How do you allocate and deallocate memory in C++?</span></h2>
<p>The new operator is used for memory allocation and deletes operator is used for memory deallocation in C++.</p>
<p>For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> value=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;      <span class="hljs-comment">//allocates memory for storing 1 integer</span><br><span class="hljs-keyword">delete</span> value;              <span class="hljs-comment">// deallocates memory taken by value</span><br><br><span class="hljs-type">int</span> *arr=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];      <span class="hljs-comment">//allocates memory for storing 10 int</span><br><span class="hljs-keyword">delete</span> []arr;                <span class="hljs-comment">// deallocates memory occupied by arr</span><br></code></pre></td></tr></table></figure>
<h2><a href="#what-is-this-pointer-in-c" class="header-anchor">#</a><span id="what-is-this-pointer-in-c"> What is this pointer in C++?</span></h2>
<p>The member functions of every object have a pointer named this, which points to the object itself. The value of this is set to the address of the object for which it is called. It can be used to access the data in the object it points to.</p>
<p>Example</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> value;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setvalue</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>   <span class="hljs-keyword">this</span>-&gt;value=x; <br>  &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br> A a;<br> a.<span class="hljs-built_in">setvalue</span>(<span class="hljs-number">5</span>);<br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1><a href="#advanced" class="header-anchor">#</a><span id="advanced"> Advanced</span></h1>
<h2><a href="#what-is-a-copy-constructor" class="header-anchor">#</a><span id="what-is-a-copy-constructor"> What is a copy constructor?</span></h2>
<p>A copy constructor is a member function that initializes an object using another object of the same class.</p>
<p>Example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-type">int</span> x,y;<br><span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)&#123;<br> <span class="hljs-keyword">this</span>-&gt;x=x;<br> <span class="hljs-keyword">this</span>-&gt;y=y;<br>&#125;<br><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-function">A <span class="hljs-title">a1</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)</span></span>;<br>A a2=a1;     <span class="hljs-comment">//default copy constructor is called</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>We can define our copy constructor. If we don’t define a copy constructor then the default copy constructor is called.</p>
<h2><a href="#what-is-the-difference-between-shallow-copy-and-deep-copy" class="header-anchor">#</a><span id="what-is-the-difference-between-shallow-copy-and-deep-copy"> What is the difference between shallow copy and deep copy?</span></h2>
<p>The difference between shallow copy and a deep copy is given below:</p>
<table>
<thead>
<tr>
<th>Shallow Copy</th>
<th>Deep Copy</th>
</tr>
</thead>
<tbody>
<tr>
<td>Shallow copy stores the references of objects to the original memory address.</td>
<td>Deep copy makes a new and separate copy of an entire object with its unique memory address.</td>
</tr>
<tr>
<td>Shallow copy is faster.</td>
<td>Deep copy is comparatively slower.</td>
</tr>
<tr>
<td>Shallow copy reflects changes made to the new/copied object in the original object.</td>
<td>Deep copy doesn’t reflect changes made to the new/copied object in the original object</td>
</tr>
</tbody>
</table>
<h2><a href="#what-is-the-difference-between-virtual-functions-and-pure-virtual-functions" class="header-anchor">#</a><span id="what-is-the-difference-between-virtual-functions-and-pure-virtual-functions"> What is the difference between virtual functions and pure virtual functions?</span></h2>
<p>A virtual function is a member function in the base class that you redefine in a derived class. It is declared using the virtual keyword.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">base</span>&#123;<br><span class="hljs-keyword">public</span>:<br> <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;<br><br> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>A pure virtual function is a function that has no implementation and is declared by assigning 0. It has no body.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">base</span>&#123;<br><span class="hljs-keyword">public</span>:<br> <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>Here, = sign has got nothing to do with the assignment, and value 0 is not assigned to anything. It is used to simply tell the compiler that a function will be pure and it will not have anybody.</p>
<h2><a href="#if-class-d-is-derived-from-a-base-class-b-when-creating-an-object-of-type-d-in-what-order-would-the-constructors-of-these-classes-get-called" class="header-anchor">#</a><span id="if-class-d-is-derived-from-a-base-class-b-when-creating-an-object-of-type-d-in-what-order-would-the-constructors-of-these-classes-get-called"> If class D is derived from a base class B. When creating an object of type D in what order would the constructors of these classes get called?</span></h2>
<p>The derived class has two parts, a base part, and a derived part.  When C++ constructs derived objects, it does so in phases. First, the most-base class(at the top of the inheritance tree) is constructed. Then each child class is constructed in order until the most-child class is constructed last.<br>
So the first Constructor of class B will be called and then the constructor of class D will be called.</p>
<p>During the destruction exactly reverse order is followed. That is destructor starts at the most-derived class and works its way down to base class.<br>
So the first destructor of class D will be called and then the destructor of class B will be called.</p>
<h2><a href="#can-we-call-a-virtual-function-from-a-constructor" class="header-anchor">#</a><span id="can-we-call-a-virtual-function-from-a-constructor"> Can we call a virtual function from a constructor?</span></h2>
<p>Yes, we can call a virtual function from a constructor. But the behavior is a little different in this case. When a virtual function is called, the virtual call is resolved at runtime. It is always the member function of the current class that gets called. That is the virtual machine doesn’t work within the constructor.</p>
<p>For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">base</span>&#123;<br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> value;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">base</span>(<span class="hljs-type">int</span> x)&#123;<br>   value=x;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;<br>   <br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">derived</span>&#123;<br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> a;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">derived</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y):<span class="hljs-built_in">base</span>(x)&#123;<br>   base *b;<br>   b=<span class="hljs-keyword">this</span>;<br>   b-&gt;<span class="hljs-built_in">fun</span>();      <span class="hljs-comment">//calls derived::fun()</span><br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;<br>   cout&lt;&lt;”fun inside derived <span class="hljs-keyword">class</span>”&lt;&lt;endl;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#what-are-void-pointers" class="header-anchor">#</a><span id="what-are-void-pointers"> What are void pointers?</span></h2>
<p>A void pointer is a pointer which is having no datatype associated with it. It can hold addresses of any type.</p>
<p>For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span> *ptr; <br><span class="hljs-type">char</span> *str;<br>p=str;                <span class="hljs-comment">// no error </span><br>str=p;                <span class="hljs-comment">// error because of type mismatch</span><br>We can assign a pointer of any type to a <span class="hljs-type">void</span> pointer but the reverse is <span class="hljs-keyword">not</span> <span class="hljs-literal">true</span> unless you typecast it as<br><br>str=(<span class="hljs-type">char</span>*) ptr;<br></code></pre></td></tr></table></figure>
<h2><a href="#what-is-const-keyword-used-for" class="header-anchor">#</a><span id="what-is-const-keyword-used-for"> What is const keyword used for?</span></h2>
<ul>
<li>Modifies a variable, indicating that the variable cannot be changed;</li>
<li>Modified pointers are divided into pointers to constants (pointer to const) and pointers that are themselves constants (const pointers, const pointers);</li>
<li>Modified references, reference to const, are used for formal parameter types, which avoids copying and avoids function modification to the value;</li>
<li>Modifies a member function, indicating that member variables cannot be modified within the member function.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> a;                <span class="hljs-comment">// 常对象成员，可以使用初始化列表或者类内初始化</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">A</span>() : <span class="hljs-built_in">a</span>(<span class="hljs-number">0</span>) &#123; &#125;;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">a</span>(x) &#123; &#125;;        <span class="hljs-comment">// 初始化列表</span><br><br>    <span class="hljs-comment">// const可用于对重载函数的区分</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span></span>;             <span class="hljs-comment">// 普通成员函数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;       <span class="hljs-comment">// 常成员函数，不得修改类中的任何数据成员的值</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 对象</span><br>    A b;                        <span class="hljs-comment">// 普通对象，可以调用全部成员函数</span><br>    <span class="hljs-type">const</span> A a;                  <span class="hljs-comment">// 常对象，只能调用常成员函数</span><br>    <span class="hljs-type">const</span> A *p = &amp;a;            <span class="hljs-comment">// 指针变量，指向常对象</span><br>    <span class="hljs-type">const</span> A &amp;q = a;             <span class="hljs-comment">// 指向常对象的引用</span><br><br>    <span class="hljs-comment">// 指针</span><br>    <span class="hljs-type">char</span> greeting[] = <span class="hljs-string">&quot;Hello&quot;</span>;<br>    <span class="hljs-type">char</span>* p1 = greeting;                <span class="hljs-comment">// 指针变量，指向字符数组变量</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* p2 = greeting;          <span class="hljs-comment">// 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）</span><br>    <span class="hljs-type">char</span>* <span class="hljs-type">const</span> p3 = greeting;          <span class="hljs-comment">// 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> p4 = greeting;    <span class="hljs-comment">// 自身是常量的指针，指向字符数组常量</span><br>&#125;<br><br><span class="hljs-comment">// 函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function1</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> Var)</span></span>;           <span class="hljs-comment">// 传递过来的参数在函数内不可变</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* Var)</span></span>;         <span class="hljs-comment">// 参数指针所指内容为常量</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function3</span><span class="hljs-params">(<span class="hljs-type">char</span>* <span class="hljs-type">const</span> Var)</span></span>;         <span class="hljs-comment">// 参数指针为常量</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function4</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; Var)</span></span>;          <span class="hljs-comment">// 引用参数在函数内为常量</span><br><br><span class="hljs-comment">// 函数返回值</span><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">function5</span><span class="hljs-params">()</span></span>;      <span class="hljs-comment">// 返回一个常数</span><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-title">function6</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">// 返回一个指向常量的指针变量，使用：const int *p = function6();</span><br><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-type">const</span> <span class="hljs-title">function7</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">// 返回一个指向变量的常指针，使用：int* const p = function7();</span><br></code></pre></td></tr></table></figure>
<h2><a href="#what-is-volatile" class="header-anchor">#</a><span id="what-is-volatile"> What is volatile?</span></h2>
<ul>
<li>The volatile keyword is a type modifier that declares a type variable that can be changed by some factor unknown to the compiler (operating system, hardware, other threads, etc.). So using volatile tells the compiler that it should not optimize such an object.</li>
<li>Variables declared with the volatile keyword must be fetched from memory each time they are accessed (variables not modified by volatile may be fetched from CPU registers due to compiler optimizations)</li>
<li>const can be volatile (like a read-only status register)</li>
<li>pointers can be volatile.</li>
</ul>
<h2><a href="#how-virtual-function-is-achieved" class="header-anchor">#</a><span id="how-virtual-function-is-achieved"> How virtual function is achieved?</span></h2>
<h2><a href="#what-s-the-common-bug-in-c" class="header-anchor">#</a><span id="what-s-the-common-bug-in-c"> What’s the common bug in C++?</span></h2>
<h2><a href="#how-to-enhance-the-safety-of-pointer" class="header-anchor">#</a><span id="how-to-enhance-the-safety-of-pointer"> How to enhance the safety of pointer?</span></h2>
<h2><a href="#difference-between-shared-ptr-unique-ptr-weak-ptr" class="header-anchor">#</a><span id="difference-between-shared-ptr-unique-ptr-weak-ptr"> Difference between shared_ptr, unique_ptr, weak_ptr.</span></h2>
<h2><a href="#what-is-virtual-inheritance" class="header-anchor">#</a><span id="what-is-virtual-inheritance"> What is virtual inheritance?</span></h2>
<h2><a href="#what-is-std-move" class="header-anchor">#</a><span id="what-is-std-move"> What is std::move?</span></h2>
<h2><a href="#what-is-the-difference-between-static-cast-const-cast-reinterpret-cast-dynamic-cast-bad-cast" class="header-anchor">#</a><span id="what-is-the-difference-between-static-cast-const-cast-reinterpret-cast-dynamic-cast-bad-cast"> What is the difference between static_cast, const_cast, reinterpret_cast, dynamic_cast, bad_cast?</span></h2>
<h2><a href="#what-are-the-common-stl-what-are-the-underlying-data-structures-of-these-stl" class="header-anchor">#</a><span id="what-are-the-common-stl-what-are-the-underlying-data-structures-of-these-stl"> What are the common STL? What are the underlying data structures of these STL?</span></h2>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://www.interviewbit.com/cpp-interview-questions/">C++ Interview Questions</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
</td></p></div><div class="share"><span>Share</span>&nbsp;<span class="soc"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></span><span class="soc"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></span><span class="soc"><a target="_blank" rel="noopener" href="http://twitter.com/home?status=https://blog.kleon.space/interview/tech/c++/%20KLEON%20Tech - C++" class="fa fa-twitter"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/interview/tech/vue/" title="Tech - Vue"><i class="fa fa-angle-double-left"></i>&nbsp;Previous post: Tech - Vue</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/interview/tech/docker/" title="Tech - Docker">Next post: Tech - Docker&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2022&nbsp;<a target="_blank" href="https://blog.kleon.space" rel="noopener noreferrer">Kleon</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>