<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>Tech - Golang · KLEON</title><meta name="description" content="Interview questions of golang [1].



Language basics

What is Golang?
Why should one use Golang? What are the advantages of Golang over other languag"><meta name="og:description" content="Interview questions of golang [1].



Language basics

What is Golang?
Why should one use Golang? What are the advantages of Golang over other languag"><meta name="twitter:site" content="KLEON"><meta name="twitter:title" content="Tech - Golang"><meta name="twitter:card" content="summary"><meta name="keywords" content=""><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/github.min.css"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.10.2/katex.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 6.1.0"></head><body><div id="stage" class="container"><div class="row"><div id="side-bar" class="col-sm-3 col-xs-12 side-container invisible"><div class="vertical-text site-title"><h3 tabindex="-1" class="site-title-small"><a href="/" class="a-title"></a></h3><h1 tabindex="-1" class="site-title-large"><a href="/" class="a-title">吹拉弹唱</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div id="site-nav" class="site-title-links"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li><li><a href="/categories">Categories</a></li><li><a href="/tags">Tags</a></li><li><a href="/googlebe23cb0bc55fc412.html"></a></li><li><a href="/about/index.html"></a></li><li class="soc"><a href="https://github.com/kleon1024" target="_blank" rel="noopener noreferrer" aria-label="Github"><i class="fa fa-github">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2022&nbsp;<a target="_blank" href="https://blog.kleon.space" rel="noopener noreferrer">Kleon</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div id="main-container" class="col-sm-9 col-xs-12 main-container invisible"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>Tech - Golang</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2022-04-22</span><span class="date meta-item">Updated at&nbsp;2022-04-22</span><span class="meta-item"><i class="fa fa-folder"></i><span>&nbsp;</span><a href="/categories/interview/" title="interview" class="a-tag">interview</a><span>&nbsp;</span></span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a href="/tags/interview/" title="interview" class="a-tag">interview</a><span>&nbsp;</span><a href="/tags/tech/" title="tech" class="a-tag">tech</a><span>&nbsp;</span><a href="/tags/golang/" title="golang" class="a-tag">golang</a><span>&nbsp;</span></span></p><p class="post-abstract"><p>Interview questions of golang <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>.</p>
<div class="toc">
<!-- toc -->
<ul>
<li><a href="#language-basics">Language basics</a>
<ul>
<li><a href="#what-is-golang">What is Golang?</a></li>
<li><a href="#why-should-one-use-golang-what-are-the-advantages-of-golang-over-other-languages">Why should one use Golang? What are the advantages of Golang over other languages?</a></li>
<li><a href="#what-are-the-cons-defects-disadvantages-of-golang">What are the cons/defects/disadvantages of Golang?</a></li>
<li><a href="#what-are-golang-packages">What are Golang packages?</a></li>
<li><a href="#what-do-you-understand-by-golang-string-literals">What do you understand by Golang string literals?</a></li>
<li><a href="#what-do-you-understand-by-the-scope-of-variables-in-go">What do you understand by the scope of variables in Go?</a></li>
<li><a href="#what-do-you-understand-by-goroutine-in-golang">What do you understand by goroutine in Golang?</a></li>
<li><a href="#is-it-possible-to-declare-variables-of-different-types-in-a-single-line-of-code-in-golang">Is it possible to declare variables of different types in a single line of code in Golang?</a></li>
<li><a href="#what-is-slice-in-go">What is “slice” in Go?</a></li>
<li><a href="#what-are-go-interfaces">What are Go Interfaces?</a></li>
<li><a href="#why-is-golang-fast-compared-to-other-languages">Why is Golang fast compared to other languages?</a></li>
<li><a href="#what-are-go-channels-and-how-are-channels-used-in-golang">What are Go channels and how are channels used in Golang?</a></li>
<li><a href="#what-do-you-understand-by-type-assertion-in-go">What do you understand by Type Assertion in Go?</a></li>
<li><a href="#how-will-you-check-the-type-of-a-variable-at-runtime-in-go">How will you check the type of a variable at runtime in Go?</a></li>
<li><a href="#is-the-usage-of-global-variables-in-programs-implementing-goroutines-recommended">Is the usage of Global Variables in programs implementing goroutines recommended?</a></li>
<li><a href="#what-are-the-uses-of-an-empty-struct">What are the uses of an empty struct?</a></li>
<li><a href="#how-can-we-copy-a-slice-and-a-map-in-go">How can we copy a slice and a map in Go?</a></li>
<li><a href="#how-is-gopath-different-from-goroot-variables-in-go">How is GoPATH different from GoROOT variables in Go?</a></li>
<li><a href="#in-go-are-there-any-good-error-handling-practices">In Go, are there any good error handling practices?</a></li>
<li><a href="#which-is-safer-for-concurrent-data-access-channels-or-maps">Which is safer for concurrent data access? Channels or Maps?</a></li>
<li><a href="#how-can-you-sort-a-slice-of-custom-structs-with-the-help-of-an-example">How can you sort a slice of custom structs with the help of an example?</a></li>
<li><a href="#what-do-you-understand-by-shadowing-in-go">What do you understand by Shadowing in Go?</a></li>
<li><a href="#what-do-you-understand-by-variadic-functions-in-go">What do you understand by variadic functions in Go?</a></li>
<li><a href="#what-do-you-understand-by-byte-and-rune-data-types-how-are-they-represented">What do you understand by byte and rune data types? How are they represented?</a></li>
</ul>
</li>
<li><a href="#code-reading">Code Reading</a>
<ul>
<li><a href="#what-do-you-understand-by-each-of-the-functions-demo-func-as-shown-in-the-below-code">What do you understand by each of the functions demo_func() as shown in the below code?</a></li>
</ul>
</li>
<li><a href="#dive-deep">Dive deep</a>
<ul>
<li><a href="#why-is-golang-so-fast">Why is Golang so fast?</a></li>
<li><a href="#describe-golang-s-csp-model">Describe Golang’s CSP Model?</a></li>
<li><a href="#describe-the-process-of-the-garbage-collection-of-golang">Describe the process of the garbage collection of Golang?</a></li>
<li><a href="#describe-the-hierarchical-memory-management-strategy">Describe the hierarchical memory management strategy?</a></li>
<li><a href="#what-s-the-data-structure-of-map">What’s the data structure of <code>map</code>?</a></li>
<li><a href="#how-is-channel-implemented">How is <code>channel</code> implemented?</a></li>
<li><a href="#lock">Lock</a></li>
<li><a href="#runtime">runtime</a></li>
<li><a href="#sentinel-go">Sentinel-Go</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div>
<h1><a href="#language-basics" class="header-anchor">#</a><span id="language-basics"> Language basics</span></h1>
<h2><a href="#what-is-golang" class="header-anchor">#</a><span id="what-is-golang"> What is Golang?</span></h2>
<p>Go is a high level, general-purpose programming language that is very strongly and <strong>statically typed</strong> by providing support for <strong>garbage collection</strong> and <strong>concurrent programming</strong>.<br>
In Go, the programs are built by using packages that help in managing the dependencies efficiently. It also uses a <strong>compile-link model</strong> for generating executable binaries from the source code. Go is a simple language with elegant and easy to understand syntax structures. It has a built-in collection of powerful standard libraries that helps developers in solving problems without the need for third party packages. Go has <strong>first-class support for Concurrency</strong> having the ability to use multi-core processor architectures to the advantage of the developer and utilize memory efficiently. This helps the applications scale in a simpler way.</p>
<h2><a href="#why-should-one-use-golang-what-are-the-advantages-of-golang-over-other-languages" class="header-anchor">#</a><span id="why-should-one-use-golang-what-are-the-advantages-of-golang-over-other-languages"> Why should one use Golang? What are the advantages of Golang over other languages?</span></h2>
<p>A:</p>
<ul>
<li><strong>Simple and Understandable</strong>: Go is very simple to learn and understand. There are no unnecessary features included. Every single line of the Go code is very easily readable and thereby easily understandable irrespective of the size of the codebase. Go was developed by keeping simplicity, maintainability and readability in mind.</li>
<li><strong>Standard Powerful Library</strong>: Go supports all standard libraries and packages that help in writing code easily and efficiently.</li>
<li><strong>Support for concurrency</strong>: Go provides very good support for concurrency using Go Routines or channels. They take advantage of efficient memory management strategies and multi-core processor architecture for implementing concurrency.</li>
<li><strong>Static Type Checking</strong>: Go is a very strong and statically typed programming language. Statically typed means every variable has types assigned to it. The data type cannot be changed once created and strongly typed means that there are rules and restrictions while performing type conversion. This ensures that the code is type-safe and all type conversions are handled efficiently. This is done for reducing the chances of errors at runtime.</li>
<li><strong>Easy to install Binaries</strong>: Go provides support for generating binaries for the applications with all required dependencies. These binaries help to install tools or applications written in Go very easily without the need for a Go compiler or package managers or runtimes.</li>
<li><strong>Good Testing Support</strong>: Go has good support for writing unit test cases along with our code. There are libraries that support checking code coverage and generating code documentation.</li>
</ul>
<h2><a href="#what-are-the-cons-defects-disadvantages-of-golang" class="header-anchor">#</a><span id="what-are-the-cons-defects-disadvantages-of-golang"> What are the cons/defects/disadvantages of Golang?</span></h2>
<p>A:</p>
<ul>
<li>Lack of Function Overloading and Default Values for Arguments. A lots of code.</li>
<li>Lack of Generics. A lots of duplicated code.</li>
<li>Error Handling. Lack of exception.</li>
<li>Absence of manual memory management. GC is not suit for some time-sensitive application.</li>
<li>Runtime safety is not that good. Golang only provides compiled-time safety rather than runtime-safety.</li>
</ul>
<h2><a href="#what-are-golang-packages" class="header-anchor">#</a><span id="what-are-golang-packages"> What are Golang packages?</span></h2>
<p>Go Packages (in short pkg) are nothing but directories in the Go workspace that contains Go source files or other Go packages themselves. Every single piece of code starting from variables to functions are written in the source files are in turn stored in a linked package. Every source file should belong to a package.<br>
From the image below, we can see that a Go Package is represented as a box where we can store multiple Go source files of the .go extension. We can also store Go packages as well within a package.</p>
<p>What are Golang pointers?<br>
Go Pointers are those variables that hold the address of any variables. Due to this, they are called special variables. Pointers support two operators:</p>
<ul>
<li><code>*</code> operator: This operator is called a dereferencing operator and is used for accessing the value in the address stored by the pointer.</li>
<li><code>&amp;</code> operator: This operator is called the address operator and is used for returning the address of the variable stored in the pointer.<br>
Pointers are used for the following purposes:</li>
<li>Allowing function to directly mutate value passed to it. That is achieving pass by reference functionality.</li>
<li>For increasing the performance in the edge cases in the presence of a large data structure. Using pointers help to copy large data efficiently.</li>
<li>Helps in signifying the lack of values. For instance, while unmarshalling JSON data into a struct, it is useful to know if the key is present or absent then the key is present with 0 value.</li>
</ul>
<h2><a href="#what-do-you-understand-by-golang-string-literals" class="header-anchor">#</a><span id="what-do-you-understand-by-golang-string-literals"> What do you understand by Golang string literals?</span></h2>
<p>String literals are those variables storing string constants that can be a single character or that can be obtained as a result of the concatenation of a sequence of characters. Go provides two types of string literals. They are:</p>
<ul>
<li>Raw string literals: Here, the values are uninterrupted character sequences between backquotes. For example:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">`interviewbit`<br></code></pre></td></tr></table></figure>
<ul>
<li>Interpreted string literals: Here, the character sequences are enclosed in double quotes. The value may or may not have new lines. For example:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&quot;Interviewbit<br>Website&quot;<br></code></pre></td></tr></table></figure>
<h2><a href="#what-do-you-understand-by-the-scope-of-variables-in-go" class="header-anchor">#</a><span id="what-do-you-understand-by-the-scope-of-variables-in-go"> What do you understand by the scope of variables in Go?</span></h2>
<p>The variable scope is defined as the part of the program where the variable can be accessed. Every variable is statically scoped (meaning a variable scope can be identified at compile time) in Go which means that the scope is declared at the time of compilation itself. There are two scopes in Go, they are:</p>
<ul>
<li>Local variables - These are declared inside a function or a block and is accessible only within these entities.</li>
<li>Global variables - These are declared outside function or block and is accessible by the whole source file.</li>
</ul>
<h2><a href="#what-do-you-understand-by-goroutine-in-golang" class="header-anchor">#</a><span id="what-do-you-understand-by-goroutine-in-golang"> What do you understand by goroutine in Golang?</span></h2>
<p>A goroutine is nothing but a function in Golang that usually runs concurrently or parallelly with other functions. They can be imagined as a lightweight thread that has independent execution and can run concurrently with other routines. Goroutines are entirely managed by Go Runtime. Goroutines help Golang achieve concurrency.</p>
<ul>
<li>In Golang, the main function of the main package is considered the main goroutine. It is the starting point of all other goroutines. These goroutines have the power to start their goroutines. Once the execution of the main goroutine is complete, it means that the program has been completed.</li>
<li>We can start a goroutine by just specifying the go keyword before the method call. The method will now be called and run as a goroutine.</li>
</ul>
<h2><a href="#is-it-possible-to-declare-variables-of-different-types-in-a-single-line-of-code-in-golang" class="header-anchor">#</a><span id="is-it-possible-to-declare-variables-of-different-types-in-a-single-line-of-code-in-golang"> Is it possible to declare variables of different types in a single line of code in Golang?</span></h2>
<p>A:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a,b,c= <span class="hljs-number">9</span>, <span class="hljs-number">7.1</span>, <span class="hljs-string">&quot;interviewbit&quot;</span><br></code></pre></td></tr></table></figure>
<h2><a href="#what-is-slice-in-go" class="header-anchor">#</a><span id="what-is-slice-in-go"> What is “slice” in Go?</span></h2>
<p>Slice in Go is a lightweight data structure of variable length sequence for storing homogeneous data. It is more convenient, powerful and flexible than an array in Go. Slice has 3 components:</p>
<ul>
<li>Pointer: This is used for pointing to the first element of the array accessible via slice. The element doesn’t need to be the first element of the array.</li>
<li>Length: This is used for representing the total elements count present in the slice.</li>
<li>Capacity: This represents the capacity up to which the slice can expand.</li>
</ul>
<h2><a href="#what-are-go-interfaces" class="header-anchor">#</a><span id="what-are-go-interfaces"> What are Go Interfaces?</span></h2>
<p>Go interfaces are those that have a defined set of method signatures. It is a custom type who can take values that has these methods implementation.  The interfaces are abstract which is why we cannot create its instance. But we can create a variable of type interface and that variable can then be assigned to a concrete value that has methods required by the interface. Due to these reasons, an interface can act as two things:</p>
<ul>
<li>Collection of method signatures</li>
<li>Custom types</li>
</ul>
<h2><a href="#why-is-golang-fast-compared-to-other-languages" class="header-anchor">#</a><span id="why-is-golang-fast-compared-to-other-languages"> Why is Golang fast compared to other languages?</span></h2>
<p>Golang is faster than other programming languages because of its simple and efficient memory management and concurrency model. The compilation process to machine code is very fast and efficient. Additionally, the dependencies are linked to a single binary file thereby putting off dependencies on servers.</p>
<h2><a href="#what-are-go-channels-and-how-are-channels-used-in-golang" class="header-anchor">#</a><span id="what-are-go-channels-and-how-are-channels-used-in-golang"> What are Go channels and how are channels used in Golang?</span></h2>
<p>Go channel is a medium using which goroutines communicate data values with each other. It is a technique that allows data transfer to other goroutines. A channel can transfer data of the same type. The data transfer in the channel is bidirectional meaning the goroutines can use the same channel for sending or receiving the data.</p>
<h2><a href="#what-do-you-understand-by-type-assertion-in-go" class="header-anchor">#</a><span id="what-do-you-understand-by-type-assertion-in-go"> What do you understand by Type Assertion in Go?</span></h2>
<p>The type assertion takes the interface value and retrieves the value of the specified explicit data type. The syntax of Type Assertion is:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">t := i.(T)<br></code></pre></td></tr></table></figure>
<p>Here, the statement asserts that the interface value i has the concrete type T and assigns the value of type T to the variable t. In case i does not have concrete type T, then the statement will result in panic.<br>
For testing, if an interface has the concrete type, we can do it by making use of two values returned by type assertion. One value is the underlying value and the other is a bool value that tells if the assertion is completed or not. The syntax would be:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">t, isSuccess := i.(T)<br></code></pre></td></tr></table></figure>
<p>Here, if the interface value i have T, then the underlying value will be assigned to t and the value of isSuccess becomes true. Else, the isSuccess statement would be false and the value of t would have the zero value corresponding to type T. This ensures there is no panic if the assertion fails.</p>
<h2><a href="#how-will-you-check-the-type-of-a-variable-at-runtime-in-go" class="header-anchor">#</a><span id="how-will-you-check-the-type-of-a-variable-at-runtime-in-go"> How will you check the type of a variable at runtime in Go?</span></h2>
<p>In Go, we can use a special type of switch for checking the variable type at runtime. This switch statement is called a “type switch”.<br>
Consider the following piece of code where we are checking for the type of variable v and performing some set of operations.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> v := param.(<span class="hljs-keyword">type</span>) &#123; <br><span class="hljs-keyword">default</span>:<br>    fmt.Printf(<span class="hljs-string">&quot;Unexpected type %T&quot;</span>, v)<br><span class="hljs-keyword">case</span> <span class="hljs-type">uint64</span>:<br>    fmt.Println(<span class="hljs-string">&quot;Integer type&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-type">string</span>:<br>    fmt.Println(<span class="hljs-string">&quot;String type&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>In the above code, we are checking for the type of variable v, if the type of variable is uint64, then the code prints “Integer type”. If the type of variable is a string, the code prints “String type”. If the type doesn’t match, the default block is executed and it runs the statements in the default block.</p>
<h2><a href="#is-the-usage-of-global-variables-in-programs-implementing-goroutines-recommended" class="header-anchor">#</a><span id="is-the-usage-of-global-variables-in-programs-implementing-goroutines-recommended"> Is the usage of Global Variables in programs implementing goroutines recommended?</span></h2>
<p>Using global variables in goroutines is not recommended because it can be accessed and modified by multiple goroutines concurrently. This can lead to unexpected and arbitrary results.</p>
<h2><a href="#what-are-the-uses-of-an-empty-struct" class="header-anchor">#</a><span id="what-are-the-uses-of-an-empty-struct"> What are the uses of an empty struct?</span></h2>
<p>Empty struct is used when we want to save memories. This is because they do not consume any memory for the values.</p>
<ul>
<li>While implementing a data set: We can use the empty struct to implement a dataset. Consider an example as shown below.</li>
<li>In graph traversals in the map of tracking visited vertices. For example, consider the below piece of code where we are initializing the value of vertex visited empty struct.</li>
<li>When a channel needs to send a signal of an event without the need for sending any data. From the below piece of code, we can see that we are sending a signal using sending empty struct to the channel which is sent to the workerRoutine.</li>
</ul>
<h2><a href="#how-can-we-copy-a-slice-and-a-map-in-go" class="header-anchor">#</a><span id="how-can-we-copy-a-slice-and-a-map-in-go"> How can we copy a slice and a map in Go?</span></h2>
<p>To copy a slice: We can use the built-in method called copy() as shown below:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">slice1 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>slice2 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br>slice3 := slice1<br><span class="hljs-built_in">copy</span>(slice1, slice2)<br>fmt.Println(slice1, slice2, slice3)<br></code></pre></td></tr></table></figure>
<p>To copy a map in Go: We can copy a map by traversing the keys of the map. There is no built-in method to copy the map.</p>
<h2><a href="#how-is-gopath-different-from-goroot-variables-in-go" class="header-anchor">#</a><span id="how-is-gopath-different-from-goroot-variables-in-go"> How is GoPATH different from GoROOT variables in Go?</span></h2>
<p>The GoPATH variable is an environment variable that is used for symbolizing the directories out of $GoROOT which combines the source and the binaries of Go Projects. The GoROOT variable determines where the Go SDK is located. We do not have to modify the variable unless we plan to use multiple Go versions. The GoPATH determines the root of the workspace whereas the GoROOT determines the location of Go SDK.</p>
<h2><a href="#in-go-are-there-any-good-error-handling-practices" class="header-anchor">#</a><span id="in-go-are-there-any-good-error-handling-practices"> In Go, are there any good error handling practices?</span></h2>
<p>In Go, the errors are nothing but an interface type where any type implementing the single Error() method is considered as an error. Go does not have try/catch methods as in other programming languages for handling the errors. They are instead returned as normal values.<br>
We use this whenever we apprehend that there are possibilities where a function can go wrong during type conversions or network calls. The function should return an error as its return variable if things go wrong. The caller has to check this error value and identify the error. Any value other than nil is termed as an error.<br>
As part of good error handling practices, guard classes should be used over if-else statements. They should also be wrapped in a meaningful way as they can be passed up in the call stack. Errors of the same types should not be logged or handled multiple times.</p>
<h2><a href="#which-is-safer-for-concurrent-data-access-channels-or-maps" class="header-anchor">#</a><span id="which-is-safer-for-concurrent-data-access-channels-or-maps"> Which is safer for concurrent data access? Channels or Maps?</span></h2>
<p>Channels are safe for concurrent access because they have blocking/locking mechanisms that do not let goroutines share memory in the presence of multiple threads.<br>
Maps are unsafe because they do not have locking mechanisms. While using maps, we have to use explicit locking mechanisms like mutex for safely sending data through goroutines.</p>
<h2><a href="#how-can-you-sort-a-slice-of-custom-structs-with-the-help-of-an-example" class="header-anchor">#</a><span id="how-can-you-sort-a-slice-of-custom-structs-with-the-help-of-an-example"> How can you sort a slice of custom structs with the help of an example?</span></h2>
<p>We can sort slices of custom structs by using sort.Sort and sort.Stable functions. These methods sort any collection that implements sort.Interface interface that has Len(), Less() and Swap() methods as shown in the code below:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Interface <span class="hljs-keyword">interface</span> &#123;<br>        <span class="hljs-comment">// Find number of elements in collection</span><br>        Len() <span class="hljs-type">int</span><br>        <br>        <span class="hljs-comment">// Less method is used for identifying which elements among index i and j are lesser and is used for sorting</span><br>        Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span><br>        <br>        <span class="hljs-comment">// Swap method is used for swapping elements with indexes i and j</span><br>        Swap(i, j <span class="hljs-type">int</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Consider an example of a Human Struct having name and age attributes.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Human <span class="hljs-keyword">struct</span> &#123;<br>    name <span class="hljs-type">string</span><br>    age  <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>Also, consider we have a slice of struct Human of type AgeFactor that needs to be sorted based on age. The AgeFactor implements the methods of the sort.Interface. Then we can call sort.Sort() method on the audience as shown in the below code:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// AgeFactor implements sort.Interface that sorts the slice based on age field.</span><br><span class="hljs-keyword">type</span> AgeFactor []Human<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a AgeFactor)</span></span> Len() <span class="hljs-type">int</span>           &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(a) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a AgeFactor)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> a[i].age &lt; a[j].age &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a AgeFactor)</span></span> Swap(i, j <span class="hljs-type">int</span>)      &#123; a[i], a[j] = a[j], a[i] &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    audience := []Human&#123;<br>        &#123;<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">35</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">45</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;James&quot;</span>, <span class="hljs-number">25</span>&#125;,<br>    &#125;<br>    sort.Sort(AgeFactor(audience))<br>    fmt.Println(audience) <br>&#125;<br></code></pre></td></tr></table></figure>
<p>This code would output:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">[&#123;James <span class="hljs-number">25</span>&#125; &#123;Alice <span class="hljs-number">35</span>&#125; &#123;Bob <span class="hljs-number">45</span>&#125;]<br></code></pre></td></tr></table></figure>
<h2><a href="#what-do-you-understand-by-shadowing-in-go" class="header-anchor">#</a><span id="what-do-you-understand-by-shadowing-in-go"> What do you understand by Shadowing in Go?</span></h2>
<p>Shadowing is a principle when a variable overrides a variable in a more specific scope. This means that when a variable is declared in an inner scope having the same data type and name in the outer scope, the variable is said to be shadowed. The outer variable is declared before the shadowed variable.<br>
Consider a code snippet as shown below:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> numOfCars = <span class="hljs-number">2</span>    <span class="hljs-comment">// Line 1</span><br><span class="hljs-keyword">type</span> Car <span class="hljs-keyword">struct</span>&#123;<br>  name <span class="hljs-type">string</span><br>  model <span class="hljs-type">string</span><br>  color <span class="hljs-type">string</span><br>&#125;<br>cars:= [&#123;<br>            name:<span class="hljs-string">&quot;Toyota&quot;</span>,<br>            model:<span class="hljs-string">&quot;Corolla&quot;</span>,<br>            color:<span class="hljs-string">&quot;red&quot;</span><br>        &#125;,<br>        &#123;<br>        name:<span class="hljs-string">&quot;Toyota&quot;</span>,<br>            model:<span class="hljs-string">&quot;Innova&quot;</span>,<br>            color:<span class="hljs-string">&quot;gray&quot;</span><br>  &#125;]<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countRedCars</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i &lt; numOfCars; i++&#123;<br>        <span class="hljs-keyword">if</span> cars[i].color == <span class="hljs-string">&quot;red&quot;</span> &#123;<br>            numOfCars +=<span class="hljs-number">1</span>    <span class="hljs-comment">// Line 2</span><br>            fmt.Println(<span class="hljs-string">&quot;Inside countRedCars method &quot;</span>, numOfCars)    <span class="hljs-comment">//Line 3</span><br>        &#125;<br>    &#125;      <br>&#125;<br></code></pre></td></tr></table></figure>
<p>Here, we have a function called countRedCars where we will be counting the red cars. We have the numOfCars variable defined at the beginning indicated by the Line 1 comment. Inside the countRedCars method, we have an if statement that checks whether the colour is red and if red then increments the numOfCars by 1. The interesting point here is that the value of the numCars variable after the end of the if statement will not be affecting the value of the numOfCars variable in the outer scope.</p>
<h2><a href="#what-do-you-understand-by-variadic-functions-in-go" class="header-anchor">#</a><span id="what-do-you-understand-by-variadic-functions-in-go"> What do you understand by variadic functions in Go?</span></h2>
<p>The function that takes a variable number of arguments is called a variadic function. We can pass zero or more parameters in the variadic function. The best example of a variadic function is fmt.Printf which requires one fixed argument as the first parameter and it can accept any arguments.</p>
<ul>
<li>The syntax for the variadic function isHere, we see that the type of the last parameter is preceded by the ellipsis symbol (…) which indicates that the function can take any number of parameters if the type is specified.</li>
<li>Inside the variadic function, the … type can be visualised as a slice. We can also pass the existing slice (or multiple slices) of the mentioned type to the function as a second parameter. When no values are passed in variadic function, the slice is treated as nil.</li>
<li>These functions are generally used for string formatting.</li>
<li>Variadic parameter can not be specified as return value, but we can return the variable of type slice from the function.</li>
</ul>
<h2><a href="#what-do-you-understand-by-byte-and-rune-data-types-how-are-they-represented" class="header-anchor">#</a><span id="what-do-you-understand-by-byte-and-rune-data-types-how-are-they-represented"> What do you understand by byte and rune data types? How are they represented?</span></h2>
<p>byte and rune are two integer types that are aliases for uint8 and int32 types respectively.<br>
The byte represents ASCII characters whereas the rune represents a single Unicode character which is UTF-8 encoded by default.<br>
The characters or rune literals can be represented by enclosing in single quotes like ‘a’,‘b’,’\n’.<br>
Rune is also called a Code point and can also be a numeric value. For example, 0x61 in hexadecimal corresponds to the rune literal a.</p>
<h1><a href="#code-reading" class="header-anchor">#</a><span id="code-reading"> Code Reading</span></h1>
<h2><a href="#what-do-you-understand-by-each-of-the-functions-demo-func-as-shown-in-the-below-code" class="header-anchor">#</a><span id="what-do-you-understand-by-each-of-the-functions-demo-func-as-shown-in-the-below-code"> What do you understand by each of the functions demo_func() as shown in the below code?</span></h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//DemoStruct definition</span><br><span class="hljs-keyword">type</span> DemoStruct <span class="hljs-keyword">struct</span> &#123;<br>    Val <span class="hljs-type">int</span><br>&#125;<br><span class="hljs-comment">//A.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">demo_func</span><span class="hljs-params">()</span></span> DemoStruct &#123;<br>    <span class="hljs-keyword">return</span> DemoStruct&#123;Val: <span class="hljs-number">1</span>&#125;<br>&#125;<br><span class="hljs-comment">//B.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">demo_func</span><span class="hljs-params">()</span></span> *DemoStruct &#123;<br>    <span class="hljs-keyword">return</span> &amp;DemoStruct&#123;&#125;<br>&#125;<br><span class="hljs-comment">//C.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">demo_func</span><span class="hljs-params">(s *DemoStruct)</span></span> &#123;<br>    s.Val = <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>A. Since the function has a return type of the struct, the function returns a copy of the struct by setting the value as 1.<br>
B. Since the function returns *DemoStruct, which is a pointer to the struct, it returns a pointer to the struct value created within the function.<br>
C. Since the function expects the existing struct object as a parameter and in the function, we are setting the value of its attribute, at the end of execution the value of Val variable of the struct object is set to 1.</p>
<h1><a href="#dive-deep" class="header-anchor">#</a><span id="dive-deep"> Dive deep</span></h1>
<h2><a href="#why-is-golang-so-fast" class="header-anchor">#</a><span id="why-is-golang-so-fast"> Why is Golang so fast?</span></h2>
<ul>
<li>Because Go is statically typed and compiled to <strong>machine code</strong>, it will naturally outperform languages that are interpreted or have virtual runtimes.</li>
<li>Efficient memory management<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup><sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>. The golang runtime manages memories in a hierarchical structure. It allocates a large piece of memory at a time to avoid the overhead and the fragmentation of memory allocation. The core idea of TCMalloc (thread cache malloc) is to divide the memory into multiple levels to reduce the granularity of the lock. Inside TCMalloc Memory management is divided into two parts: <strong>thread memory</strong> and <strong>page heap</strong>.
<ul>
<li><strong>thread memory</strong> Each memory page divided into — Free List of multiple fixed allocatable size-classes, which helps in reducing fragmentation. So each thread will have a cache for small objects without locks, which makes it very efficient to allocate small objects (&lt;=32k) under parallel programs.</li>
<li><strong>page heap</strong> The heap managed by TCMalloc consists of a collection of pages, where a set of consecutive pages can be represented by span. When allocated Object is larger than 32K, Pages Heap is used for allocation.<br>
When there is not enough memory to allocate small objects, go to page heap for memory. If there is not enough, page heap will ask more memory from the Operating System.<br>
As such an allocation model maintains a user-spaced memory pool, it greatly improves the efficiency of memory allocation and release.</li>
</ul>
</li>
<li>Efficient concurrency model<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup><sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>. The Golang runtime manages all goroutines, which avoids the context switch overhead than the thread or the process.
<ul>
<li><strong>Concurrency</strong>. Go implements a variant of the <strong>CSP model</strong>, in which channels are the preferred method for two Goroutines (a user space thread-like, with a few kilobytes in its stack) to share data. This approach is actually the opposite of that frequently used with other languages like Ruby or Python—a global shared data structure, with synchronization primitives for exclusive access (semaphores, locks, queues, etc.). Keeping these global data structures consistent across all units involves a lot of overhead.<br>
By following the CSP model, Go makes it possible to have concurrent constructions as primitives of the language. By default, Go knows how to deal with multiple tasks at once, and knows how to pass data between them. This, of course, translates to low latency with intercommunicating Goroutines. In Go, in the context of multithreading, you don’t write data to common storage. You create Goroutines to share data via channels. And because there is no need for exclusive access to global data structures, you gain speed.<br>
It is important to note that you can also use mutex (or lock) mechanisms in Go, but that isn’t the default approach for a concurrent program.</li>
<li><strong>Threading model</strong>. Go operates under an <strong>M:N threading model</strong>. In an M:N model, there are units of work under the user space (the Goroutines or G in the scheduler lexicon) which are scheduled to be run by the language runtime on OS threads (or M in the scheduler lexicon) on machine processors (or P in the scheduler lexicon). A Goroutine is defined as a lightweight thread managed by the Go runtime. Different Goroutines (G) can be executed on different OS threads (M), but at any given time, only one OS thread can be run on a CPU §. In the user space, you achieve concurrency as the Goroutines work cooperatively. In the presence of a blocking operation (network, I/O or system call), another Goroutine can be assigned to the OS thread.<br>
Once the blocking call ends, the runtime will try to reassign the previous Goroutine to an available OS thread. It’s possible to achieve parallelism here, because once the Goroutines are assigned to an OS thread, the OS can decide to distribute its threads’ execution through its multiple cores.<br>
By having multiple Goroutines assigned to OS threads—thus being run cooperatively (or in parallel if two OS threads are run simultaneously on different cores)—you get an efficient use of your machine’s CPUs, because all cores will be available for running your program’s functions.</li>
<li><strong>Goroutines</strong>. Goroutines live within the user thread space. In comparison to OS threads, their operations cost less: The overhead for assigning them, suspending them, and resuming them is lower than the overhead required by OS threads. Goroutines and channels are two of the most important primitives Go offers for concurrency. One important aspect of Goroutines is that expressing them in terms of code is fairly easy. You simply put the keyword go before the function you want to schedule to be run outside of the main thread.<br>
But how do Goroutines help make Go more performant? The minimal stack required for a Goroutine to exist is 2 KB. Goroutines can increase their stack on runtime if they see the need for more space, but overall, they are memory-friendly. This means their management overhead is minimal. In other words, you can have more working units being processed with a decent quantity of memory, and that translates into efficiency and speed.</li>
<li><strong>Task Scheduling</strong>. Go comes with its own runtime scheduler. The language does not rely on the native OS thread/process scheduler, but it cooperates with it. Because the scheduler is an independent component, it has the flexibility for implementing optimizations. All these optimizations aim for one thing: to avoid too much preemption of the OS Goroutines, which would result in suspending and resuming the functions’ execution, an expensive operation.<br>
Next, we are going to highlight some specific optimizations done by the scheduler in order to avoid preemption.</li>
<li><strong>Work Stealing</strong>. Generally, there are two ways to distribute workloads across CPUs. The first one is work sharing, in which busy processors send threads to other, less busy processors with the hope they will be taken and executed. The second method is work stealing, in which an idle processor is constantly looking to steal other processor threads. Go uses work stealing.<br>
How does the work stealing approach help make Go faster? The migration of threads between processors is expensive, as it involves context switch operations. Under the stealing paradigm, this phenomenon occurs less frequently, resulting in less overhead.</li>
<li><strong>Spinning Threads</strong>. The scheduler also implements a particular strategy called spinning threads, which tries to fairly distribute as many OS threads across processors as possible. Go runtime not only reduces the frequency of thread migrations between processors, it is also capable of moving an OS thread with no work assigned to another processor. This can balance CPU usage and power.<br>
When you have all CPUs working with fairly distributed workloads, you are avoiding resource underutilization, which, again, translates to resource efficiency and speed.</li>
<li><strong>System Calls</strong>. What strategy does the Go scheduler follow for handling system calls? It turns out that it also helps reduce overhead overall. Let’s see how.<br>
For system calls expected to be slow, the scheduler applies a pessimistic approach. It makes the OS thread release the processor in which it’s been running, just before the system call. Then, after the system call ends, the scheduler tries to reacquire the processor if it’s available. Otherwise, it’s enqueued by the scheduler until it finds a new available processor. The inconvenience of this approach is the overhead required for dropping and reacquiring a processor.<br>
However, the scheduler uses a second approach for system calls that are known to be fast—an optimistic approach. With this approach, the OS thread running the Goroutine with the system call does not release the processor, but it flags it.<br>
Then, after a few microseconds (20 to be precise), another independent special Goroutine (the sysmon Goroutine) checks for all flagged processors. If they are still running the heavy Goroutine that involves the system call, the scheduler takes their processors away, so they’re suspended. If the stolen processor is still available once the system call ends, the Goroutine can continue executing. Otherwise, it will need to be scheduled for execution again (until a processor becomes available).</li>
</ul>
</li>
</ul>
<h2><a href="#describe-golang-s-csp-model" class="header-anchor">#</a><span id="describe-golang-s-csp-model"> Describe Golang’s CSP Model?</span></h2>
<h2><a href="#describe-the-process-of-the-garbage-collection-of-golang" class="header-anchor">#</a><span id="describe-the-process-of-the-garbage-collection-of-golang"> Describe the process of the garbage collection of Golang?</span></h2>
<h2><a href="#describe-the-hierarchical-memory-management-strategy" class="header-anchor">#</a><span id="describe-the-hierarchical-memory-management-strategy"> Describe the hierarchical memory management strategy?</span></h2>
<h2><a href="#what-s-the-data-structure-of-map" class="header-anchor">#</a><span id="what-s-the-data-structure-of-map"> What’s the data structure of <code>map</code>?</span></h2>
<p>A linked hash table.</p>
<h2><a href="#how-is-channel-implemented" class="header-anchor">#</a><span id="how-is-channel-implemented"> How is <code>channel</code> implemented?</span></h2>
<p>A ring linked list with mutex <sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>.</p>
<h2><a href="#lock" class="header-anchor">#</a><span id="lock"> Lock</span></h2>
<p>mutex TryLock()</p>
<h2><a href="#runtime" class="header-anchor">#</a><span id="runtime"> runtime</span></h2>
<p>runtime.GoSche()</p>
<h2><a href="#sentinel-go" class="header-anchor">#</a><span id="sentinel-go"> Sentinel-Go</span></h2>
<hr>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://www.interviewbit.com/golang-interview-questions">Golang Interview Questions</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://medium.com/@ankur_anand/a-visual-guide-to-golang-memory-allocator-from-ground-up-e132258453ed">A visual guide to Go Memory Allocator from scratch (Golang)</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/76802887">详解Go语言的内存模型及堆的分配管理</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://granulate.io/deep-dive-into-golang-performance/">Deep Dive into Golang Performance</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://huweicai.com/process-thread-goroutine/">进程线程协程的本质区别</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://i6448038.github.io/2019/04/11/go-channel/">图解Go的channel底层实现</a> <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
</p></div><div class="share"><span>Share</span>&nbsp;<span class="soc"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></span><span class="soc"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></span><span class="soc"><a target="_blank" rel="noopener" href="http://twitter.com/home?status=https://blog.kleon.space/interview/tech/golang/%20KLEON%20Tech - Golang" class="fa fa-twitter"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/interview/tech/outline/" title="Tech - Outline"><i class="fa fa-angle-double-left"></i>&nbsp;Previous post: Tech - Outline</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/interview/tech/kubernetes/" title="Tech - Kubernetes">Next post: Tech - Kubernetes&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2022&nbsp;<a target="_blank" href="https://blog.kleon.space" rel="noopener noreferrer">Kleon</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>