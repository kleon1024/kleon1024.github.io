<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>Code - Dynamic Programming · KLEON</title><meta name="description" content="Principles
Problems

Knapsack Problem


LeetCode

53. Maximum Subarray
121. Best Time to Buy and Sell Stock
122. Best Time to Buy and Sell Stock II
5."><meta name="og:description" content="Principles
Problems

Knapsack Problem


LeetCode

53. Maximum Subarray
121. Best Time to Buy and Sell Stock
122. Best Time to Buy and Sell Stock II
5."><meta name="twitter:site" content="KLEON"><meta name="twitter:title" content="Code - Dynamic Programming"><meta name="twitter:card" content="summary"><meta name="keywords" content=""><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/github.min.css"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 6.1.0"></head><body><div id="stage" class="container"><div class="row"><div id="side-bar" class="col-sm-3 col-xs-12 side-container invisible"><div class="vertical-text site-title"><h3 tabindex="-1" class="site-title-small"><a href="/" class="a-title"></a></h3><h1 tabindex="-1" class="site-title-large"><a href="/" class="a-title">自说自话</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div id="site-nav" class="site-title-links"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li><li><a href="/categories">Categories</a></li><li><a href="/tags">Tags</a></li><li><a href="/googlebe23cb0bc55fc412.html"></a></li><li><a href="/about/index.html"></a></li><li class="soc"><a href="https://github.com/kleon1024" target="_blank" rel="noopener noreferrer" aria-label="Github"><i class="fa fa-github">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2022&nbsp;<a target="_blank" href="https://blog.kleon.space" rel="noopener noreferrer">Kleon</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div id="main-container" class="col-sm-9 col-xs-12 main-container invisible"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>Code - Dynamic Programming</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2022-05-05</span><span class="date meta-item">Updated at&nbsp;2022-05-05</span><span class="meta-item"><i class="fa fa-folder"></i><span>&nbsp;</span><a href="/categories/interview/" title="interview" class="a-tag">interview</a><span>&nbsp;</span></span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a href="/tags/interview/" title="interview" class="a-tag">interview</a><span>&nbsp;</span><a href="/tags/algorithm/" title="algorithm" class="a-tag">algorithm</a><span>&nbsp;</span></span></p><p class="post-abstract"><div class="toc">
<!-- toc -->
<ul>
<li><a href="#principles">Principles</a></li>
<li><a href="#problems">Problems</a>
<ul>
<li><a href="#knapsack-problem">Knapsack Problem</a></li>
</ul>
</li>
<li><a href="#leetcode">LeetCode</a>
<ul>
<li><a href="#53-maximum-subarray">53. Maximum Subarray</a></li>
<li><a href="#121-best-time-to-buy-and-sell-stock">121. Best Time to Buy and Sell Stock</a></li>
<li><a href="#122-best-time-to-buy-and-sell-stock-ii">122. Best Time to Buy and Sell Stock II</a></li>
<li><a href="#5-longest-palindromic-substring">5. Longest Palindromic Substring</a></li>
<li><a href="#647-palindromic-substrings">647. Palindromic Substrings</a></li>
<li><a href="#516-longest-palindromic-subsequence">516. Longest Palindromic Subsequence</a></li>
<li><a href="#10-regular-expression-matching">10. Regular Expression Matching</a></li>
<li><a href="#42-trapping-rain-water">42. Trapping Rain Water</a></li>
<li><a href="#44-wildcard-matching">44. Wildcard Matching</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div>
<h1><a href="#principles" class="header-anchor">#</a><span id="principles">Principles</span></h1>
<ol>
<li>Determine the dp array (dp table) and the meaning of the subscript</li>
<li>Determine the recurrence formula</li>
<li>How to initialize the dp array</li>
<li>Determine the traversal order</li>
<li>Derive the dp array by example</li>
</ol>
<h1><a href="#problems" class="header-anchor">#</a><span id="problems">Problems</span></h1>
<h2><a href="#knapsack-problem" class="header-anchor">#</a><span id="knapsack-problem">Knapsack Problem</span></h2>
<h1><a href="#leetcode" class="header-anchor">#</a><span id="leetcode">LeetCode</span></h1>
<h2><a href="#53-maximum-subarray" class="header-anchor">#</a><span id="53-maximum-subarray">53. Maximum Subarray</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-subarray/">leetcode</a></p>
<p><strong>A general dp solution.</strong></p>
<p>The question is quite clear. I only need to return the maximum sum rather the specific subarray.<br>
The first method comes into my mind is the dynamic programming. The maximum sum of the subarray with the index from 0 to N - 1, in which N is the length of the input array, is the larger one between the sum of the subarray with the index between 0 to N-2 adding the N-1 th element, and the N-1 th element which means reset the sum. So we can find the maximum sum of the subarray during the iteration.</p>
<p>Therefore, we can determine the dp array which means the maximum sum of the subarray between the index 0 to subscript i.<br>
And the recurrence formula is:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">dp[i] = <span class="hljs-title function_">max</span>(nums[i], dp[i - <span class="hljs-number">1</span>] + nums[i])<br></code></pre></td></tr></table></figure>
<p>And initializing the dp array. The dp[0] means the maximum array from 0 to 0, which exactly is nums[0].<br>
The traversal order is incremental.<br>
And manually validate our assumptions with an example.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    N := <span class="hljs-built_in">len</span>(nums)<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, N)<br>    dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>    result := dp[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; N; i++ &#123;<br>        dp[i] = max(nums[i], dp[i - <span class="hljs-number">1</span>] + nums[i])<br>        <span class="hljs-keyword">if</span> (dp[i] &gt; result) &#123;<br>            result = dp[i]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p><strong>A greedy solution</strong><br>
We keep a sum of the contiguous subarray adding each new element. Once the sum is less than 0, we reset the sum to 0. Any negative number could reduces the sum, and if the sum is already negative, we’re choosing the large one between the sum of the contiguous subarray and the next element, or simply the next element. The larger one must be the later, which is exactly resetting the sum to 0.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    sum := <span class="hljs-number">0</span><br>    max := math.MinInt64<br>    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>        sum += num<br>        <span class="hljs-keyword">if</span> sum &gt; max &#123;<br>            max = sum<br>        &#125;<br>        <span class="hljs-keyword">if</span> sum &lt; <span class="hljs-number">0</span> &#123;<br>            sum = <span class="hljs-number">0</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> max<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#121-best-time-to-buy-and-sell-stock" class="header-anchor">#</a><span id="121-best-time-to-buy-and-sell-stock">121. Best Time to Buy and Sell Stock</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">leetcode</a></p>
<p><strong>Greedy Solution</strong></p>
<p>The constraint is I have to sell the stock in a day after buying. So the first method could be finding the minimum value from the left and the maximum value from the right. And the difference between these two numbers is the maximum profit.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    profit := <span class="hljs-number">0</span><br>    low := math.MaxInt64<br>    <span class="hljs-keyword">for</span> _, price := <span class="hljs-keyword">range</span> prices &#123;<br>        low = min(low, price)<br>        profit = max(profit, price - low)<br>    &#125;<br>    <span class="hljs-keyword">return</span> profit<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure>
<p>optimized</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    profit := <span class="hljs-number">0</span><br>    low := prices[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> _, price := <span class="hljs-keyword">range</span> prices &#123;<br>        <span class="hljs-keyword">if</span> price &lt; low &#123;<br>            low = price<br>        &#125;<br>        <span class="hljs-keyword">if</span> profit &lt; price - low &#123;<br>            profit = price - low<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> profit<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h2><a href="#122-best-time-to-buy-and-sell-stock-ii" class="header-anchor">#</a><span id="122-best-time-to-buy-and-sell-stock-ii">122. Best Time to Buy and Sell Stock II</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">leetcode</a></p>
<p><strong>Greedy Solution</strong></p>
<p>Since we could only hold one share of stock and we can buy and sell at any time, so we could break the profit down to a single day, and we only count the days which have a positive profit.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">func maxProfit(prices []int) int &#123;<br>    profit := 0<br>    for i := 1; i &lt; len(prices); i++ &#123;<br>        if (prices[i] &gt; prices[i - 1]) &#123;<br>            profit += prices[i] - prices[i - 1]<br>        &#125;<br>    &#125;<br>    return profit<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#5-longest-palindromic-substring" class="header-anchor">#</a><span id="5-longest-palindromic-substring">5. Longest Palindromic Substring</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-palindromic-substring/">leetcode</a></p>
<p><strong>DP</strong></p>
<p>Is the substring contiguous? Yes<br>
If multiple substrings are found, which one should I return? Any of them.</p>
<p>The solution I may have a try is dynamic programming.<br>
First, determine the meaning of dp table <code>dp[i][j]</code>, which means is the substring from the subscript i to j is palindromic. i is less then j. The interval is left closed and right closed.<br>
Second, determine the recursive formula. If s[i] and s[j] are not equal, there is no chance the substring could be palindromic. Therefore, we discuss the details where s[i] and s[j] are equal. There are 3 situations.</p>
<ol>
<li>If i == j, then the substring is a letter, so it must be palindromic.</li>
<li>If j - i == 1, then the substring is like ‘aa’, so it is palindromic.</li>
<li>If j - i &gt; 1, then the substring is depending on dp[i+1][j-1].<br>
Third, determine how to initialize the dp table. dp[0][0] is palindromic, initialize all other elements to false.<br>
Fourth, determine the traversal order.<br>
dp[i + 1][j - 1] is at the bottom left of dp[i][j], so dp[i + 1][j - 1] must be determined before dp[i][j]. So it must be traversed from bottom to top and left to right, so as to ensure that dp[i + 1][j - 1] is calculated.</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    N := <span class="hljs-built_in">len</span>(s)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>, N)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; N; i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, N)<br>    &#125;<br>    left := <span class="hljs-number">0</span><br>    right := <span class="hljs-number">0</span><br>    max := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := N - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">for</span> j := i; j &lt; N; j++ &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == s[j]) &#123;<br>                <span class="hljs-keyword">if</span> j - i &lt;= <span class="hljs-number">1</span> &#123;<br>                    dp[i][j] = <span class="hljs-literal">true</span><br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = <span class="hljs-literal">true</span><br>                &#125;<br>                <span class="hljs-keyword">if</span> dp[i][j] &#123;<br>                    <span class="hljs-keyword">if</span> j - i + <span class="hljs-number">1</span> &gt; max &#123;<br>                        max = j - i + <span class="hljs-number">1</span><br>                        left = i<br>                        right = j<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> s[left:right + <span class="hljs-number">1</span>]<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#647-palindromic-substrings" class="header-anchor">#</a><span id="647-palindromic-substrings">647. Palindromic Substrings</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/palindromic-substrings/">leetcode</a></p>
<p>This is similar to 5.</p>
<p><strong>DP</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    N := <span class="hljs-built_in">len</span>(s)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>, N)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; N; i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, N)<br>    &#125;<br>    result := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := N - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">for</span> j := i; j &lt; N; j++ &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == s[j]) &#123;<br>                <span class="hljs-keyword">if</span> j - i &lt;= <span class="hljs-number">1</span> &#123;<br>                    dp[i][j] = <span class="hljs-literal">true</span><br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = <span class="hljs-literal">true</span><br>                &#125;<br>                <span class="hljs-keyword">if</span> dp[i][j] &#123;<br>                    result++<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#516-longest-palindromic-subsequence" class="header-anchor">#</a><span id="516-longest-palindromic-subsequence">516. Longest Palindromic Subsequence</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-palindromic-subsequence/">leetcode</a></p>
<p>This is quite similar to 5 other than the situation analysis.<br>
First, determine the meaning of dp table dp[i][j], which means the length of the longest palindromic subsequence from subscript i to j.<br>
Second, determine the recursive formula. If s[i] == s[j], then dp[i][j] = dp[i + 1][j - 1] + 2. If s[i] != s[j], it means that adding s[i] and s[j] at the same time cannot increase the length of the palindrome substring in the interval [i, j], then add s[i] and s respectively. [j] See which one can form the longest palindromic subsequence. The dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]).<br>
Third, initialize the dp array. dp[i][i] = 1.<br>
Fourth, determine the traversal order. dp[i][j] is dependent on dp[i + 1][j - 1] and dp[i + 1][j] and dp[i][j - 1]. So it must be traversed from bottom to top and left to right.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestPalindromeSubseq</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    N := <span class="hljs-built_in">len</span>(s)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, N)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; N; i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, N)<br>        dp[i][i] = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> i := N - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; N; j++ &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == s[j]) &#123;<br>                dp[i][j] = dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">2</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = max(dp[i+<span class="hljs-number">1</span>][j], dp[i][j<span class="hljs-number">-1</span>])<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][N<span class="hljs-number">-1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#10-regular-expression-matching" class="header-anchor">#</a><span id="10-regular-expression-matching">10. Regular Expression Matching</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/regular-expression-matching/">leetcode</a></p>
<p>Simply converted to a dp problem.<br>
First, determine the dp table, dp[i-1][j-1] means is p[0:j] matches s[0:i].<br>
Second, determine the recursive formula.</p>
<ol>
<li>If current p (p[j - 1]) is star, dp[i][j] compares s[i-1] and p[i-1]</li>
<li>because * means matching 0 or more, dp[i][j] at least equals to dp[i][j-2], which ignores the last two characters of p.</li>
<li>If p[i-2] is dot, then the condition is relax to dp[i - 1][j - 2].</li>
<li>And if s[i-1] == p[j - 2], current s equals last p, then dp[i][j] = dp[i - 1][j], check if we remove the last character of s, if the rest of s matches p.</li>
<li>If current p is dot, which could match any character, dp[i][j] = dp[i - 1][j - 1], if the shorter substring matches, then current substring matches.</li>
<li>If current p equals to current s, dp[i][j] = dp[i - 1][j - 1], if the shorter substring matches, then current substring matches.</li>
<li>One optimization is if the next character is star, just skip the current comparison.</li>
</ol>
<p>Third initialize the dp table.<br>
dp[0][0] must be true.<br>
Matches the 0-length s with p.</p>
<p>Determine the traversal order. From left to right, bottom to up.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(s <span class="hljs-type">string</span>, p <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    S, P := <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">len</span>(p)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>, S + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; S + <span class="hljs-number">1</span>; i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, P + <span class="hljs-number">1</span>)<br>    &#125;<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span><br>    <br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; P + <span class="hljs-number">1</span>; j++ &#123;<br>        <span class="hljs-keyword">if</span> p[j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span> &#123;<br>            dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j<span class="hljs-number">-2</span>]<br>        &#125;<br>    &#125;<br>        <br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; S + <span class="hljs-number">1</span>; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; P + <span class="hljs-number">1</span>; j++ &#123;<br>            <span class="hljs-keyword">if</span> j &lt; P &amp;&amp; p[j] == <span class="hljs-string">&#x27;*&#x27;</span> &#123;<br>                <span class="hljs-comment">// skip if this character is followed by *</span><br>                <span class="hljs-keyword">continue</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> p[j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;*&#x27;</span> &#123;<br>                dp[i][j] = dp[i][j - <span class="hljs-number">2</span>]<br>                <span class="hljs-keyword">if</span> p[j<span class="hljs-number">-2</span>] == <span class="hljs-string">&#x27;.&#x27;</span> || s[i<span class="hljs-number">-1</span>] == p[j<span class="hljs-number">-2</span>] &#123;<br>                    dp[i][j] = dp[i][j] || dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-2</span>] || dp[i<span class="hljs-number">-1</span>][j]<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> p[j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;.&#x27;</span> || s[i<span class="hljs-number">-1</span>] == p[j<span class="hljs-number">-1</span>] &#123;<br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[S][P]<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#42-trapping-rain-water" class="header-anchor">#</a><span id="42-trapping-rain-water">42. Trapping Rain Water</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/trapping-rain-water/">leetcode</a></p>
<p><strong>Column Searching</strong></p>
<p>The main idea is to find the maximum wall from the target column i. The first and the last wall do not count.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trap</span><span class="hljs-params">(height []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    sum := <span class="hljs-number">0</span><br>    N := <span class="hljs-built_in">len</span>(height)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; N; i++ &#123;<br>        <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> || i == N - <span class="hljs-number">1</span> &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        left := height[i]<br>        right := height[i]<br>        <span class="hljs-keyword">for</span> r := i + <span class="hljs-number">1</span>; r &lt; N; r++ &#123;<br>            <span class="hljs-keyword">if</span> height[r] &gt; right &#123;<br>                right = height[r]<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> l := i - <span class="hljs-number">1</span>; l &gt;= <span class="hljs-number">0</span>; l-- &#123;<br>            <span class="hljs-keyword">if</span> height[l] &gt; left &#123;<br>                left = height[l]<br>            &#125;<br>        &#125;<br>        sum += min(left, right) - height[i]<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Dynamic Programming</strong></p>
<p>Use an array to store the max height.<br>
maxLeft[i] = max(height[i], maxLeft[i - 1]);<br>
maxRight[i] = max(height[i], maxRight[i + 1]);</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trap</span><span class="hljs-params">(height []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(height) &lt; <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    sum := <span class="hljs-number">0</span><br>    N := <span class="hljs-built_in">len</span>(height)<br>    maxLeft := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, N)<br>    maxRight := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, N)<br>    maxLeft[<span class="hljs-number">0</span>] = height[<span class="hljs-number">0</span>]<br>    maxRight[N<span class="hljs-number">-1</span>] = height[N<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; N; i++ &#123;<br>        maxLeft[i] = max(maxLeft[i<span class="hljs-number">-1</span>], height[i])<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := N - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        maxRight[i] = max(maxRight[i + <span class="hljs-number">1</span>], height[i])<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; N; i++ &#123;<br>        sum += min(maxLeft[i], maxRight[i]) - height[i]<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Double Pointer</strong></p>
<p>Optimization to DP Solution.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trap</span><span class="hljs-params">(height []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    left, right := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(height)<span class="hljs-number">-1</span><br>    leftMax, rightMax := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> left &lt; right &#123;<br>        leftMax = max(leftMax, height[left])<br>        rightMax = max(rightMax, height[right])<br>        <span class="hljs-keyword">if</span> height[left] &lt; height[right] &#123;<br>            ans += leftMax - height[left]<br>            left++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ans += rightMax - height[right]<br>            right--<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#44-wildcard-matching" class="header-anchor">#</a><span id="44-wildcard-matching">44. Wildcard Matching</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/wildcard-matching/">leetcode</a></p>
<p>This is similar to 10 but simpler because the wildcard character are not combined.<br>
Consider it as a dp problem.<br>
First determine the dp table, dp[i][j] means whether p[i-1] can match s[i-1].</p>
<ol>
<li>If current p[i-1] is star, then dp[i][j] compares s[i-1] and p[j-1].</li>
<li>star matches 0 or more characters. dp[i][j] at least equals to dp[i][j-1], which ignores the last characters of p or dp[i][j] equals to dp[i-1][j], which ignores the last character of s.</li>
<li>If current p[i-1] is dot, which matches any single character. dp[i][j] = dp[i-1][j-1].</li>
<li>If current p[i-1] equals s[i-1], which matches any single character. dp[i][j] = dp[i-1][j-1].</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(s <span class="hljs-type">string</span>, p <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    S, P := <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">len</span>(p)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>, S+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; S+<span class="hljs-number">1</span>; i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, P+<span class="hljs-number">1</span>)<br>    &#125;<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; P+<span class="hljs-number">1</span>; j++ &#123;<br>        <span class="hljs-keyword">if</span> p[j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;*&#x27;</span> &#123;<br>            dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j<span class="hljs-number">-1</span>]<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; S+<span class="hljs-number">1</span>; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; P+<span class="hljs-number">1</span>; j++ &#123;<br>            <span class="hljs-keyword">if</span> p[j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;*&#x27;</span> &#123;<br>                dp[i][j] = dp[i][j<span class="hljs-number">-1</span>] || dp[i<span class="hljs-number">-1</span>][j]<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> p[j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;?&#x27;</span> || s[i<span class="hljs-number">-1</span>] == p[j<span class="hljs-number">-1</span>] &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[S][P]<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#" class="header-anchor">#</a><span id></span></h2>
</p></div><div class="share"><span>Share</span>&nbsp;<span class="soc"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></span><span class="soc"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></span><span class="soc"><a target="_blank" rel="noopener" href="http://twitter.com/home?status=https://blog.kleon.space/interview/code/dynamic_programming/%20KLEON%20Code - Dynamic Programming" class="fa fa-twitter"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/interview/code/array/" title="Code - Array"><i class="fa fa-angle-double-left"></i>&nbsp;Previous post: Code - Array</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/interview/code/linked_list/" title="Code - Linked List">Next post: Code - Linked List&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2022&nbsp;<a target="_blank" href="https://blog.kleon.space" rel="noopener noreferrer">Kleon</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>