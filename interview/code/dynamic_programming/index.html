<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>Code - Dynamic Programming · KLEON</title><meta name="description" content="Principles
Problems

Knapsack Problem


LeetCode

53. Maximum Subarray
121. Best Time to Buy and Sell Stock
122. Best Time to Buy and Sell Stock II
5."><meta name="og:description" content="Principles
Problems

Knapsack Problem


LeetCode

53. Maximum Subarray
121. Best Time to Buy and Sell Stock
122. Best Time to Buy and Sell Stock II
5."><meta name="twitter:site" content="KLEON"><meta name="twitter:title" content="Code - Dynamic Programming"><meta name="twitter:card" content="summary"><meta name="keywords" content=""><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/github.min.css"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.10.2/katex.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 6.1.0"></head><body><div id="stage" class="container"><div class="row"><div id="side-bar" class="col-sm-3 col-xs-12 side-container invisible"><div class="vertical-text site-title"><h3 tabindex="-1" class="site-title-small"><a href="/" class="a-title"></a></h3><h1 tabindex="-1" class="site-title-large"><a href="/" class="a-title">吹拉弹唱</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div id="site-nav" class="site-title-links"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li><li><a href="/categories">Categories</a></li><li><a href="/tags">Tags</a></li><li><a href="/googlebe23cb0bc55fc412.html"></a></li><li><a href="/about/index.html"></a></li><li class="soc"><a href="https://github.com/kleon1024" target="_blank" rel="noopener noreferrer" aria-label="Github"><i class="fa fa-github">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2022&nbsp;<a target="_blank" href="https://blog.kleon.space" rel="noopener noreferrer">Kleon</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div id="main-container" class="col-sm-9 col-xs-12 main-container invisible"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>Code - Dynamic Programming</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2022-05-05</span><span class="date meta-item">Updated at&nbsp;2022-05-05</span><span class="meta-item"><i class="fa fa-folder"></i><span>&nbsp;</span><a href="/categories/interview/" title="interview" class="a-tag">interview</a><span>&nbsp;</span></span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a href="/tags/interview/" title="interview" class="a-tag">interview</a><span>&nbsp;</span><a href="/tags/algorithm/" title="algorithm" class="a-tag">algorithm</a><span>&nbsp;</span></span></p><p class="post-abstract"><div class="toc">
<!-- toc -->
<ul>
<li><a href="#principles">Principles</a></li>
<li><a href="#problems">Problems</a>
<ul>
<li><a href="#knapsack-problem">Knapsack Problem</a></li>
</ul>
</li>
<li><a href="#leetcode">LeetCode</a>
<ul>
<li><a href="#53-maximum-subarray">53. Maximum Subarray</a></li>
<li><a href="#121-best-time-to-buy-and-sell-stock">121. Best Time to Buy and Sell Stock</a></li>
<li><a href="#122-best-time-to-buy-and-sell-stock-ii">122. Best Time to Buy and Sell Stock II</a></li>
<li><a href="#5-longest-palindromic-substring">5. Longest Palindromic Substring</a></li>
<li><a href="#647-palindromic-substrings">647. Palindromic Substrings</a></li>
<li><a href="#516-longest-palindromic-subsequence">516. Longest Palindromic Subsequence</a></li>
<li><a href="#10-regular-expression-matching">10. Regular Expression Matching</a></li>
<li><a href="#42-trapping-rain-water">42. Trapping Rain Water</a></li>
<li><a href="#44-wildcard-matching">44. Wildcard Matching</a></li>
<li><a href="#55-jump-game">55. Jump Game</a></li>
<li><a href="#45-jump-game-ii">45. Jump Game II</a></li>
<li><a href="#1306-jump-game-iii">1306. Jump Game III</a></li>
<li><a href="#1871-jump-game-vii">1871. Jump Game VII</a></li>
<li><a href="#1345-jump-game-iv">1345. Jump Game IV</a></li>
<li><a href="#62-unique-paths">62. Unique Paths</a></li>
<li><a href="#63-unique-paths-ii">63. Unique Paths II</a></li>
<li><a href="#980-unique-paths-iii">980. Unique Paths III</a></li>
<li><a href="#64-minimum-path-sum">64. Minimum Path Sum</a></li>
<li><a href="#70-climbing-stairs">70. Climbing Stairs</a></li>
<li><a href="#746-min-cost-climbing-stairs">746. Min Cost Climbing Stairs</a></li>
<li><a href="#72-edit-distance">72. Edit Distance</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div>
<h1><a href="#principles" class="header-anchor">#</a><span id="principles"> Principles</span></h1>
<ol>
<li>Determine the dp array (dp table) and the meaning of the subscript</li>
<li>Determine the recurrence formula</li>
<li>How to initialize the dp array</li>
<li>Determine the traversal order</li>
<li>Derive the dp array by example</li>
</ol>
<h1><a href="#problems" class="header-anchor">#</a><span id="problems"> Problems</span></h1>
<h2><a href="#knapsack-problem" class="header-anchor">#</a><span id="knapsack-problem"> Knapsack Problem</span></h2>
<h1><a href="#leetcode" class="header-anchor">#</a><span id="leetcode"> LeetCode</span></h1>
<h2><a href="#53-maximum-subarray" class="header-anchor">#</a><span id="53-maximum-subarray"> 53. Maximum Subarray</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-subarray/">leetcode</a></p>
<p><strong>A general dp solution.</strong></p>
<p>The question is quite clear. I only need to return the maximum sum rather the specific subarray.<br>
The first method comes into my mind is the dynamic programming. The maximum sum of the subarray with the index from 0 to N - 1, in which N is the length of the input array, is the larger one between the sum of the subarray with the index between 0 to N-2 adding the N-1 th element, and the N-1 th element which means reset the sum. So we can find the maximum sum of the subarray during the iteration.</p>
<p>Therefore, we can determine the dp array which means the maximum sum of the subarray between the index 0 to subscript i.<br>
And the recurrence formula is:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">dp[i] = <span class="hljs-title function_">max</span>(nums[i], dp[i - <span class="hljs-number">1</span>] + nums[i])<br></code></pre></td></tr></table></figure>
<p>And initializing the dp array. The dp[0] means the maximum array from 0 to 0, which exactly is nums[0].<br>
The traversal order is incremental.<br>
And manually validate our assumptions with an example.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    N := <span class="hljs-built_in">len</span>(nums)<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, N)<br>    dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>    result := dp[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; N; i++ &#123;<br>        dp[i] = max(nums[i], dp[i - <span class="hljs-number">1</span>] + nums[i])<br>        <span class="hljs-keyword">if</span> (dp[i] &gt; result) &#123;<br>            result = dp[i]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p><strong>A greedy solution</strong><br>
We keep a sum of the contiguous subarray adding each new element. Once the sum is less than 0, we reset the sum to 0. Any negative number could reduces the sum, and if the sum is already negative, we’re choosing the large one between the sum of the contiguous subarray and the next element, or simply the next element. The larger one must be the later, which is exactly resetting the sum to 0.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    sum := <span class="hljs-number">0</span><br>    max := math.MinInt64<br>    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>        sum += num<br>        <span class="hljs-keyword">if</span> sum &gt; max &#123;<br>            max = sum<br>        &#125;<br>        <span class="hljs-keyword">if</span> sum &lt; <span class="hljs-number">0</span> &#123;<br>            sum = <span class="hljs-number">0</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> max<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#121-best-time-to-buy-and-sell-stock" class="header-anchor">#</a><span id="121-best-time-to-buy-and-sell-stock"> 121. Best Time to Buy and Sell Stock</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">leetcode</a></p>
<p><strong>Greedy Solution</strong></p>
<p>The constraint is I have to sell the stock in a day after buying. So the first method could be finding the minimum value from the left and the maximum value from the right. And the difference between these two numbers is the maximum profit.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    profit := <span class="hljs-number">0</span><br>    low := math.MaxInt64<br>    <span class="hljs-keyword">for</span> _, price := <span class="hljs-keyword">range</span> prices &#123;<br>        low = min(low, price)<br>        profit = max(profit, price - low)<br>    &#125;<br>    <span class="hljs-keyword">return</span> profit<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure>
<p>optimized</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    profit := <span class="hljs-number">0</span><br>    low := prices[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> _, price := <span class="hljs-keyword">range</span> prices &#123;<br>        <span class="hljs-keyword">if</span> price &lt; low &#123;<br>            low = price<br>        &#125;<br>        <span class="hljs-keyword">if</span> profit &lt; price - low &#123;<br>            profit = price - low<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> profit<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h2><a href="#122-best-time-to-buy-and-sell-stock-ii" class="header-anchor">#</a><span id="122-best-time-to-buy-and-sell-stock-ii"> 122. Best Time to Buy and Sell Stock II</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">leetcode</a></p>
<p><strong>Greedy Solution</strong></p>
<p>Since we could only hold one share of stock and we can buy and sell at any time, so we could break the profit down to a single day, and we only count the days which have a positive profit.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">func maxProfit(prices []int) int &#123;<br>    profit := 0<br>    for i := 1; i &lt; len(prices); i++ &#123;<br>        if (prices[i] &gt; prices[i - 1]) &#123;<br>            profit += prices[i] - prices[i - 1]<br>        &#125;<br>    &#125;<br>    return profit<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#5-longest-palindromic-substring" class="header-anchor">#</a><span id="5-longest-palindromic-substring"> 5. Longest Palindromic Substring</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-palindromic-substring/">leetcode</a></p>
<p><strong>DP</strong></p>
<p>Is the substring contiguous? Yes<br>
If multiple substrings are found, which one should I return? Any of them.</p>
<p>The solution I may have a try is dynamic programming.<br>
First, determine the meaning of dp table <code>dp[i][j]</code>, which means is the substring from the subscript i to j is palindromic. i is less then j. The interval is left closed and right closed.<br>
Second, determine the recursive formula. If s[i] and s[j] are not equal, there is no chance the substring could be palindromic. Therefore, we discuss the details where s[i] and s[j] are equal. There are 3 situations.</p>
<ol>
<li>If i == j, then the substring is a letter, so it must be palindromic.</li>
<li>If j - i == 1, then the substring is like ‘aa’, so it is palindromic.</li>
<li>If j - i &gt; 1, then the substring is depending on dp[i+1][j-1].<br>
Third, determine how to initialize the dp table. dp[0][0] is palindromic, initialize all other elements to false.<br>
Fourth, determine the traversal order.<br>
dp[i + 1][j - 1] is at the bottom left of dp[i][j], so dp[i + 1][j - 1] must be determined before dp[i][j]. So it must be traversed from bottom to top and left to right, so as to ensure that dp[i + 1][j - 1] is calculated.</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    N := <span class="hljs-built_in">len</span>(s)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>, N)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; N; i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, N)<br>    &#125;<br>    left := <span class="hljs-number">0</span><br>    right := <span class="hljs-number">0</span><br>    max := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := N - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">for</span> j := i; j &lt; N; j++ &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == s[j]) &#123;<br>                <span class="hljs-keyword">if</span> j - i &lt;= <span class="hljs-number">1</span> &#123;<br>                    dp[i][j] = <span class="hljs-literal">true</span><br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = <span class="hljs-literal">true</span><br>                &#125;<br>                <span class="hljs-keyword">if</span> dp[i][j] &#123;<br>                    <span class="hljs-keyword">if</span> j - i + <span class="hljs-number">1</span> &gt; max &#123;<br>                        max = j - i + <span class="hljs-number">1</span><br>                        left = i<br>                        right = j<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> s[left:right + <span class="hljs-number">1</span>]<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#647-palindromic-substrings" class="header-anchor">#</a><span id="647-palindromic-substrings"> 647. Palindromic Substrings</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/palindromic-substrings/">leetcode</a></p>
<p>This is similar to 5.</p>
<p><strong>DP</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    N := <span class="hljs-built_in">len</span>(s)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>, N)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; N; i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, N)<br>    &#125;<br>    result := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := N - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">for</span> j := i; j &lt; N; j++ &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == s[j]) &#123;<br>                <span class="hljs-keyword">if</span> j - i &lt;= <span class="hljs-number">1</span> &#123;<br>                    dp[i][j] = <span class="hljs-literal">true</span><br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = <span class="hljs-literal">true</span><br>                &#125;<br>                <span class="hljs-keyword">if</span> dp[i][j] &#123;<br>                    result++<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#516-longest-palindromic-subsequence" class="header-anchor">#</a><span id="516-longest-palindromic-subsequence"> 516. Longest Palindromic Subsequence</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-palindromic-subsequence/">leetcode</a></p>
<p>This is quite similar to 5 other than the situation analysis.<br>
First, determine the meaning of dp table dp[i][j], which means the length of the longest palindromic subsequence from subscript i to j.<br>
Second, determine the recursive formula. If s[i] == s[j], then dp[i][j] = dp[i + 1][j - 1] + 2. If s[i] != s[j], it means that adding s[i] and s[j] at the same time cannot increase the length of the palindrome substring in the interval [i, j], then add s[i] and s respectively. [j] See which one can form the longest palindromic subsequence. The dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]).<br>
Third, initialize the dp array. dp[i][i] = 1.<br>
Fourth, determine the traversal order. dp[i][j] is dependent on dp[i + 1][j - 1] and dp[i + 1][j] and dp[i][j - 1]. So it must be traversed from bottom to top and left to right.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestPalindromeSubseq</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    N := <span class="hljs-built_in">len</span>(s)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, N)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; N; i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, N)<br>        dp[i][i] = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> i := N - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; N; j++ &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == s[j]) &#123;<br>                dp[i][j] = dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">2</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = max(dp[i+<span class="hljs-number">1</span>][j], dp[i][j<span class="hljs-number">-1</span>])<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][N<span class="hljs-number">-1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#10-regular-expression-matching" class="header-anchor">#</a><span id="10-regular-expression-matching"> 10. Regular Expression Matching</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/regular-expression-matching/">leetcode</a></p>
<p>Simply converted to a dp problem.<br>
First, determine the dp table, dp[i-1][j-1] means is p[0:j] matches s[0:i].<br>
Second, determine the recursive formula.</p>
<ol>
<li>If current p (p[j - 1]) is star, dp[i][j] compares s[i-1] and p[i-1]</li>
<li>because * means matching 0 or more, dp[i][j] at least equals to dp[i][j-2], which ignores the last two characters of p.</li>
<li>If p[i-2] is dot, then the condition is relax to dp[i - 1][j - 2].</li>
<li>And if s[i-1] == p[j - 2], current s equals last p, then dp[i][j] = dp[i - 1][j], check if we remove the last character of s, if the rest of s matches p.</li>
<li>If current p is dot, which could match any character, dp[i][j] = dp[i - 1][j - 1], if the shorter substring matches, then current substring matches.</li>
<li>If current p equals to current s, dp[i][j] = dp[i - 1][j - 1], if the shorter substring matches, then current substring matches.</li>
<li>One optimization is if the next character is star, just skip the current comparison.</li>
</ol>
<p>Third initialize the dp table.<br>
dp[0][0] must be true.<br>
Matches the 0-length s with p.</p>
<p>Determine the traversal order. From left to right, bottom to up.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(s <span class="hljs-type">string</span>, p <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    S, P := <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">len</span>(p)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>, S + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; S + <span class="hljs-number">1</span>; i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, P + <span class="hljs-number">1</span>)<br>    &#125;<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span><br>    <br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; P + <span class="hljs-number">1</span>; j++ &#123;<br>        <span class="hljs-keyword">if</span> p[j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span> &#123;<br>            dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j<span class="hljs-number">-2</span>]<br>        &#125;<br>    &#125;<br>        <br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; S + <span class="hljs-number">1</span>; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; P + <span class="hljs-number">1</span>; j++ &#123;<br>            <span class="hljs-keyword">if</span> j &lt; P &amp;&amp; p[j] == <span class="hljs-string">&#x27;*&#x27;</span> &#123;<br>                <span class="hljs-comment">// skip if this character is followed by *</span><br>                <span class="hljs-keyword">continue</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> p[j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;*&#x27;</span> &#123;<br>                dp[i][j] = dp[i][j - <span class="hljs-number">2</span>]<br>                <span class="hljs-keyword">if</span> p[j<span class="hljs-number">-2</span>] == <span class="hljs-string">&#x27;.&#x27;</span> || s[i<span class="hljs-number">-1</span>] == p[j<span class="hljs-number">-2</span>] &#123;<br>                    dp[i][j] = dp[i][j] || dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-2</span>] || dp[i<span class="hljs-number">-1</span>][j]<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> p[j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;.&#x27;</span> || s[i<span class="hljs-number">-1</span>] == p[j<span class="hljs-number">-1</span>] &#123;<br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[S][P]<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#42-trapping-rain-water" class="header-anchor">#</a><span id="42-trapping-rain-water"> 42. Trapping Rain Water</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/trapping-rain-water/">leetcode</a></p>
<p><strong>Column Searching</strong></p>
<p>The main idea is to find the maximum wall from the target column i. The first and the last wall do not count.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trap</span><span class="hljs-params">(height []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    sum := <span class="hljs-number">0</span><br>    N := <span class="hljs-built_in">len</span>(height)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; N; i++ &#123;<br>        <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> || i == N - <span class="hljs-number">1</span> &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        left := height[i]<br>        right := height[i]<br>        <span class="hljs-keyword">for</span> r := i + <span class="hljs-number">1</span>; r &lt; N; r++ &#123;<br>            <span class="hljs-keyword">if</span> height[r] &gt; right &#123;<br>                right = height[r]<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> l := i - <span class="hljs-number">1</span>; l &gt;= <span class="hljs-number">0</span>; l-- &#123;<br>            <span class="hljs-keyword">if</span> height[l] &gt; left &#123;<br>                left = height[l]<br>            &#125;<br>        &#125;<br>        sum += min(left, right) - height[i]<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Dynamic Programming</strong></p>
<p>Use an array to store the max height.<br>
maxLeft[i] = max(height[i], maxLeft[i - 1]);<br>
maxRight[i] = max(height[i], maxRight[i + 1]);</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trap</span><span class="hljs-params">(height []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(height) &lt; <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    sum := <span class="hljs-number">0</span><br>    N := <span class="hljs-built_in">len</span>(height)<br>    maxLeft := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, N)<br>    maxRight := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, N)<br>    maxLeft[<span class="hljs-number">0</span>] = height[<span class="hljs-number">0</span>]<br>    maxRight[N<span class="hljs-number">-1</span>] = height[N<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; N; i++ &#123;<br>        maxLeft[i] = max(maxLeft[i<span class="hljs-number">-1</span>], height[i])<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := N - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        maxRight[i] = max(maxRight[i + <span class="hljs-number">1</span>], height[i])<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; N; i++ &#123;<br>        sum += min(maxLeft[i], maxRight[i]) - height[i]<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Double Pointer</strong></p>
<p>Optimization to DP Solution.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trap</span><span class="hljs-params">(height []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    left, right := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(height)<span class="hljs-number">-1</span><br>    leftMax, rightMax := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> left &lt; right &#123;<br>        leftMax = max(leftMax, height[left])<br>        rightMax = max(rightMax, height[right])<br>        <span class="hljs-keyword">if</span> height[left] &lt; height[right] &#123;<br>            ans += leftMax - height[left]<br>            left++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ans += rightMax - height[right]<br>            right--<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#44-wildcard-matching" class="header-anchor">#</a><span id="44-wildcard-matching"> 44. Wildcard Matching</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/wildcard-matching/">leetcode</a></p>
<p>This is similar to 10 but simpler because the wildcard character are not combined.<br>
Consider it as a dp problem.<br>
First determine the dp table, dp[i][j] means whether p[i-1] can match s[i-1].</p>
<ol>
<li>If current p[i-1] is star, then dp[i][j] compares s[i-1] and p[j-1].</li>
<li>star matches 0 or more characters. dp[i][j] at least equals to dp[i][j-1], which ignores the last characters of p or dp[i][j] equals to dp[i-1][j], which ignores the last character of s.</li>
<li>If current p[i-1] is dot, which matches any single character. dp[i][j] = dp[i-1][j-1].</li>
<li>If current p[i-1] equals s[i-1], which matches any single character. dp[i][j] = dp[i-1][j-1].</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(s <span class="hljs-type">string</span>, p <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    S, P := <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">len</span>(p)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>, S+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; S+<span class="hljs-number">1</span>; i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, P+<span class="hljs-number">1</span>)<br>    &#125;<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; P+<span class="hljs-number">1</span>; j++ &#123;<br>        <span class="hljs-keyword">if</span> p[j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;*&#x27;</span> &#123;<br>            dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j<span class="hljs-number">-1</span>]<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; S+<span class="hljs-number">1</span>; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; P+<span class="hljs-number">1</span>; j++ &#123;<br>            <span class="hljs-keyword">if</span> p[j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;*&#x27;</span> &#123;<br>                dp[i][j] = dp[i][j<span class="hljs-number">-1</span>] || dp[i<span class="hljs-number">-1</span>][j]<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> p[j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;?&#x27;</span> || s[i<span class="hljs-number">-1</span>] == p[j<span class="hljs-number">-1</span>] &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[S][P]<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#55-jump-game" class="header-anchor">#</a><span id="55-jump-game"> 55. Jump Game</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/jump-game/">leetcode</a></p>
<p><strong>Greedy</strong><br>
Let’s say the range of current jump is [curBegin, curEnd], curFarthest is the farthest point that all points is [curBegin, curEnd] can reach. Once the current point reaches curEnd, then trigger another jump and set the new curEnd with curFarthest.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canJump</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    curEnd, curFarthest := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>; i++ &#123;<br>        <span class="hljs-keyword">if</span> i + nums[i] &gt; curFarthest &#123;<br>            curFarthest = i + nums[i]<br>        &#125;<br>        <span class="hljs-keyword">if</span> i == curEnd &#123;<br>            curEnd = curFarthest<br>            <span class="hljs-keyword">if</span> curEnd &gt;= <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>DP</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canJump</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, n)<br>    dp[n - <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span><br>        <br>    <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        maxJump := min(i + nums[i], n - <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt;= maxJump; j++ &#123;<br>            dp[i] = dp[i] || dp[j]<br>        &#125;<br>    &#125;<br>                <br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#45-jump-game-ii" class="header-anchor">#</a><span id="45-jump-game-ii"> 45. Jump Game II</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/jump-game-ii/">leetcode</a></p>
<p><strong>Dynamic Programming</strong><br>
This can be converted to a dp problem.<br>
First, determine dp array, dp[i] means the minimum number of jumps from n - 1 to i.<br>
Second, determine the iteration formula. For each index i, iterate j over i + 1 to maxJump, in which maxJump equals i + nums[i]. dp[i] = min(dp[i], dp[j] + 1).<br>
Third, Initialize dp[n-1] = 0, because we only need to jump 0 times to n-1.<br>
Fourth, determine the traversal order. We need two variables, i iterates from n - 2 to 0, j iterates from i + 1 to the maxJump of i.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">jump</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++ &#123;<br>        dp[i] = math.MaxInt32<br>    &#125;<br>    dp[n - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br>        <br>    <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        maxJump := min(i + nums[i], n - <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt;= maxJump; j++ &#123;<br>            dp[i] = min(dp[i], dp[j] + <span class="hljs-number">1</span>)<br>        &#125;<br>    &#125;<br>                <br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Greedy</strong><br>
Let’s say the range of current jump is [curBegin, curEnd], curFarthest is the farthest point that all points is [curBegin, curEnd] can reach. Once the current point reaches curEnd, then trigger another jump and set the new curEnd with curFarthest.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">jump</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    curEnd, curFarthest := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    jumps := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>; i++ &#123;<br>        <span class="hljs-keyword">if</span> i + nums[i] &gt; curFarthest &#123;<br>            curFarthest = i + nums[i]<br>        &#125;<br>        <span class="hljs-keyword">if</span> i == curEnd &#123;<br>            jumps++<br>            curEnd = curFarthest<br>            <span class="hljs-keyword">if</span> curEnd &gt; <span class="hljs-built_in">len</span>(nums) &#123;<br>                <span class="hljs-keyword">break</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> jumps<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#1306-jump-game-iii" class="header-anchor">#</a><span id="1306-jump-game-iii"> 1306. Jump Game III</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/jump-game-iii/">leetcode</a></p>
<p>At first glance, we could use BFS search. Because you can only jump to either i + arr[i] or i - arr[i], the algorithm complexity is O(2N). Because the arr is non-negative, we can use its negativity marked as traversed.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canReach</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, start <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> start &gt;= <span class="hljs-number">0</span> &amp;&amp; start &lt; <span class="hljs-built_in">len</span>(arr) &amp;&amp; arr[start] &gt;= <span class="hljs-number">0</span> &#123;<br>        arr[start] = -arr[start]<br>        <span class="hljs-keyword">return</span> arr[start] == <span class="hljs-number">0</span> || canReach(arr, start + arr[start]) || canReach(arr, start - arr[start])<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#1871-jump-game-vii" class="header-anchor">#</a><span id="1871-jump-game-vii"> 1871. Jump Game VII</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/jump-game-vii/">leetcode</a></p>
<p>It’s a bottom-up DP implementation. The boolean value represents whether this position is reachable from start. So the first step is to generate the table. Here the table was pre-labeled True or False, thus '1’s are already labeled False.<br>
To determine the state of dp[i], one need to check the states in window dp[i-maxJ : i-minJ], because any one of them can reach i if it’s labeled True.<br>
Then you need to check if there is a True in this window. Notice that this is a sliding window problem, so you don’t need to calculate it everytime. You only need to remove the effect from dp[i-maxJ-1] and add the dp[i-minJ]. This is done by these two lines of code pre += dp[i - minJ] and pre -= dp[i - maxJ - 1]<br>
The if statements if i &gt;= minJ: and if i &gt; maxJ: are dealing with the initial boundary.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canReach</span><span class="hljs-params">(s <span class="hljs-type">string</span>, minJump <span class="hljs-type">int</span>, maxJump <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(s)<br>    pre := <span class="hljs-number">0</span><br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, n)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">if</span> i &gt;= minJump &amp;&amp; dp[i - minJump] &#123;<br>            pre += <span class="hljs-number">1</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> i &gt; maxJump &amp;&amp; dp[i - maxJump - <span class="hljs-number">1</span>] &#123;<br>            pre -= <span class="hljs-number">1</span><br>        &#125;<br>        dp[i] = pre &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] == <span class="hljs-string">&#x27;0&#x27;</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>]<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#1345-jump-game-iv" class="header-anchor">#</a><span id="1345-jump-game-iv"> 1345. Jump Game IV</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/jump-game-iv/">leetcode</a></p>
<p>We can try brute force bfs search first. But time limit exceeds.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> indices <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>][]<span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> visited []<span class="hljs-type">bool</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minJumps</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(arr)<br>    indices = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>][]<span class="hljs-type">int</span>)<br>    visited = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, n)<br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> arr &#123;<br>        <span class="hljs-keyword">if</span> _, exists := indices[v]; exists &#123;<br>            indices[v] = <span class="hljs-built_in">append</span>(indices[v], i) <br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            indices[v] = []<span class="hljs-type">int</span>&#123;i&#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> bfs(arr, <span class="hljs-number">0</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bfs</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, index <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-built_in">len</span>(arr) &#123;<br>        <span class="hljs-keyword">return</span> math.MaxInt32<br>    &#125;<br>    <span class="hljs-keyword">if</span> visited[index] &#123;<br>        <span class="hljs-keyword">return</span> math.MaxInt32<br>    &#125;<br>    <span class="hljs-keyword">if</span> index == <span class="hljs-built_in">len</span>(arr) - <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    visited[index] = <span class="hljs-literal">true</span><br>    step := math.MaxInt32<br>    step = min(step, bfs(arr, index+<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>)<br>    step = min(step, bfs(arr, index<span class="hljs-number">-1</span>)+<span class="hljs-number">1</span>)<br>    indiceList, exists := indices[arr[index]]<br>    <span class="hljs-keyword">if</span> exists &#123;<br>        <span class="hljs-keyword">for</span> _, i := <span class="hljs-keyword">range</span> indiceList &#123;<br>            step = min(step, bfs(arr, i)+<span class="hljs-number">1</span>)<br>        &#125;<br>    &#125;<br>    visited[index] = <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">return</span> step<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Optimization with iteration. The first one reaches the end is the minimum number of steps.<br>
The first visit is the minimum number of steps. Clear the indices map to avoid revisiting.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minJumps</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(arr)<br>    indices := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>][]<span class="hljs-type">int</span>)<br>    visited := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, n)<br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> arr &#123;<br>        <span class="hljs-keyword">if</span> _, exists := indices[v]; exists &#123;<br>            indices[v] = <span class="hljs-built_in">append</span>(indices[v], i) <br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            indices[v] = []<span class="hljs-type">int</span>&#123;i&#125;<br>        &#125;<br>    &#125;<br>    queue := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(arr))<br>    queue = <span class="hljs-built_in">append</span>(queue, []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;)<br>    <br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        q := queue[<span class="hljs-number">0</span>]<br>        step, index := q[<span class="hljs-number">0</span>], q[<span class="hljs-number">1</span>]<br>        queue = queue[<span class="hljs-number">1</span>:]<br>        <span class="hljs-keyword">if</span> index == n - <span class="hljs-number">1</span> &#123;<br>            <span class="hljs-keyword">return</span> step<br>        &#125;<br>        <br>        left := index - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> left &gt; <span class="hljs-number">0</span> &amp;&amp; !visited[left] &#123;<br>            visited[left] = <span class="hljs-literal">true</span><br>            queue = <span class="hljs-built_in">append</span>(queue, []<span class="hljs-type">int</span>&#123;step + <span class="hljs-number">1</span>, left&#125;)<br>        &#125;<br>        right := index + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> right &lt; n &amp;&amp; !visited[right] &#123;<br>            visited[right] = <span class="hljs-literal">true</span><br>            queue = <span class="hljs-built_in">append</span>(queue, []<span class="hljs-type">int</span>&#123;step + <span class="hljs-number">1</span>, right&#125;)<br>        &#125;<br>        <br>        vals, exists := indices[arr[index]]<br>        <span class="hljs-keyword">if</span> exists &#123;<br>            <span class="hljs-keyword">for</span> _, neib := <span class="hljs-keyword">range</span> vals &#123;<br>                <span class="hljs-keyword">if</span> !visited[neib] &#123;<br>                    visited[neib] = <span class="hljs-literal">true</span><br>                    queue = <span class="hljs-built_in">append</span>(queue, []<span class="hljs-type">int</span>&#123;step + <span class="hljs-number">1</span>, neib&#125;)<br>                &#125;<br>            &#125;<br>            indices[arr[index]] = []<span class="hljs-type">int</span>&#123;&#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#62-unique-paths" class="header-anchor">#</a><span id="62-unique-paths"> 62. Unique Paths</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/unique-paths/">leetcode</a></p>
<p>It’s a typical combinatorial problem, which should be:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><mrow><mi>m</mi><mo>+</mo><mi>n</mi></mrow><mi>m</mi></mfrac><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">m+n \choose m 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.26033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">m</span></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span></span></span></span></span></p>
<p>But we can also use DP to solve this problem.</p>
<p>First determine the dp array, dp[i][j] means the number of possible unique paths to the ixj grid.<br>
Second, determine the iteration formula. dp[i][j] is dependent on dp[i-1][j] and dp[i][j-1]. dp[i][j] = dp[i-1][j] + dp[i][j-1]<br>
Third, initialize the array. dp[0][0] = 1. And grids with 1 width or 1 height only have 1 possible unique paths.<br>
Fourth, determine the traversal order. It must be from left to right, and bottom to top.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(m <span class="hljs-type">int</span>, n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m; i ++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>            dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i][j<span class="hljs-number">-1</span>]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>]<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#63-unique-paths-ii" class="header-anchor">#</a><span id="63-unique-paths-ii"> 63. Unique Paths II</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/unique-paths-ii/">leetcode</a></p>
<p>It’s similar to 62, but be cautious to the initialization of the array. And if dp[i][j] is occupied by an obstacle, there is no path to it.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(obstacleGrid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-built_in">len</span>(obstacleGrid)<br>    n := <span class="hljs-built_in">len</span>(obstacleGrid[<span class="hljs-number">0</span>])<br>    <br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m; i ++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>; i++ &#123;<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n &amp;&amp; obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>; j++ &#123;<br>        dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>            <span class="hljs-keyword">if</span> obstacleGrid[i][j] == <span class="hljs-number">1</span> &#123;<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i][j<span class="hljs-number">-1</span>]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>]<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#980-unique-paths-iii" class="header-anchor">#</a><span id="980-unique-paths-iii"> 980. Unique Paths III</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/unique-paths-iii/">leetcode</a></p>
<p>It seems that dp cannot solve this problem. Try DFS.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> empty <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> res <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">uniquePathsIII</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// Take account of the ending cell</span><br>    empty = <span class="hljs-number">1</span><br>    res = <span class="hljs-number">0</span><br>    startX, startY := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(grid); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>]); j++ &#123;<br>            <span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-number">1</span> &#123;<br>                startX = i<br>                startY = j<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-number">0</span> &#123;<br>                empty++<br>            &#125;<br>        &#125;<br>    &#125;<br>    dfs(grid, startX, startY, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>, x, y <span class="hljs-type">int</span>, count <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span> || x &gt;= <span class="hljs-built_in">len</span>(grid) || y &gt;= <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>]) || grid[x][y] == <span class="hljs-number">-1</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> grid[x][y] == <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">if</span> count == empty &#123;<br>            res++<br>        &#125;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// Used as visited</span><br>    grid[x][y] = <span class="hljs-number">-1</span><br>    <br>    dfs(grid, x<span class="hljs-number">-1</span>, y, count+<span class="hljs-number">1</span>)<br>    dfs(grid, x, y<span class="hljs-number">-1</span>, count+<span class="hljs-number">1</span>)<br>    dfs(grid, x+<span class="hljs-number">1</span>, y, count+<span class="hljs-number">1</span>)<br>    dfs(grid, x, y+<span class="hljs-number">1</span>, count+<span class="hljs-number">1</span>)<br>    <br>    grid[x][y] = <span class="hljs-number">0</span><br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#64-minimum-path-sum" class="header-anchor">#</a><span id="64-minimum-path-sum"> 64. Minimum Path Sum</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-path-sum/">leetcode</a></p>
<p>A dp problem.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m, n := <span class="hljs-built_in">len</span>(grid), <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> grid &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    &#125;<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; m; i++ &#123;<br>        dp[i][<span class="hljs-number">0</span>] = dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] + grid[i][<span class="hljs-number">0</span>]<br>    &#125;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>        dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>] + grid[<span class="hljs-number">0</span>][j]<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>            dp[i][j] = grid[i][j] + min(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>])<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#70-climbing-stairs" class="header-anchor">#</a><span id="70-climbing-stairs"> 70. Climbing Stairs</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/climbing-stairs/">leetcode</a></p>
<p>It’s basically fibonacci problem.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">return</span> n<br>    &#125;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>    dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">3</span>; i &lt;= n; i++ &#123;<br>        dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>]<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n]<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#746-min-cost-climbing-stairs" class="header-anchor">#</a><span id="746-min-cost-climbing-stairs"> 746. Min Cost Climbing Stairs</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/min-cost-climbing-stairs/">leetcode</a></p>
<p>It could be solved by dp.<br>
First dp[i] means the minimum cost to reach the ith floor.<br>
Second dp[i] = min(dp[i-1], dp[i-2]) + cost[i]<br>
Third initialize dp[0] = cost[0], dp[1] = cost[1]<br>
Fourth traverse from left to right.<br>
Finally return the minimum of the last two dp elements.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(cost []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(cost)<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    dp[<span class="hljs-number">0</span>], dp[<span class="hljs-number">1</span>] = cost[<span class="hljs-number">0</span>], cost[<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt; n; i++ &#123;<br>        dp[i] = min(dp[i<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-2</span>]) + cost[i]<br>    &#125;<br>    <span class="hljs-keyword">return</span> min(dp[n - <span class="hljs-number">1</span>], dp[n - <span class="hljs-number">2</span>])<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#72-edit-distance" class="header-anchor">#</a><span id="72-edit-distance"> 72. Edit Distance</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/edit-distance/">leetcode</a></p>
<p>It’s DP problem.<br>
First dp[i][j] means the minimum operations between the first i - 1 characters in word1 and the first j - 1 characters in word2.<br>
Second, if word1[i - 1] == word2[i - 2], there is no need to edit any characters. Otherwise, there’s different operations:</p>
<ol>
<li>word1 deletes an character, so the left i - 2 characters of word1 equals j - 1 characters of word2, dp[i][j] = dp[i - 1][j]</li>
<li>word2 deletes an character, so the left i - 1 characters of word1 equals j - 2 characters of word2, dp[i][j] = dp[i][j - 1]</li>
<li>the addition of character is the reversion of deletion.</li>
<li>substitution, replace word1[i - 1] to match word2[j - 1], dp[i][j] = dp[i - 1][j - 1] + 1<br>
Third, initialize dp[0][0] = 0. For word1’s first i - 1 characters, there must be i operations to the empty word2.<br>
Fourth, left to right. Bottom to up.</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(word1 <span class="hljs-type">string</span>, word2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m, n := <span class="hljs-built_in">len</span>(word1), <span class="hljs-built_in">len</span>(word2)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m+<span class="hljs-number">1</span>; i++ &#123;<br>        dp[i][<span class="hljs-number">0</span>] = i<br>    &#125;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n+<span class="hljs-number">1</span>; j++ &#123;<br>        dp[<span class="hljs-number">0</span>][j] = j<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; m+<span class="hljs-number">1</span>; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; n+<span class="hljs-number">1</span>; j++ &#123;<br>            <span class="hljs-keyword">if</span> word1[i - <span class="hljs-number">1</span>] == word2[j - <span class="hljs-number">1</span>] &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = min(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m][n]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(args ...<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>  min := args[<span class="hljs-number">0</span>]<br>  <span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> args &#123;<br>    <span class="hljs-keyword">if</span> item &lt; min &#123;<br>      min = item<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> min<br>&#125;<br></code></pre></td></tr></table></figure></p></div><div class="share"><span>Share</span>&nbsp;<span class="soc"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></span><span class="soc"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></span><span class="soc"><a target="_blank" rel="noopener" href="http://twitter.com/home?status=https://blog.kleon.space/interview/code/dynamic_programming/%20KLEON%20Code - Dynamic Programming" class="fa fa-twitter"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/interview/code/stack/" title="Code - Stack"><i class="fa fa-angle-double-left"></i>&nbsp;Previous post: Code - Stack</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/interview/code/outline/" title="Code - Outline">Next post: Code - Outline&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2022&nbsp;<a target="_blank" href="https://blog.kleon.space" rel="noopener noreferrer">Kleon</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>