<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>Code - Dynamic Programming · KLEON</title><meta name="description" content="Principles
Problems

Knapsack Problem

0-1 Knapsack
Complete Knapsack


Interval DP

Palindrome


Two Strings

Matching
Operation


Histogram
Subarray"><meta name="og:description" content="Principles
Problems

Knapsack Problem

0-1 Knapsack
Complete Knapsack


Interval DP

Palindrome


Two Strings

Matching
Operation


Histogram
Subarray"><meta name="twitter:site" content="KLEON"><meta name="twitter:title" content="Code - Dynamic Programming"><meta name="twitter:card" content="summary"><meta name="keywords" content=""><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/github.min.css"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.10.2/katex.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 6.1.0"></head><body><div id="stage" class="container"><div class="row"><div id="side-bar" class="col-sm-3 col-xs-12 side-container invisible"><div class="vertical-text site-title"><h3 tabindex="-1" class="site-title-small"><a href="/" class="a-title"></a></h3><h1 tabindex="-1" class="site-title-large"><a href="/" class="a-title">吹拉弹唱</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div id="site-nav" class="site-title-links"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li><li><a href="/categories">Categories</a></li><li><a href="/tags">Tags</a></li><li><a href="/googlebe23cb0bc55fc412.html"></a></li><li><a href="/about/index.html"></a></li><li class="soc"><a href="https://github.com/kleon1024" target="_blank" rel="noopener noreferrer" aria-label="Github"><i class="fa fa-github">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2022&nbsp;<a target="_blank" href="https://blog.kleon.space" rel="noopener noreferrer">Kleon</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div id="main-container" class="col-sm-9 col-xs-12 main-container invisible"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>Code - Dynamic Programming</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2022-05-05</span><span class="date meta-item">Updated at&nbsp;2022-05-05</span><span class="meta-item"><i class="fa fa-folder"></i><span>&nbsp;</span><a href="/categories/interview/" title="interview" class="a-tag">interview</a><span>&nbsp;</span></span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a href="/tags/interview/" title="interview" class="a-tag">interview</a><span>&nbsp;</span><a href="/tags/algorithm/" title="algorithm" class="a-tag">algorithm</a><span>&nbsp;</span></span></p><p class="post-abstract"><div class="toc">
<!-- toc -->
<ul>
<li><a href="#principles">Principles</a></li>
<li><a href="#problems">Problems</a>
<ul>
<li><a href="#knapsack-problem">Knapsack Problem</a>
<ul>
<li><a href="#0-1-knapsack">0-1 Knapsack</a></li>
<li><a href="#complete-knapsack">Complete Knapsack</a></li>
</ul>
</li>
<li><a href="#interval-dp">Interval DP</a>
<ul>
<li><a href="#palindrome">Palindrome</a></li>
</ul>
</li>
<li><a href="#two-strings">Two Strings</a>
<ul>
<li><a href="#matching">Matching</a></li>
<li><a href="#operation">Operation</a></li>
</ul>
</li>
<li><a href="#histogram">Histogram</a></li>
<li><a href="#subarray">Subarray</a>
<ul>
<li><a href="#maximum-sum">Maximum sum</a></li>
<li><a href="#stock">Stock</a></li>
</ul>
</li>
<li><a href="#combination">Combination</a></li>
<li><a href="#path-dfs">Path/DFS</a></li>
<li><a href="#divide-conquer">Divide &amp; Conquer</a></li>
</ul>
</li>
<li><a href="#leetcode">LeetCode</a>
<ul>
<li><a href="#53-maximum-subarray">53. Maximum Subarray</a></li>
<li><a href="#121-best-time-to-buy-and-sell-stock">121. Best Time to Buy and Sell Stock</a></li>
<li><a href="#122-best-time-to-buy-and-sell-stock-ii">122. Best Time to Buy and Sell Stock II</a></li>
<li><a href="#5-longest-palindromic-substring">5. Longest Palindromic Substring</a></li>
<li><a href="#647-palindromic-substrings">647. Palindromic Substrings</a></li>
<li><a href="#516-longest-palindromic-subsequence">516. Longest Palindromic Subsequence</a></li>
<li><a href="#10-regular-expression-matching">10. Regular Expression Matching</a></li>
<li><a href="#42-trapping-rain-water">42. Trapping Rain Water</a></li>
<li><a href="#44-wildcard-matching">44. Wildcard Matching</a></li>
<li><a href="#55-jump-game">55. Jump Game</a></li>
<li><a href="#45-jump-game-ii">45. Jump Game II</a></li>
<li><a href="#1306-jump-game-iii">1306. Jump Game III</a></li>
<li><a href="#1871-jump-game-vii">1871. Jump Game VII</a></li>
<li><a href="#1345-jump-game-iv">1345. Jump Game IV</a></li>
<li><a href="#62-unique-paths">62. Unique Paths</a></li>
<li><a href="#63-unique-paths-ii">63. Unique Paths II</a></li>
<li><a href="#64-minimum-path-sum">64. Minimum Path Sum</a></li>
<li><a href="#70-climbing-stairs">70. Climbing Stairs</a></li>
<li><a href="#746-min-cost-climbing-stairs">746. Min Cost Climbing Stairs</a></li>
<li><a href="#72-edit-distance">72. Edit Distance</a></li>
<li><a href="#85-maximal-rectangle">85. Maximal Rectangle</a></li>
<li><a href="#84-largest-rectangle-in-histogram">84. Largest Rectangle in Histogram</a></li>
<li><a href="#87-scramble-string">87. Scramble String</a></li>
<li><a href="#312-burst-balloons">312. Burst Balloons</a></li>
<li><a href="#1246-palindrome-removal">1246. Palindrome Removal</a></li>
<li><a href="#322-coin-change">322. Coin Change</a></li>
<li><a href="#416-partition-equal-subset-sum">416. Partition Equal Subset Sum</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div>
<h1><a href="#principles" class="header-anchor">#</a><span id="principles"> Principles</span></h1>
<ol>
<li>Determine the dp array (dp table) and the meaning of the subscript</li>
<li>Determine the recurrence formula</li>
<li>How to initialize the dp array</li>
<li>Determine the traversal order</li>
<li>Derive the dp array by example</li>
</ol>
<h1><a href="#problems" class="header-anchor">#</a><span id="problems"> Problems</span></h1>
<h2><a href="#knapsack-problem" class="header-anchor">#</a><span id="knapsack-problem"> Knapsack Problem</span></h2>
<h3><a href="#0-1-knapsack" class="header-anchor">#</a><span id="0-1-knapsack"> 0-1 Knapsack</span></h3>
<p><a href="#416-partition-equal-subset-sum">416. Partition Equal Subset Sum</a> Valid.</p>
<h3><a href="#complete-knapsack" class="header-anchor">#</a><span id="complete-knapsack"> Complete Knapsack</span></h3>
<p><a href="#322-coin-change">322. Coin Change</a> Minimum weight.</p>
<h2><a href="#interval-dp" class="header-anchor">#</a><span id="interval-dp"> Interval DP</span></h2>
<h3><a href="#palindrome" class="header-anchor">#</a><span id="palindrome"> Palindrome</span></h3>
<p><a href="#5-longest-palindromic-substring">5. Longest Palindromic Substring</a> Check if valid. Contiguous.<br>
<a href="#647-palindromic-substrings">647. Palindromic Substrings</a> Find the number of all possible combinations. Contiguous.<br>
<a href="#516-longest-palindromic-subsequence">516. Longest Palindromic Subsequence</a> Find the length of longest subsequence. Not contiguous.</p>
<h2><a href="#two-strings" class="header-anchor">#</a><span id="two-strings"> Two Strings</span></h2>
<h3><a href="#matching" class="header-anchor">#</a><span id="matching"> Matching</span></h3>
<p><a href="#10-regular-expression-matching">10. Regular Expression Matching</a> Matching. Valid.<br>
<a href="#44-wildcard-matching">44. Wildcard Matching</a> Matching. Valid.</p>
<h3><a href="#operation" class="header-anchor">#</a><span id="operation"> Operation</span></h3>
<p><a href="#72-edit-distance">72. Edit Distance</a></p>
<h2><a href="#histogram" class="header-anchor">#</a><span id="histogram"> Histogram</span></h2>
<p><a href="#42-trapping-rain-water">42. Trapping Rain Water</a>. Area. Bidirectional Search. DP(Memorized Search). Two pointer. Monolithic Stack.<br>
<a href="#84-largest-rectangle-in-histogram">84. Largest Rectangle in Histogram</a>. Area. Bidirectional Search. DP(Memorized Search). Monolithic Stack.<br>
<a href="#85-maximal-rectangle">85. Maximal Rectangle</a>. Area. Based on 84 for each Row. DP(Memorized Search based on last row).</p>
<h2><a href="#subarray" class="header-anchor">#</a><span id="subarray"> Subarray</span></h2>
<h3><a href="#maximum-sum" class="header-anchor">#</a><span id="maximum-sum"> Maximum sum</span></h3>
<p><a href="#53-maximum-subarray">53. Maximum Subarray</a></p>
<h3><a href="#stock" class="header-anchor">#</a><span id="stock"> Stock</span></h3>
<p><a href="#121-best-time-to-buy-and-sell-stock">121. Best Time to Buy and Sell Stock</a><br>
<a href="#122-best-time-to-buy-and-sell-stock-ii">122. Best Time to Buy and Sell Stock II</a></p>
<h2><a href="#combination" class="header-anchor">#</a><span id="combination"> Combination</span></h2>
<p><a href="#62-unique-paths">62. Unique Paths</a> Combinatorial number. DP.<br>
<a href="#63-unique-paths-ii">63. Unique Paths II</a> With Obstacle.<br>
<a href="#70-climbing-stairs">70. Climbing Stairs</a> 1 or 2 steps. What if 1…N Steps. Find all combinations.<br>
<a href="#746-min-cost-climbing-stairs">746. Min Cost Climbing Stairs</a> Options with cost. Find the minimum cost.</p>
<h2><a href="#path-dfs" class="header-anchor">#</a><span id="path-dfs"> Path/DFS</span></h2>
<p><a href="#64-minimum-path-sum">64. Minimum Path Sum</a> Find the minimum path.<br>
<a href="#87-scramble-string">87. Scramble String</a> Check path valid.</p>
<h2><a href="#divide-amp-conquer" class="header-anchor">#</a><span id="divide-amp-conquer"> Divide &amp; Conquer</span></h2>
<p><a href="#312-burst-balloons">312. Burst Balloons</a><br>
<a href="#1246-palindrome-removal">1246. Palindrome Removal</a></p>
<h1><a href="#leetcode" class="header-anchor">#</a><span id="leetcode"> LeetCode</span></h1>
<h2><a href="#53-maximum-subarray" class="header-anchor">#</a><span id="53-maximum-subarray"> 53. Maximum Subarray</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-subarray/">leetcode</a></p>
<p><strong>A general dp solution.</strong></p>
<p>The question is quite clear. I only need to return the maximum sum rather the specific subarray.<br>
The first method comes into my mind is the dynamic programming. The maximum sum of the subarray with the index from 0 to N - 1, in which N is the length of the input array, is the larger one between the sum of the subarray with the index between 0 to N-2 adding the N-1 th element, and the N-1 th element which means reset the sum. So we can find the maximum sum of the subarray during the iteration.</p>
<p>Therefore, we can determine the dp array which means the maximum sum of the subarray between the index 0 to subscript i.<br>
And the recurrence formula is:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">dp[i] = <span class="hljs-title function_">max</span>(nums[i], dp[i - <span class="hljs-number">1</span>] + nums[i])<br></code></pre></td></tr></table></figure>
<p>And initializing the dp array. The dp[0] means the maximum array from 0 to 0, which exactly is nums[0].<br>
The traversal order is incremental.<br>
And manually validate our assumptions with an example.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    N := <span class="hljs-built_in">len</span>(nums)<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, N)<br>    dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>    result := dp[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; N; i++ &#123;<br>        dp[i] = max(nums[i], dp[i - <span class="hljs-number">1</span>] + nums[i])<br>        <span class="hljs-keyword">if</span> (dp[i] &gt; result) &#123;<br>            result = dp[i]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p><strong>A greedy solution</strong><br>
We keep a sum of the contiguous subarray adding each new element. Once the sum is less than 0, we reset the sum to 0. Any negative number could reduces the sum, and if the sum is already negative, we’re choosing the large one between the sum of the contiguous subarray and the next element, or simply the next element. The larger one must be the later, which is exactly resetting the sum to 0.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    sum := <span class="hljs-number">0</span><br>    max := math.MinInt64<br>    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>        sum += num<br>        <span class="hljs-keyword">if</span> sum &gt; max &#123;<br>            max = sum<br>        &#125;<br>        <span class="hljs-keyword">if</span> sum &lt; <span class="hljs-number">0</span> &#123;<br>            sum = <span class="hljs-number">0</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> max<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#121-best-time-to-buy-and-sell-stock" class="header-anchor">#</a><span id="121-best-time-to-buy-and-sell-stock"> 121. Best Time to Buy and Sell Stock</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">leetcode</a></p>
<p><strong>Greedy Solution</strong></p>
<p>The constraint is I have to sell the stock in a day after buying. So the first method could be finding the minimum value from the left and the maximum value from the right. And the difference between these two numbers is the maximum profit.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    profit := <span class="hljs-number">0</span><br>    low := math.MaxInt64<br>    <span class="hljs-keyword">for</span> _, price := <span class="hljs-keyword">range</span> prices &#123;<br>        low = min(low, price)<br>        profit = max(profit, price - low)<br>    &#125;<br>    <span class="hljs-keyword">return</span> profit<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure>
<p>optimized</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    profit := <span class="hljs-number">0</span><br>    low := prices[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> _, price := <span class="hljs-keyword">range</span> prices &#123;<br>        <span class="hljs-keyword">if</span> price &lt; low &#123;<br>            low = price<br>        &#125;<br>        <span class="hljs-keyword">if</span> profit &lt; price - low &#123;<br>            profit = price - low<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> profit<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h2><a href="#122-best-time-to-buy-and-sell-stock-ii" class="header-anchor">#</a><span id="122-best-time-to-buy-and-sell-stock-ii"> 122. Best Time to Buy and Sell Stock II</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">leetcode</a></p>
<p><strong>Greedy Solution</strong></p>
<p>Since we could only hold one share of stock and we can buy and sell at any time, so we could break the profit down to a single day, and we only count the days which have a positive profit.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">func maxProfit(prices []int) int &#123;<br>    profit := 0<br>    for i := 1; i &lt; len(prices); i++ &#123;<br>        if (prices[i] &gt; prices[i - 1]) &#123;<br>            profit += prices[i] - prices[i - 1]<br>        &#125;<br>    &#125;<br>    return profit<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#5-longest-palindromic-substring" class="header-anchor">#</a><span id="5-longest-palindromic-substring"> 5. Longest Palindromic Substring</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-palindromic-substring/">leetcode</a></p>
<p><strong>DP</strong></p>
<p>Is the substring contiguous? Yes<br>
If multiple substrings are found, which one should I return? Any of them.</p>
<p>The solution I may have a try is dynamic programming.<br>
First, determine the meaning of dp table <code>dp[i][j]</code>, which means is the substring from the subscript i to j is palindromic. i is less then j. The interval is left closed and right closed.<br>
Second, determine the recursive formula. If s[i] and s[j] are not equal, there is no chance the substring could be palindromic. Therefore, we discuss the details where s[i] and s[j] are equal. There are 3 situations.</p>
<ol>
<li>If i == j, then the substring is a letter, so it must be palindromic.</li>
<li>If j - i == 1, then the substring is like ‘aa’, so it is palindromic.</li>
<li>If j - i &gt; 1, then the substring is depending on dp[i+1][j-1].<br>
Third, determine how to initialize the dp table. dp[0][0] is palindromic, initialize all other elements to false.<br>
Fourth, determine the traversal order.<br>
dp[i + 1][j - 1] is at the bottom left of dp[i][j], so dp[i + 1][j - 1] must be determined before dp[i][j]. So it must be traversed from bottom to top and left to right, so as to ensure that dp[i + 1][j - 1] is calculated.</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    N := <span class="hljs-built_in">len</span>(s)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>, N)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; N; i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, N)<br>    &#125;<br>    left := <span class="hljs-number">0</span><br>    right := <span class="hljs-number">0</span><br>    max := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := N - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">for</span> j := i; j &lt; N; j++ &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == s[j]) &#123;<br>                <span class="hljs-keyword">if</span> j - i &lt;= <span class="hljs-number">1</span> &#123;<br>                    dp[i][j] = <span class="hljs-literal">true</span><br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = <span class="hljs-literal">true</span><br>                &#125;<br>                <span class="hljs-keyword">if</span> dp[i][j] &#123;<br>                    <span class="hljs-keyword">if</span> j - i + <span class="hljs-number">1</span> &gt; max &#123;<br>                        max = j - i + <span class="hljs-number">1</span><br>                        left = i<br>                        right = j<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> s[left:right + <span class="hljs-number">1</span>]<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#647-palindromic-substrings" class="header-anchor">#</a><span id="647-palindromic-substrings"> 647. Palindromic Substrings</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/palindromic-substrings/">leetcode</a></p>
<p>This is similar to 5.</p>
<p><strong>DP</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    N := <span class="hljs-built_in">len</span>(s)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>, N)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; N; i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, N)<br>    &#125;<br>    result := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := N - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">for</span> j := i; j &lt; N; j++ &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == s[j]) &#123;<br>                <span class="hljs-keyword">if</span> j - i &lt;= <span class="hljs-number">1</span> &#123;<br>                    dp[i][j] = <span class="hljs-literal">true</span><br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = <span class="hljs-literal">true</span><br>                &#125;<br>                <span class="hljs-keyword">if</span> dp[i][j] &#123;<br>                    result++<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#516-longest-palindromic-subsequence" class="header-anchor">#</a><span id="516-longest-palindromic-subsequence"> 516. Longest Palindromic Subsequence</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-palindromic-subsequence/">leetcode</a></p>
<p>This is quite similar to 5 other than the situation analysis.<br>
First, determine the meaning of dp table dp[i][j], which means the length of the longest palindromic subsequence from subscript i to j.<br>
Second, determine the recursive formula. If s[i] == s[j], then dp[i][j] = dp[i + 1][j - 1] + 2. If s[i] != s[j], it means that adding s[i] and s[j] at the same time cannot increase the length of the palindrome substring in the interval [i, j], then add s[i] and s respectively. [j] See which one can form the longest palindromic subsequence. The dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]).<br>
Third, initialize the dp array. dp[i][i] = 1.<br>
Fourth, determine the traversal order. dp[i][j] is dependent on dp[i + 1][j - 1] and dp[i + 1][j] and dp[i][j - 1]. So it must be traversed from bottom to top and left to right.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestPalindromeSubseq</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    N := <span class="hljs-built_in">len</span>(s)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, N)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; N; i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, N)<br>        dp[i][i] = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> i := N - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; N; j++ &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == s[j]) &#123;<br>                dp[i][j] = dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">2</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = max(dp[i+<span class="hljs-number">1</span>][j], dp[i][j<span class="hljs-number">-1</span>])<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][N<span class="hljs-number">-1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#10-regular-expression-matching" class="header-anchor">#</a><span id="10-regular-expression-matching"> 10. Regular Expression Matching</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/regular-expression-matching/">leetcode</a></p>
<p>Simply converted to a dp problem.<br>
First, determine the dp table, dp[i][j] means is p[0:j-1] matches s[0:i-1].<br>
Second, determine the recursive formula.</p>
<ol>
<li>If current p (p[j - 1]) is star, dp[i][j] compares s[i-1] and p[i-1]</li>
<li>because * means matching 0 or more, dp[i][j] at least equals to dp[i][j-2], which ignores the last two characters of p.</li>
<li>If p[i-2] is dot, then the condition is relax to dp[i - 1][j - 2].</li>
<li>And if s[i-1] == p[j - 2], current s equals last p, then dp[i][j] = dp[i - 1][j], check if we remove the last character of s, if the rest of s matches p.</li>
<li>If current p is dot, which could match any character, dp[i][j] = dp[i - 1][j - 1], if the shorter substring matches, then current substring matches.</li>
<li>If current p equals to current s, dp[i][j] = dp[i - 1][j - 1], if the shorter substring matches, then current substring matches.</li>
<li>One optimization is if the next character is star, just skip the current comparison.</li>
</ol>
<p>Third initialize the dp table.<br>
dp[0][0] must be true.<br>
Matches the 0-length s with p.</p>
<p>Determine the traversal order. From left to right, bottom to up.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(s <span class="hljs-type">string</span>, p <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    S, P := <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">len</span>(p)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>, S + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; S + <span class="hljs-number">1</span>; i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, P + <span class="hljs-number">1</span>)<br>    &#125;<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span><br>    <br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; P + <span class="hljs-number">1</span>; j++ &#123;<br>        <span class="hljs-keyword">if</span> p[j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span> &#123;<br>            dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j<span class="hljs-number">-2</span>]<br>        &#125;<br>    &#125;<br>        <br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; S + <span class="hljs-number">1</span>; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; P + <span class="hljs-number">1</span>; j++ &#123;<br>            <span class="hljs-keyword">if</span> j &lt; P &amp;&amp; p[j] == <span class="hljs-string">&#x27;*&#x27;</span> &#123;<br>                <span class="hljs-comment">// skip if this character is followed by *</span><br>                <span class="hljs-keyword">continue</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> p[j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;*&#x27;</span> &#123;<br>                dp[i][j] = dp[i][j - <span class="hljs-number">2</span>]<br>                <span class="hljs-keyword">if</span> p[j<span class="hljs-number">-2</span>] == <span class="hljs-string">&#x27;.&#x27;</span> || s[i<span class="hljs-number">-1</span>] == p[j<span class="hljs-number">-2</span>] &#123;<br>                    dp[i][j] = dp[i][j] || dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-2</span>] || dp[i<span class="hljs-number">-1</span>][j]<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> p[j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;.&#x27;</span> || s[i<span class="hljs-number">-1</span>] == p[j<span class="hljs-number">-1</span>] &#123;<br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[S][P]<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#42-trapping-rain-water" class="header-anchor">#</a><span id="42-trapping-rain-water"> 42. Trapping Rain Water</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/trapping-rain-water/">leetcode</a></p>
<p><strong>Column Searching</strong></p>
<p>The main idea is to find the maximum wall from the target column i. The first and the last wall do not count.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trap</span><span class="hljs-params">(height []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    sum := <span class="hljs-number">0</span><br>    N := <span class="hljs-built_in">len</span>(height)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; N; i++ &#123;<br>        <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> || i == N - <span class="hljs-number">1</span> &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        left := height[i]<br>        right := height[i]<br>        <span class="hljs-keyword">for</span> r := i + <span class="hljs-number">1</span>; r &lt; N; r++ &#123;<br>            <span class="hljs-keyword">if</span> height[r] &gt; right &#123;<br>                right = height[r]<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> l := i - <span class="hljs-number">1</span>; l &gt;= <span class="hljs-number">0</span>; l-- &#123;<br>            <span class="hljs-keyword">if</span> height[l] &gt; left &#123;<br>                left = height[l]<br>            &#125;<br>        &#125;<br>        sum += min(left, right) - height[i]<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Dynamic Programming</strong></p>
<p>Use an array to store the max height.<br>
maxLeft[i] = max(height[i], maxLeft[i - 1]);<br>
maxRight[i] = max(height[i], maxRight[i + 1]);</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trap</span><span class="hljs-params">(height []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(height) &lt; <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    sum := <span class="hljs-number">0</span><br>    N := <span class="hljs-built_in">len</span>(height)<br>    maxLeft := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, N)<br>    maxRight := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, N)<br>    maxLeft[<span class="hljs-number">0</span>] = height[<span class="hljs-number">0</span>]<br>    maxRight[N<span class="hljs-number">-1</span>] = height[N<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; N; i++ &#123;<br>        maxLeft[i] = max(maxLeft[i<span class="hljs-number">-1</span>], height[i])<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := N - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        maxRight[i] = max(maxRight[i + <span class="hljs-number">1</span>], height[i])<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; N; i++ &#123;<br>        sum += min(maxLeft[i], maxRight[i]) - height[i]<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Double Pointer</strong></p>
<p>Optimization to DP Solution.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trap</span><span class="hljs-params">(height []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    left, right := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(height)<span class="hljs-number">-1</span><br>    leftMax, rightMax := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> left &lt; right &#123;<br>        leftMax = max(leftMax, height[left])<br>        rightMax = max(rightMax, height[right])<br>        <span class="hljs-keyword">if</span> height[left] &lt; height[right] &#123;<br>            ans += leftMax - height[left]<br>            left++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ans += rightMax - height[right]<br>            right--<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#44-wildcard-matching" class="header-anchor">#</a><span id="44-wildcard-matching"> 44. Wildcard Matching</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/wildcard-matching/">leetcode</a></p>
<p>This is similar to 10 but simpler because the wildcard character are not combined.<br>
Consider it as a dp problem.<br>
First determine the dp table, dp[i][j] means whether p[i-1] can match s[i-1].</p>
<ol>
<li>If current p[i-1] is star, then dp[i][j] compares s[i-1] and p[j-1].</li>
<li>star matches 0 or more characters. dp[i][j] at least equals to dp[i][j-1], which ignores the last characters of p or dp[i][j] equals to dp[i-1][j], which ignores the last character of s.</li>
<li>If current p[i-1] is dot, which matches any single character. dp[i][j] = dp[i-1][j-1].</li>
<li>If current p[i-1] equals s[i-1], which matches any single character. dp[i][j] = dp[i-1][j-1].</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(s <span class="hljs-type">string</span>, p <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    S, P := <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">len</span>(p)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>, S+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; S+<span class="hljs-number">1</span>; i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, P+<span class="hljs-number">1</span>)<br>    &#125;<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; P+<span class="hljs-number">1</span>; j++ &#123;<br>        <span class="hljs-keyword">if</span> p[j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;*&#x27;</span> &#123;<br>            dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j<span class="hljs-number">-1</span>]<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; S+<span class="hljs-number">1</span>; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; P+<span class="hljs-number">1</span>; j++ &#123;<br>            <span class="hljs-keyword">if</span> p[j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;*&#x27;</span> &#123;<br>                dp[i][j] = dp[i][j<span class="hljs-number">-1</span>] || dp[i<span class="hljs-number">-1</span>][j]<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> p[j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;?&#x27;</span> || s[i<span class="hljs-number">-1</span>] == p[j<span class="hljs-number">-1</span>] &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[S][P]<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#55-jump-game" class="header-anchor">#</a><span id="55-jump-game"> 55. Jump Game</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/jump-game/">leetcode</a></p>
<p><strong>Greedy</strong><br>
Let’s say the range of current jump is [curBegin, curEnd], curFarthest is the farthest point that all points is [curBegin, curEnd] can reach. Once the current point reaches curEnd, then trigger another jump and set the new curEnd with curFarthest.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canJump</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    curEnd, curFarthest := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>; i++ &#123;<br>        <span class="hljs-keyword">if</span> i + nums[i] &gt; curFarthest &#123;<br>            curFarthest = i + nums[i]<br>        &#125;<br>        <span class="hljs-keyword">if</span> i == curEnd &#123;<br>            curEnd = curFarthest<br>            <span class="hljs-keyword">if</span> curEnd &gt;= <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>DP</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canJump</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, n)<br>    dp[n - <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span><br>        <br>    <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        maxJump := min(i + nums[i], n - <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt;= maxJump; j++ &#123;<br>            dp[i] = dp[i] || dp[j]<br>        &#125;<br>    &#125;<br>                <br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#45-jump-game-ii" class="header-anchor">#</a><span id="45-jump-game-ii"> 45. Jump Game II</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/jump-game-ii/">leetcode</a></p>
<p><strong>Dynamic Programming</strong><br>
This can be converted to a dp problem.<br>
First, determine dp array, dp[i] means the minimum number of jumps from n - 1 to i.<br>
Second, determine the iteration formula. For each index i, iterate j over i + 1 to maxJump, in which maxJump equals i + nums[i]. dp[i] = min(dp[i], dp[j] + 1).<br>
Third, Initialize dp[n-1] = 0, because we only need to jump 0 times to n-1.<br>
Fourth, determine the traversal order. We need two variables, i iterates from n - 2 to 0, j iterates from i + 1 to the maxJump of i.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">jump</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++ &#123;<br>        dp[i] = math.MaxInt32<br>    &#125;<br>    dp[n - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br>        <br>    <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        maxJump := min(i + nums[i], n - <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt;= maxJump; j++ &#123;<br>            dp[i] = min(dp[i], dp[j] + <span class="hljs-number">1</span>)<br>        &#125;<br>    &#125;<br>                <br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Greedy</strong><br>
Let’s say the range of current jump is [curBegin, curEnd], curFarthest is the farthest point that all points is [curBegin, curEnd] can reach. Once the current point reaches curEnd, then trigger another jump and set the new curEnd with curFarthest.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">jump</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    curEnd, curFarthest := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    jumps := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>; i++ &#123;<br>        <span class="hljs-keyword">if</span> i + nums[i] &gt; curFarthest &#123;<br>            curFarthest = i + nums[i]<br>        &#125;<br>        <span class="hljs-keyword">if</span> i == curEnd &#123;<br>            jumps++<br>            curEnd = curFarthest<br>            <span class="hljs-keyword">if</span> curEnd &gt; <span class="hljs-built_in">len</span>(nums) &#123;<br>                <span class="hljs-keyword">break</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> jumps<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#1306-jump-game-iii" class="header-anchor">#</a><span id="1306-jump-game-iii"> 1306. Jump Game III</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/jump-game-iii/">leetcode</a></p>
<p>At first glance, we could use BFS search. Because you can only jump to either i + arr[i] or i - arr[i], the algorithm complexity is O(2N). Because the arr is non-negative, we can use its negativity marked as traversed.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canReach</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, start <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> start &gt;= <span class="hljs-number">0</span> &amp;&amp; start &lt; <span class="hljs-built_in">len</span>(arr) &amp;&amp; arr[start] &gt;= <span class="hljs-number">0</span> &#123;<br>        arr[start] = -arr[start]<br>        <span class="hljs-keyword">return</span> arr[start] == <span class="hljs-number">0</span> || canReach(arr, start + arr[start]) || canReach(arr, start - arr[start])<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#1871-jump-game-vii" class="header-anchor">#</a><span id="1871-jump-game-vii"> 1871. Jump Game VII</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/jump-game-vii/">leetcode</a></p>
<p>It’s a bottom-up DP implementation. The boolean value represents whether this position is reachable from start. So the first step is to generate the table. Here the table was pre-labeled True or False, thus '1’s are already labeled False.<br>
To determine the state of dp[i], one need to check the states in window dp[i-maxJ : i-minJ], because any one of them can reach i if it’s labeled True.<br>
Then you need to check if there is a True in this window. Notice that this is a sliding window problem, so you don’t need to calculate it everytime. You only need to remove the effect from dp[i-maxJ-1] and add the dp[i-minJ]. This is done by these two lines of code pre += dp[i - minJ] and pre -= dp[i - maxJ - 1]<br>
The if statements if i &gt;= minJ: and if i &gt; maxJ: are dealing with the initial boundary.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canReach</span><span class="hljs-params">(s <span class="hljs-type">string</span>, minJump <span class="hljs-type">int</span>, maxJump <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(s)<br>    pre := <span class="hljs-number">0</span><br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, n)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">if</span> i &gt;= minJump &amp;&amp; dp[i - minJump] &#123;<br>            pre += <span class="hljs-number">1</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> i &gt; maxJump &amp;&amp; dp[i - maxJump - <span class="hljs-number">1</span>] &#123;<br>            pre -= <span class="hljs-number">1</span><br>        &#125;<br>        dp[i] = pre &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] == <span class="hljs-string">&#x27;0&#x27;</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>]<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#1345-jump-game-iv" class="header-anchor">#</a><span id="1345-jump-game-iv"> 1345. Jump Game IV</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/jump-game-iv/">leetcode</a></p>
<p>We can try brute force bfs search first. But time limit exceeds.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> indices <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>][]<span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> visited []<span class="hljs-type">bool</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minJumps</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(arr)<br>    indices = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>][]<span class="hljs-type">int</span>)<br>    visited = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, n)<br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> arr &#123;<br>        <span class="hljs-keyword">if</span> _, exists := indices[v]; exists &#123;<br>            indices[v] = <span class="hljs-built_in">append</span>(indices[v], i) <br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            indices[v] = []<span class="hljs-type">int</span>&#123;i&#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> bfs(arr, <span class="hljs-number">0</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bfs</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, index <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-built_in">len</span>(arr) &#123;<br>        <span class="hljs-keyword">return</span> math.MaxInt32<br>    &#125;<br>    <span class="hljs-keyword">if</span> visited[index] &#123;<br>        <span class="hljs-keyword">return</span> math.MaxInt32<br>    &#125;<br>    <span class="hljs-keyword">if</span> index == <span class="hljs-built_in">len</span>(arr) - <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    visited[index] = <span class="hljs-literal">true</span><br>    step := math.MaxInt32<br>    step = min(step, bfs(arr, index+<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>)<br>    step = min(step, bfs(arr, index<span class="hljs-number">-1</span>)+<span class="hljs-number">1</span>)<br>    indiceList, exists := indices[arr[index]]<br>    <span class="hljs-keyword">if</span> exists &#123;<br>        <span class="hljs-keyword">for</span> _, i := <span class="hljs-keyword">range</span> indiceList &#123;<br>            step = min(step, bfs(arr, i)+<span class="hljs-number">1</span>)<br>        &#125;<br>    &#125;<br>    visited[index] = <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">return</span> step<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Optimization with iteration. The first one reaches the end is the minimum number of steps.<br>
The first visit is the minimum number of steps. Clear the indices map to avoid revisiting.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minJumps</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(arr)<br>    indices := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>][]<span class="hljs-type">int</span>)<br>    visited := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, n)<br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> arr &#123;<br>        <span class="hljs-keyword">if</span> _, exists := indices[v]; exists &#123;<br>            indices[v] = <span class="hljs-built_in">append</span>(indices[v], i) <br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            indices[v] = []<span class="hljs-type">int</span>&#123;i&#125;<br>        &#125;<br>    &#125;<br>    queue := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(arr))<br>    queue = <span class="hljs-built_in">append</span>(queue, []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;)<br>    <br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        q := queue[<span class="hljs-number">0</span>]<br>        step, index := q[<span class="hljs-number">0</span>], q[<span class="hljs-number">1</span>]<br>        queue = queue[<span class="hljs-number">1</span>:]<br>        <span class="hljs-keyword">if</span> index == n - <span class="hljs-number">1</span> &#123;<br>            <span class="hljs-keyword">return</span> step<br>        &#125;<br>        <br>        left := index - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> left &gt; <span class="hljs-number">0</span> &amp;&amp; !visited[left] &#123;<br>            visited[left] = <span class="hljs-literal">true</span><br>            queue = <span class="hljs-built_in">append</span>(queue, []<span class="hljs-type">int</span>&#123;step + <span class="hljs-number">1</span>, left&#125;)<br>        &#125;<br>        right := index + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> right &lt; n &amp;&amp; !visited[right] &#123;<br>            visited[right] = <span class="hljs-literal">true</span><br>            queue = <span class="hljs-built_in">append</span>(queue, []<span class="hljs-type">int</span>&#123;step + <span class="hljs-number">1</span>, right&#125;)<br>        &#125;<br>        <br>        vals, exists := indices[arr[index]]<br>        <span class="hljs-keyword">if</span> exists &#123;<br>            <span class="hljs-keyword">for</span> _, neib := <span class="hljs-keyword">range</span> vals &#123;<br>                <span class="hljs-keyword">if</span> !visited[neib] &#123;<br>                    visited[neib] = <span class="hljs-literal">true</span><br>                    queue = <span class="hljs-built_in">append</span>(queue, []<span class="hljs-type">int</span>&#123;step + <span class="hljs-number">1</span>, neib&#125;)<br>                &#125;<br>            &#125;<br>            indices[arr[index]] = []<span class="hljs-type">int</span>&#123;&#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#62-unique-paths" class="header-anchor">#</a><span id="62-unique-paths"> 62. Unique Paths</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/unique-paths/">leetcode</a></p>
<p>It’s a typical combinatorial problem, which should be:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><mrow><mi>m</mi><mo>+</mo><mi>n</mi></mrow><mi>m</mi></mfrac><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">m+n \choose m 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.26033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">m</span></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span></span></span></span></span></p>
<p>But we can also use DP to solve this problem.</p>
<p>First determine the dp array, dp[i][j] means the number of possible unique paths to the ixj grid.<br>
Second, determine the iteration formula. dp[i][j] is dependent on dp[i-1][j] and dp[i][j-1]. dp[i][j] = dp[i-1][j] + dp[i][j-1]<br>
Third, initialize the array. dp[0][0] = 1. And grids with 1 width or 1 height only have 1 possible unique paths.<br>
Fourth, determine the traversal order. It must be from left to right, and bottom to top.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(m <span class="hljs-type">int</span>, n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m; i ++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>            dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i][j<span class="hljs-number">-1</span>]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>]<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#63-unique-paths-ii" class="header-anchor">#</a><span id="63-unique-paths-ii"> 63. Unique Paths II</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/unique-paths-ii/">leetcode</a></p>
<p>It’s similar to 62, but be cautious to the initialization of the array. And if dp[i][j] is occupied by an obstacle, there is no path to it.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(obstacleGrid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-built_in">len</span>(obstacleGrid)<br>    n := <span class="hljs-built_in">len</span>(obstacleGrid[<span class="hljs-number">0</span>])<br>    <br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m; i ++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>; i++ &#123;<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n &amp;&amp; obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>; j++ &#123;<br>        dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>            <span class="hljs-keyword">if</span> obstacleGrid[i][j] == <span class="hljs-number">1</span> &#123;<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i][j<span class="hljs-number">-1</span>]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>]<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#64-minimum-path-sum" class="header-anchor">#</a><span id="64-minimum-path-sum"> 64. Minimum Path Sum</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-path-sum/">leetcode</a></p>
<p>A dp problem.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m, n := <span class="hljs-built_in">len</span>(grid), <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> grid &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    &#125;<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; m; i++ &#123;<br>        dp[i][<span class="hljs-number">0</span>] = dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] + grid[i][<span class="hljs-number">0</span>]<br>    &#125;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>        dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>] + grid[<span class="hljs-number">0</span>][j]<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>            dp[i][j] = grid[i][j] + min(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>])<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#70-climbing-stairs" class="header-anchor">#</a><span id="70-climbing-stairs"> 70. Climbing Stairs</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/climbing-stairs/">leetcode</a></p>
<p>It’s basically fibonacci problem.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">return</span> n<br>    &#125;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>    dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">3</span>; i &lt;= n; i++ &#123;<br>        dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>]<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n]<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#746-min-cost-climbing-stairs" class="header-anchor">#</a><span id="746-min-cost-climbing-stairs"> 746. Min Cost Climbing Stairs</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/min-cost-climbing-stairs/">leetcode</a></p>
<p>It could be solved by dp.<br>
First dp[i] means the minimum cost to reach the ith floor.<br>
Second dp[i] = min(dp[i-1], dp[i-2]) + cost[i]<br>
Third initialize dp[0] = cost[0], dp[1] = cost[1]<br>
Fourth traverse from left to right.<br>
Finally return the minimum of the last two dp elements.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(cost []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(cost)<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    dp[<span class="hljs-number">0</span>], dp[<span class="hljs-number">1</span>] = cost[<span class="hljs-number">0</span>], cost[<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt; n; i++ &#123;<br>        dp[i] = min(dp[i<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-2</span>]) + cost[i]<br>    &#125;<br>    <span class="hljs-keyword">return</span> min(dp[n - <span class="hljs-number">1</span>], dp[n - <span class="hljs-number">2</span>])<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#72-edit-distance" class="header-anchor">#</a><span id="72-edit-distance"> 72. Edit Distance</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/edit-distance/">leetcode</a></p>
<p>It’s DP problem.<br>
First dp[i][j] means the minimum operations between the first i - 1 characters in word1 and the first j - 1 characters in word2.<br>
Second, if word1[i - 1] == word2[i - 2], there is no need to edit any characters. Otherwise, there’s different operations:</p>
<ol>
<li>word1 deletes an character, so the left i - 2 characters of word1 equals j - 1 characters of word2, dp[i][j] = dp[i - 1][j]</li>
<li>word2 deletes an character, so the left i - 1 characters of word1 equals j - 2 characters of word2, dp[i][j] = dp[i][j - 1]</li>
<li>the addition of character is the reversion of deletion.</li>
<li>substitution, replace word1[i - 1] to match word2[j - 1], dp[i][j] = dp[i - 1][j - 1] + 1<br>
Third, initialize dp[0][0] = 0. For word1’s first i - 1 characters, there must be i operations to the empty word2.<br>
Fourth, left to right. Bottom to up.</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(word1 <span class="hljs-type">string</span>, word2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m, n := <span class="hljs-built_in">len</span>(word1), <span class="hljs-built_in">len</span>(word2)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m+<span class="hljs-number">1</span>; i++ &#123;<br>        dp[i][<span class="hljs-number">0</span>] = i<br>    &#125;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n+<span class="hljs-number">1</span>; j++ &#123;<br>        dp[<span class="hljs-number">0</span>][j] = j<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; m+<span class="hljs-number">1</span>; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; n+<span class="hljs-number">1</span>; j++ &#123;<br>            <span class="hljs-keyword">if</span> word1[i - <span class="hljs-number">1</span>] == word2[j - <span class="hljs-number">1</span>] &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = min(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m][n]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(args ...<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>  min := args[<span class="hljs-number">0</span>]<br>  <span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> args &#123;<br>    <span class="hljs-keyword">if</span> item &lt; min &#123;<br>      min = item<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> min<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#85-maximal-rectangle" class="header-anchor">#</a><span id="85-maximal-rectangle"> 85. Maximal Rectangle</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximal-rectangle/">leetcode</a></p>
<p><strong>DP</strong></p>
<p>Try to find the highest height and the longest right - left distance for each row.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maximalRectangle</span><span class="hljs-params">(matrix [][]<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    rows, cols := <span class="hljs-built_in">len</span>(matrix), <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])<br>    left := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, cols)<br>    right := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, cols)<br>    height := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, cols)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> right &#123;<br>        right[i] = cols<br>    &#125;<br>    <br>    maxA := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; rows; i++ &#123;<br>        cur_left, cur_right := <span class="hljs-number">0</span>, cols<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; cols; j++ &#123;<br>            <span class="hljs-keyword">if</span> matrix[i][j] == <span class="hljs-string">&#x27;1&#x27;</span> &#123;<br>                height[j] = height[j] + <span class="hljs-number">1</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                height[j] = <span class="hljs-number">0</span><br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; cols; j++ &#123;<br>            <span class="hljs-keyword">if</span> matrix[i][j] == <span class="hljs-string">&#x27;1&#x27;</span> &#123;<br>                left[j] = max(left[j], cur_left)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left[j] = <span class="hljs-number">0</span><br>                cur_left = j + <span class="hljs-number">1</span><br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span> j := cols - <span class="hljs-number">1</span>; j &gt;=<span class="hljs-number">0</span> ;j-- &#123;<br>            <span class="hljs-keyword">if</span> matrix[i][j] == <span class="hljs-string">&#x27;1&#x27;</span> &#123;<br>                right[j] = min(right[j], cur_right)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right[j] = cols<br>                cur_right = j<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; cols;j++ &#123;<br>            maxA = max(maxA, (right[j] - left[j]) * height[j])<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxA<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#84-largest-rectangle-in-histogram" class="header-anchor">#</a><span id="84-largest-rectangle-in-histogram"> 84. Largest Rectangle in Histogram</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/largest-rectangle-in-histogram/">leetcode</a></p>
<p><strong>Stack</strong></p>
<p>The basic idea is traversing from left to right. There are 4 possibilities:</p>
<ol>
<li>There’s a rectangle forming just using the height of the current bar which has an area larger than the maxArea previously recorded.</li>
<li>There’s a rectangle forming using the width or entire spread of the area starting from a bar seen long back which has an area larger than the current maxArea</li>
<li>There’s a rectangle forming using width and height of recent tall bars which has an area larger than the current maxArea.</li>
<li>There’s no rectangle with larger area at this step.<br>
So we have to find the possible bars which may form a larger rectangle and eliminate the impossible bars when we encounter a bar less than the bar we’ve before. So the stack is come into my mind.</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(heights []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(heights)<br>    stack := []<span class="hljs-type">int</span>&#123;&#125;<br>    stack = <span class="hljs-built_in">append</span>(stack, <span class="hljs-number">-1</span>)<br>    heights = <span class="hljs-built_in">append</span>(heights, <span class="hljs-number">0</span>)<br>    ans := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i, height := <span class="hljs-keyword">range</span> heights &#123;<br>        <span class="hljs-keyword">for</span> &#123;<br>            idx := stack[<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">if</span> idx == <span class="hljs-number">-1</span> &#123;<br>                idx = n<br>            &#125;<br>            <span class="hljs-keyword">if</span> heights[idx] &lt;= height &#123;<br>                <span class="hljs-keyword">break</span><br>            &#125;<br>            h := heights[idx]<br>            stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>            w := i - stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] - <span class="hljs-number">1</span><br>            area := h * w<br>            <span class="hljs-keyword">if</span> area &gt; ans &#123;<br>                ans = area<br>            &#125;<br>        &#125;<br>        stack = <span class="hljs-built_in">append</span>(stack, i)<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Two pointer</strong></p>
<p>To find the last index from both the left and right where heights[l] &gt;= heights[i] and heights[r] &gt;= heights[i]</p>
<h2><a href="#87-scramble-string" class="header-anchor">#</a><span id="87-scramble-string"> 87. Scramble String</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/scramble-string/">leetcode</a></p>
<p><strong>Recursive</strong></p>
<p>Straight forward way to check all possible substring by dividing the string into two parts and check whether both two parts are scrambled.<br>
But unfortunately, simple recursive solution will get a time limit exceed error. We have to optimize using premature exit and memorization.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> store <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isScramble</span><span class="hljs-params">(s1 <span class="hljs-type">string</span>, s2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> store == <span class="hljs-literal">nil</span> &#123;<br>        store = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>)<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s1) != <span class="hljs-built_in">len</span>(s2) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> s1 == s2 &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-comment">// shortcut to check the frequency of the letters</span><br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> s1 &#123;<br>        m[s1[i]]++<br>        m[s2[i]]--<br>    &#125;<br>    <span class="hljs-keyword">for</span> _, count := <span class="hljs-keyword">range</span> m &#123;<br>        <span class="hljs-keyword">if</span> count &gt; <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> val, ok := store[s1+s2]; ok &#123;<br>        <span class="hljs-keyword">return</span> val<br>    &#125;<br>    <br>    n := <span class="hljs-built_in">len</span>(s1)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= n - <span class="hljs-number">1</span>; i++ &#123;<br>        <span class="hljs-keyword">if</span> isScramble(s1[:i], s2[:i]) &amp;&amp; isScramble(s1[i:], s2[i:]) &#123;<br>            store[s1 + s2] = <span class="hljs-literal">true</span><br>            store[s2 + s1] = <span class="hljs-literal">true</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> isScramble(s1[:i], s2[n-i:]) &amp;&amp; isScramble(s1[i:], s2[:n-i]) &#123;<br>            store[s1 + s2] = <span class="hljs-literal">true</span><br>            store[s2 + s1] = <span class="hljs-literal">true</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br>    store[s1 + s2] = <span class="hljs-literal">false</span><br>    store[s2 + s1] = <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>DP</strong></p>
<p>DP is generalized from the memorized recursive solution. The dp[i][j][k] means whether the k length substring from i, j respectively are scramble strings.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isScramble</span><span class="hljs-params">(s1 <span class="hljs-type">string</span>, s2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> s1 == s2 &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s1) != <span class="hljs-built_in">len</span>(s2) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    n := <span class="hljs-built_in">len</span>(s1)<br>    dp := <span class="hljs-built_in">make</span>([][][]<span class="hljs-type">bool</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>, n)<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> dp[i] &#123;<br>            dp[i][j] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, n+<span class="hljs-number">1</span>)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n; j++ &#123;<br>            dp[i][j][<span class="hljs-number">1</span>] = s1[i] == s2[j]<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> l := <span class="hljs-number">2</span>; l &lt;= n; l++ &#123;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= n - l; i++ &#123;<br>            <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt;= n - l; j++ &#123;<br>                <span class="hljs-keyword">for</span> k := <span class="hljs-number">1</span>; k &lt; l; k++&#123;<br>                    a := dp[i][j][k] &amp;&amp; dp[i + k][j + k][l - k]<br>                    b := dp[i][j + l - k][k] &amp;&amp; dp[i + k][j][l - k]<br>                    <span class="hljs-keyword">if</span> a || b &#123;<br>                        dp[i][j][l] = <span class="hljs-literal">true</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][n]<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#312-burst-balloons" class="header-anchor">#</a><span id="312-burst-balloons"> 312. Burst Balloons</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/burst-balloons/">leetcode</a></p>
<p>We could describe the whole process in reverse. Suppose we have a open interval (i, j), and the kth ballon is the last ballon which will be bursted. Then the coins we can get is:<br>
nums[i] * nums[j] * nums[k] + coins(i, k) + coins(k, j)<br>
Determine the traversal order.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxCoins</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    nums = <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>&#125;, nums...)<br>    nums = <span class="hljs-built_in">append</span>(nums, <span class="hljs-number">1</span>)<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>            <span class="hljs-keyword">for</span> k := i + <span class="hljs-number">1</span>; k &lt; j; k++ &#123;<br>                coin := nums[i] * nums[k] * nums[j] + dp[i][k] + dp[k][j]<br>                <span class="hljs-keyword">if</span> coin &gt; dp[i][j] &#123;<br>                    dp[i][j] = coin<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>]<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#1246-palindrome-removal" class="header-anchor">#</a><span id="1246-palindrome-removal"> 1246. Palindrome Removal</span></h2>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_29051413/article/details/108647630">csdn</a></p>
<p>It’s problem to find the minimal number of operations in an interval.<br>
dp[i][j] means the minimal number of delete operations in the interval [i, j], left closed, right closed.<br>
If i == j, the dp[i][i] = 1, there only needs 1 operation, because there is only one character.<br>
If j - i == 1, if the arr[i] == arr[j], dp[i][j] = 1, otherwise dp[i][j] = 2<br>
If j - i &gt; 1, we have to check if arr[i] == arr[j]. If so, dp[i][j] = dp[i + 1][j - 1]. Otherwise, we could use divide and conquer. Suppose k divides interval into [i,k][k,j], we need to find the least dp[i][k] + dp[k+1][j].<br>
Determine the traversal order. It can be the outer iterate from 0 to n, the inner loop iterate from i to 0. Or the outer loop iterate from n to 0, the inner loop iterate from i to n.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minimumMoves</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>  n := <span class="hljs-built_in">len</span>(arr)<br>  dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n)<br>  <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>    dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>  &#125;<br>  <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>    <span class="hljs-keyword">for</span> j := i; j &lt; n; j++ &#123;<br>      <span class="hljs-keyword">if</span> arr[i] == arr[j] &#123;<br>        <span class="hljs-keyword">if</span> j - i &lt;= <span class="hljs-number">1</span> &#123;<br>          dp[i][j] = j - <span class="hljs-number">1</span> + <span class="hljs-number">1</span><br>          <span class="hljs-keyword">continue</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">for</span> k := i; k &lt; j; k++ &#123;<br>        cost := dp[i][k] + dp[k+<span class="hljs-number">1</span>][j]<br>        <span class="hljs-keyword">if</span> cost &lt; dp[i][j] &#123;<br>          dp[i][j] = cost<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>]<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#322-coin-change" class="header-anchor">#</a><span id="322-coin-change"> 322. Coin Change</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/coin-change/">leetcode</a></p>
<p>Review the complete knapsack problem.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(coins []<span class="hljs-type">int</span>, amount <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(coins)<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, amount+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; amount+<span class="hljs-number">1</span>; i++ &#123;<br>        dp[i] = math.MaxInt32<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := coins[i]; j &lt;= amount; j++ &#123;<br>            <span class="hljs-keyword">if</span> dp[j - coins[i]] == math.MaxInt32 &#123;<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br><br>            dp[j] = min(dp[j - coins[i]] + <span class="hljs-number">1</span>, dp[j])<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> dp[amount] == math.MaxInt32 &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[amount]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#416-partition-equal-subset-sum" class="header-anchor">#</a><span id="416-partition-equal-subset-sum"> 416. Partition Equal Subset Sum</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/partition-equal-subset-sum/">leetcode</a></p>
<p>The problem can be converted to whether we can find a subarray with the sum of total_sum / 2, which is a 0-1 knapsack problem. If we can fill the sum/2 weighted knapsack with sum/2 valued items.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    sum := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>        sum += num<br>    &#125;<br>    <span class="hljs-keyword">if</span> sum % <span class="hljs-number">2</span> != <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    size := sum / <span class="hljs-number">2</span><br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, size+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := size; j &gt;= nums[i]; j-- &#123;<br>            dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[size] == size <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure></p></div><div class="share"><span>Share</span>&nbsp;<span class="soc"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></span><span class="soc"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></span><span class="soc"><a target="_blank" rel="noopener" href="http://twitter.com/home?status=https://blog.kleon.space/interview/code/dynamic_programming/%20KLEON%20Code - Dynamic Programming" class="fa fa-twitter"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/interview/code/stack/" title="Code - Stack"><i class="fa fa-angle-double-left"></i>&nbsp;Previous post: Code - Stack</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/interview/code/outline/" title="Code - Outline">Next post: Code - Outline&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2022&nbsp;<a target="_blank" href="https://blog.kleon.space" rel="noopener noreferrer">Kleon</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>