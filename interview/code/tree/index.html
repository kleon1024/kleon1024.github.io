<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>Code - Tree · KLEON</title><meta name="description" content="Basics

Tree
Binary Tree
Full Binary Tree
Complete Binary Tree
Binary Search Tree
Balanced Search Tree
AVL Tree
Red–Black Tree
B-Tree
B+Tree
B*Tree


"><meta name="og:description" content="Basics

Tree
Binary Tree
Full Binary Tree
Complete Binary Tree
Binary Search Tree
Balanced Search Tree
AVL Tree
Red–Black Tree
B-Tree
B+Tree
B*Tree


"><meta name="twitter:site" content="KLEON"><meta name="twitter:title" content="Code - Tree"><meta name="twitter:card" content="summary"><meta name="keywords" content=""><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/github.min.css"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.10.2/katex.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 6.1.0"></head><body><div id="stage" class="container"><div class="row"><div id="side-bar" class="col-sm-3 col-xs-12 side-container invisible"><div class="vertical-text site-title"><h3 tabindex="-1" class="site-title-small"><a href="/" class="a-title"></a></h3><h1 tabindex="-1" class="site-title-large"><a href="/" class="a-title">吹拉弹唱</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div id="site-nav" class="site-title-links"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li><li><a href="/categories">Categories</a></li><li><a href="/tags">Tags</a></li><li><a href="/googlebe23cb0bc55fc412.html"></a></li><li><a href="/about/index.html"></a></li><li class="soc"><a href="https://github.com/kleon1024" target="_blank" rel="noopener noreferrer" aria-label="Github"><i class="fa fa-github">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2022&nbsp;<a target="_blank" href="https://blog.kleon.space" rel="noopener noreferrer">Kleon</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div id="main-container" class="col-sm-9 col-xs-12 main-container invisible"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>Code - Tree</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2022-05-15</span><span class="date meta-item">Updated at&nbsp;2022-05-15</span><span class="meta-item"><i class="fa fa-folder"></i><span>&nbsp;</span><a href="/categories/interview/" title="interview" class="a-tag">interview</a><span>&nbsp;</span></span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a href="/tags/interview/" title="interview" class="a-tag">interview</a><span>&nbsp;</span><a href="/tags/algorithm/" title="algorithm" class="a-tag">algorithm</a><span>&nbsp;</span></span></p><p class="post-abstract"><div class="toc">
<!-- toc -->
<ul>
<li><a href="#basics">Basics</a>
<ul>
<li><a href="#tree">Tree</a></li>
<li><a href="#binary-tree">Binary Tree</a></li>
<li><a href="#full-binary-tree">Full Binary Tree</a></li>
<li><a href="#complete-binary-tree">Complete Binary Tree</a></li>
<li><a href="#binary-search-tree">Binary Search Tree</a></li>
<li><a href="#balanced-search-tree">Balanced Search Tree</a></li>
<li><a href="#avl-tree">AVL Tree</a></li>
<li><a href="#red-black-tree">Red–Black Tree</a></li>
<li><a href="#b-tree">B-Tree</a></li>
<li><a href="#b-tree">B+Tree</a></li>
<li><a href="#b-tree">B*Tree</a></li>
</ul>
</li>
<li><a href="#leetcode">LeetCode</a>
<ul>
<li><a href="#144-binary-tree-preorder-traversal">144. Binary Tree Preorder Traversal</a></li>
<li><a href="#145-binary-tree-postorder-traversal">145. Binary Tree Postorder Traversal</a></li>
<li><a href="#94-binary-tree-inorder-traversal">94. Binary Tree Inorder Traversal</a></li>
<li><a href="#102-binary-tree-level-order-traversal">102. Binary Tree Level Order Traversal</a></li>
<li><a href="#107-binary-tree-level-order-traversal-ii">107. Binary Tree Level Order Traversal II</a></li>
<li><a href="#199-binary-tree-right-side-view">199. Binary Tree Right Side View</a></li>
<li><a href="#637-average-of-levels-in-binary-tree">637. Average of Levels in Binary Tree</a></li>
<li><a href="#429-n-ary-tree-level-order-traversal">429. N-ary Tree Level Order Traversal</a></li>
<li><a href="#114-flatten-binary-tree-to-linked-list">114. Flatten Binary Tree to Linked List</a></li>
<li><a href="#226-invert-binary-tree">226. Invert Binary Tree</a></li>
<li><a href="#101-symmetric-tree">101. Symmetric Tree</a></li>
<li><a href="#104-maximum-depth-of-binary-tree">104. Maximum Depth of Binary Tree</a></li>
<li><a href="#559-maximum-depth-of-n-ary-tree">559. Maximum Depth of N-ary Tree</a></li>
<li><a href="#111-minimum-depth-of-binary-tree">111. Minimum Depth of Binary Tree</a></li>
<li><a href="#222-count-complete-tree-nodes">222. Count Complete Tree Nodes</a></li>
<li><a href="#110-balanced-binary-tree">110. Balanced Binary Tree</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div>
<h1><a href="#basics" class="header-anchor">#</a><span id="basics"> Basics</span></h1>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TreeNode <span class="hljs-keyword">struct</span> &#123;<br>  Val   <span class="hljs-type">int</span><br>  Left  *TreeNode<br>  Right *TreeNode<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#tree" class="header-anchor">#</a><span id="tree"> Tree</span></h2>
<p>A directional acyclic linear data structure in which each node can point to multiple nodes and only one node can point to self.</p>
<h2><a href="#binary-tree" class="header-anchor">#</a><span id="binary-tree"> Binary Tree</span></h2>
<p>A binary tree is a tree data structure in which each node has at most two children, which are referred to as the left child and the right child.</p>
<h2><a href="#full-binary-tree" class="header-anchor">#</a><span id="full-binary-tree"> Full Binary Tree</span></h2>
<p>A full Binary tree is a special type of binary tree in which every parent node/internal node has either two or no children.</p>
<h2><a href="#complete-binary-tree" class="header-anchor">#</a><span id="complete-binary-tree"> Complete Binary Tree</span></h2>
<p>A complete binary tree is a binary tree in which all the levels are completely filled except possibly the lowest one, which is filled from the left.</p>
<h2><a href="#binary-search-tree" class="header-anchor">#</a><span id="binary-search-tree"> Binary Search Tree</span></h2>
<p>A binary search tree (BST), also called an ordered or sorted binary tree, is a rooted binary tree data structure whose internal nodes each store a key greater than all the keys in the node’s left subtree and less than those in its right subtree. The time complexity of operations on the binary search tree is directly proportional to the height of the tree.</p>
<ul>
<li>pros: No need to adjust the structure when inserting data.</li>
<li>cons: The performance can be easily affected by the order of data insertion. The worst case is sequential insertion, which degenerates into a linked list.</li>
</ul>
<h2><a href="#balanced-search-tree" class="header-anchor">#</a><span id="balanced-search-tree"> Balanced Search Tree</span></h2>
<p>A balanced binary tree, also referred to as a height-balanced binary tree, is defined as a binary tree in which the height of the left and right subtree of any node differ by not more than 1.</p>
<h2><a href="#avl-tree" class="header-anchor">#</a><span id="avl-tree"> AVL Tree</span></h2>
<p>An AVL tree (named after inventors Adelson-Velsky and Landis) is a self-balancing binary search tree (BST). It was the first such data structure to be invented. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Lookup, insertion, and deletion all take O(log n) time in both the average and worst cases, where n is the number of nodes in the tree prior to the operation. Insertions and deletions may require the tree to be rebalanced by one or more tree rotations.</p>
<ul>
<li>pros: More balanced compared to binary search tree. The performance is still good enough in extreme cases.</li>
<li>cons: In the case of a similar read-write ratio, there are too many rotation operations.</li>
</ul>
<h2><a href="#red-black-tree" class="header-anchor">#</a><span id="red-black-tree"> Red–Black Tree</span></h2>
<p>A red–black tree is a kind of self-balancing binary search tree. Each node stores an extra bit representing “color” (“red” or “black”), used to ensure that the tree remains balanced during insertions and deletions.</p>
<ol>
<li>Every node has a colour either red or black.</li>
<li>The root of the tree is always black.</li>
<li>There are no two adjacent red nodes (A red node cannot have a red parent or red child).</li>
<li>Every path from a node (including root) to any of its descendants NULL nodes has the same number of black nodes.</li>
<li>All leaf nodes are black nodes.</li>
</ol>
<ul>
<li>pros: The writing performance is much higher.</li>
<li>cons: The searching performance is not as good as AVL tree, because the height difference of the child tree is 1 more than AVL, the worst case will have an extra comparison.</li>
</ul>
<h2><a href="#b-tree" class="header-anchor">#</a><span id="b-tree"> B-Tree</span></h2>
<p>A B-tree is a self-balancing tree data structure that maintains sorted data and allows searches, sequential access, insertions, and deletions in logarithmic time. The B-tree generalizes the binary search tree, allowing for nodes with more than two children.</p>
<p>M-ary search tree. Used for data indexing, the child node stores pointers and data chunks。the tree structure is maintained by splitting operations.</p>
<h2><a href="#b-tree" class="header-anchor">#</a><span id="b-tree"> B+Tree</span></h2>
<p>A B+ tree is an m-ary tree with a variable but often large number of children per node. A B+ tree consists of a root, internal nodes and leaves. The root may be either a leaf or a node with two or more children.</p>
<p>A B+ tree can be viewed as a B-tree in which each node contains only keys (not key–value pairs), and to which an additional level is added at the bottom with linked leaves.</p>
<h2><a href="#b-tree" class="header-anchor">#</a><span id="b-tree"> B*Tree</span></h2>
<p>B*-tree of order m is a search tree that is either empty or that satisfies three properties:</p>
<ol>
<li>The root node has minimum two and maximum 2 floor ((2m-2)/3) +1 children</li>
<li>Other internal nodes have the minimum floor ((2m-1)/3) and maximum m children</li>
<li>All external nodes are on the same level.</li>
</ol>
<h1><a href="#leetcode" class="header-anchor">#</a><span id="leetcode"> LeetCode</span></h1>
<h2><a href="#144-binary-tree-preorder-traversal" class="header-anchor">#</a><span id="144-binary-tree-preorder-traversal"> 144. Binary Tree Preorder Traversal</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-preorder-traversal/">leetcode</a></p>
<p><strong>Recursion</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    result := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> result<br>    &#125;<br>    result = <span class="hljs-built_in">append</span>(result, root.Val)<br>    result = <span class="hljs-built_in">append</span>(result, preorderTraversal(root.Left)...)<br>    result = <span class="hljs-built_in">append</span>(result, preorderTraversal(root.Right)...)<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Iteration</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    stack := []*TreeNode&#123;&#125;<br>    result := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root != <span class="hljs-literal">nil</span> &#123;<br>        stack = <span class="hljs-built_in">append</span>(stack, root)<br>    &#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack) &gt; <span class="hljs-number">0</span> &#123;<br>        node := stack[<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>        stack = stack[:<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> node != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                stack = <span class="hljs-built_in">append</span>(stack, node.Right)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                stack = <span class="hljs-built_in">append</span>(stack, node.Left)<br>            &#125;<br>            stack = <span class="hljs-built_in">append</span>(stack, node)<br>            stack = <span class="hljs-built_in">append</span>(stack, <span class="hljs-literal">nil</span>)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            node = stack[<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>            stack = stack[:<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>            result = <span class="hljs-built_in">append</span>(result, node.Val)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#145-binary-tree-postorder-traversal" class="header-anchor">#</a><span id="145-binary-tree-postorder-traversal"> 145. Binary Tree Postorder Traversal</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-postorder-traversal/">leetcode</a></p>
<p><strong>Recursion</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    result := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> result<br>    &#125;<br>    result = <span class="hljs-built_in">append</span>(result, postorderTraversal(root.Left)...)<br>    result = <span class="hljs-built_in">append</span>(result, postorderTraversal(root.Right)...)<br>    result = <span class="hljs-built_in">append</span>(result, root.Val)<br>    <span class="hljs-keyword">return</span> result    <br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Iteration</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    stack := []*TreeNode&#123;&#125;<br>    result := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root != <span class="hljs-literal">nil</span> &#123;<br>        stack = <span class="hljs-built_in">append</span>(stack, root)<br>    &#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack) &gt; <span class="hljs-number">0</span> &#123;<br>        node := stack[<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>        stack = stack[:<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> node != <span class="hljs-literal">nil</span> &#123;<br>            stack = <span class="hljs-built_in">append</span>(stack, node)<br>            stack = <span class="hljs-built_in">append</span>(stack, <span class="hljs-literal">nil</span>)<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                stack = <span class="hljs-built_in">append</span>(stack, node.Right)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                stack = <span class="hljs-built_in">append</span>(stack, node.Left)<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            node = stack[<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>            stack = stack[:<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>            result = <span class="hljs-built_in">append</span>(result, node.Val)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result <br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#94-binary-tree-inorder-traversal" class="header-anchor">#</a><span id="94-binary-tree-inorder-traversal"> 94. Binary Tree Inorder Traversal</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-inorder-traversal/">leetcode</a></p>
<p><strong>Recursion</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    result := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> result<br>    &#125;<br>    result = <span class="hljs-built_in">append</span>(result, inorderTraversal(root.Left)...)<br>    result = <span class="hljs-built_in">append</span>(result, root.Val)<br>    result = <span class="hljs-built_in">append</span>(result, inorderTraversal(root.Right)...)<br>    <span class="hljs-keyword">return</span> result        <br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Iteration</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    stack := []*TreeNode&#123;&#125;<br>    result := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root != <span class="hljs-literal">nil</span> &#123;<br>        stack = <span class="hljs-built_in">append</span>(stack, root)<br>    &#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack) &gt; <span class="hljs-number">0</span> &#123;<br>        node := stack[<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>        stack = stack[:<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> node != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                stack = <span class="hljs-built_in">append</span>(stack, node.Right)<br>            &#125;<br>            stack = <span class="hljs-built_in">append</span>(stack, node)<br>            stack = <span class="hljs-built_in">append</span>(stack, <span class="hljs-literal">nil</span>)<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                stack = <span class="hljs-built_in">append</span>(stack, node.Left)<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            node = stack[<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>            stack = stack[:<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>            result = <span class="hljs-built_in">append</span>(result, node.Val)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result    <br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#102-binary-tree-level-order-traversal" class="header-anchor">#</a><span id="102-binary-tree-level-order-traversal"> 102. Binary Tree Level Order Traversal</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-level-order-traversal/">leetcode</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(root *TreeNode)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    queue := []*TreeNode&#123;&#125;<br>    result := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root != <span class="hljs-literal">nil</span> &#123;<br>        queue = <span class="hljs-built_in">append</span>(queue, root)<br>    &#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        size := <span class="hljs-built_in">len</span>(queue)<br>        vec := []<span class="hljs-type">int</span>&#123;&#125;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>            node := queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:]<br>            vec = <span class="hljs-built_in">append</span>(vec, node.Val)<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Right)<br>            &#125;<br>        &#125;<br>        result = <span class="hljs-built_in">append</span>(result, vec)<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#107-binary-tree-level-order-traversal-ii" class="header-anchor">#</a><span id="107-binary-tree-level-order-traversal-ii"> 107. Binary Tree Level Order Traversal II</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/">leetcode</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">levelOrderBottom</span><span class="hljs-params">(root *TreeNode)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    queue := []*TreeNode&#123;&#125;<br>    result := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root != <span class="hljs-literal">nil</span> &#123;<br>        queue = <span class="hljs-built_in">append</span>(queue, root)<br>    &#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        size := <span class="hljs-built_in">len</span>(queue)<br>        vec := []<span class="hljs-type">int</span>&#123;&#125;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>            node := queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:]<br>            vec = <span class="hljs-built_in">append</span>(vec, node.Val)<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Right)<br>            &#125;<br>        &#125;<br>        result = <span class="hljs-built_in">append</span>([][]<span class="hljs-type">int</span>&#123;vec&#125;, result...)<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Or</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">levelOrderBottom</span><span class="hljs-params">(root *TreeNode)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    queue := []*TreeNode&#123;&#125;<br>    result := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root != <span class="hljs-literal">nil</span> &#123;<br>        queue = <span class="hljs-built_in">append</span>(queue, root)<br>    &#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        size := <span class="hljs-built_in">len</span>(queue)<br>        vec := []<span class="hljs-type">int</span>&#123;&#125;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>            node := queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:]<br>            vec = <span class="hljs-built_in">append</span>(vec, node.Val)<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Right)<br>            &#125;<br>        &#125;<br>        result = <span class="hljs-built_in">append</span>(result, vec)<br>    &#125;<br>    <span class="hljs-keyword">for</span> i, j := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(result)<span class="hljs-number">-1</span>; i &lt; j; i, j = i+<span class="hljs-number">1</span>, j<span class="hljs-number">-1</span> &#123;<br>        result[i], result[j] = result[j], result[i]<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#199-binary-tree-right-side-view" class="header-anchor">#</a><span id="199-binary-tree-right-side-view"> 199. Binary Tree Right Side View</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-right-side-view/">leetcode</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rightSideView</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    queue := []*TreeNode&#123;&#125;<br>    result := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root != <span class="hljs-literal">nil</span> &#123;<br>        queue = <span class="hljs-built_in">append</span>(queue, root)<br>    &#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        size := <span class="hljs-built_in">len</span>(queue)<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>            node := queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:]<br>            <span class="hljs-keyword">if</span> i == size - <span class="hljs-number">1</span> &#123;<br>                result = <span class="hljs-built_in">append</span>(result, node.Val)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Right)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#637-average-of-levels-in-binary-tree" class="header-anchor">#</a><span id="637-average-of-levels-in-binary-tree"> 637. Average of Levels in Binary Tree</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/average-of-levels-in-binary-tree/">leetcode</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">averageOfLevels</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">float64</span> &#123;<br>    queue := []*TreeNode&#123;&#125;<br>    result := []<span class="hljs-type">float64</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root != <span class="hljs-literal">nil</span> &#123;<br>        queue = <span class="hljs-built_in">append</span>(queue, root)<br>    &#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        size := <span class="hljs-built_in">len</span>(queue)<br>        sum := <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>            node := queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:]<br>            sum += node.Val<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Right)<br>            &#125;<br>        &#125;<br>        result = <span class="hljs-built_in">append</span>(result, <span class="hljs-type">float64</span>(sum) / <span class="hljs-type">float64</span>(size))<br>    &#125;<br>    <span class="hljs-keyword">return</span> result  <br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#429-n-ary-tree-level-order-traversal" class="header-anchor">#</a><span id="429-n-ary-tree-level-order-traversal"> 429. N-ary Tree Level Order Traversal</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/n-ary-tree-level-order-traversal/">leetcode</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a Node.</span><br><span class="hljs-comment"> * type Node struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Children []*Node</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(root *Node)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    queue := []*Node&#123;&#125;<br>    result := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root != <span class="hljs-literal">nil</span> &#123;<br>        queue = <span class="hljs-built_in">append</span>(queue, root)<br>    &#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        size := <span class="hljs-built_in">len</span>(queue)<br>        vec := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, size)<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>            node := queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:]<br>            vec = <span class="hljs-built_in">append</span>(vec, node.Val)<br>            <span class="hljs-keyword">for</span> _, child := <span class="hljs-keyword">range</span> node.Children &#123;<br>                <span class="hljs-keyword">if</span> child != <span class="hljs-literal">nil</span> &#123;<br>                    queue = <span class="hljs-built_in">append</span>(queue, child)<br>                &#125;<br>            &#125;<br>        &#125;<br>        result = <span class="hljs-built_in">append</span>(result, vec)<br>    &#125;<br>    <span class="hljs-keyword">return</span> result     <br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#114-flatten-binary-tree-to-linked-list" class="header-anchor">#</a><span id="114-flatten-binary-tree-to-linked-list"> 114. Flatten Binary Tree to Linked List</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/">leetcode</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">flatten</span><span class="hljs-params">(root *TreeNode)</span></span>  &#123;<br>    stack := []*TreeNode&#123;&#125;<br>    list := []*TreeNode&#123;&#125;<br>    node := root<br>    <span class="hljs-keyword">for</span> node != <span class="hljs-literal">nil</span> || <span class="hljs-built_in">len</span>(stack) &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">for</span> node != <span class="hljs-literal">nil</span> &#123;<br>            list = <span class="hljs-built_in">append</span>(list, node)<br>            stack = <span class="hljs-built_in">append</span>(stack, node)<br>            node = node.Left<br>        &#125;<br>        node = stack[<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>        node = node.Right<br>        stack = stack[:<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(list); i++ &#123;<br>        prev, curr := list[i<span class="hljs-number">-1</span>], list[i]<br>        prev.Left, prev.Right = <span class="hljs-literal">nil</span>, curr<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#226-invert-binary-tree" class="header-anchor">#</a><span id="226-invert-binary-tree"> 226. Invert Binary Tree</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/invert-binary-tree/">leetcode</a></p>
<p><strong>Recursion</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">invertTree</span><span class="hljs-params">(root *TreeNode)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> root<br>    &#125;<br>    root.Left, root.Right = root.Right, root.Left<br>    invertTree(root.Left)<br>    invertTree(root.Right)<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Iteration</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">invertTree</span><span class="hljs-params">(root *TreeNode)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> root<br>    &#125;<br>    stack := []*TreeNode&#123;&#125;<br>    stack = <span class="hljs-built_in">append</span>(stack, root)<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack) &gt; <span class="hljs-number">0</span> &#123;<br>        node := stack[<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>        stack = stack[:<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>        node.Left, node.Right = node.Right, node.Left<br>        <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>            stack = <span class="hljs-built_in">append</span>(stack, node.Right)<br>        &#125;<br>        <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>            stack = <span class="hljs-built_in">append</span>(stack, node.Left)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Level Order</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">invertTree</span><span class="hljs-params">(root *TreeNode)</span></span> *TreeNode &#123;<br>    queue := []*TreeNode&#123;&#125;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> root<br>    &#125;<br>    queue = <span class="hljs-built_in">append</span>(queue, root)<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        size := <span class="hljs-built_in">len</span>(queue)<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>            node := queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:]<br>            node.Left, node.Right = node.Right, node.Left<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Right)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#101-symmetric-tree" class="header-anchor">#</a><span id="101-symmetric-tree"> 101. Symmetric Tree</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/symmetric-tree/">leetcode</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">compare</span><span class="hljs-params">(left *TreeNode, right *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> right != <span class="hljs-literal">nil</span> &amp;&amp; left == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>    <span class="hljs-keyword">if</span> right == <span class="hljs-literal">nil</span> &amp;&amp; left != <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>    <span class="hljs-keyword">if</span> right == <span class="hljs-literal">nil</span> &amp;&amp; left == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125;<br>    <span class="hljs-keyword">if</span> right.Val != left.Val &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br><br>    outside := compare(left.Left, right.Right)<br>    inside := compare(left.Right, right.Left)<br>    <span class="hljs-keyword">return</span> outside &amp;&amp; inside<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125;<br>    <span class="hljs-keyword">return</span> compare(root.Left, root.Right)<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125;<br>    queue := []*TreeNode&#123;&#125;<br>    queue = <span class="hljs-built_in">append</span>(queue, root.Left)<br>    queue = <span class="hljs-built_in">append</span>(queue, root.Right)<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        left := queue[<span class="hljs-number">0</span>]; queue = queue[<span class="hljs-number">1</span>:]<br>        right := queue[<span class="hljs-number">0</span>]; queue = queue[<span class="hljs-number">1</span>:]<br>        <span class="hljs-keyword">if</span> left == <span class="hljs-literal">nil</span> &amp;&amp; right == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> left == <span class="hljs-literal">nil</span> || right == <span class="hljs-literal">nil</span> || left.Val != right.Val &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>        queue = <span class="hljs-built_in">append</span>(queue, left.Left)<br>        queue = <span class="hljs-built_in">append</span>(queue, right.Right)<br>        queue = <span class="hljs-built_in">append</span>(queue, left.Right)<br>        queue = <span class="hljs-built_in">append</span>(queue, right.Left)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#104-maximum-depth-of-binary-tree" class="header-anchor">#</a><span id="104-maximum-depth-of-binary-tree"> 104. Maximum Depth of Binary Tree</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">leetcode</a></p>
<p><strong>Recursion</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + max(maxDepth(root.Left), maxDepth(root.Right))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Iteration</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a Node.</span><br><span class="hljs-comment"> * type Node struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(root *Node)</span></span> <span class="hljs-type">int</span> &#123;<br>    queue := []*Node&#123;&#125;<br>    depth := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> depth &#125;<br>    queue = <span class="hljs-built_in">append</span>(queue, root)<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        size := <span class="hljs-built_in">len</span>(queue)<br>        depth++<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>            node := queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:]<br>            queue = <span class="hljs-built_in">append</span>(queue, node.Left)<br>            queue = <span class="hljs-built_in">append</span>(queue, node.Right)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> depth<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#559-maximum-depth-of-n-ary-tree" class="header-anchor">#</a><span id="559-maximum-depth-of-n-ary-tree"> 559. Maximum Depth of N-ary Tree</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-depth-of-n-ary-tree/">leetcode</a></p>
<p><strong>Recursion</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a Node.</span><br><span class="hljs-comment"> * type Node struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Children []*Node</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(root *Node)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    max := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, child := <span class="hljs-keyword">range</span> root.Children &#123;<br>        depth := maxDepth(child)<br>        <span class="hljs-keyword">if</span> depth &gt; max &#123;<br>            max = depth<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + max<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Iteration</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a Node.</span><br><span class="hljs-comment"> * type Node struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Children []*Node</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(root *Node)</span></span> <span class="hljs-type">int</span> &#123;<br>    queue := []*Node&#123;&#125;<br>    depth := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> depth &#125;<br>    queue = <span class="hljs-built_in">append</span>(queue, root)<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        size := <span class="hljs-built_in">len</span>(queue)<br>        depth++<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>            node := queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:]<br>            <span class="hljs-keyword">for</span> _, n := <span class="hljs-keyword">range</span> node.Children &#123;<br>                <span class="hljs-keyword">if</span> n != <span class="hljs-literal">nil</span> &#123;<br>                    queue = <span class="hljs-built_in">append</span>(queue, n)<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> depth<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#111-minimum-depth-of-binary-tree" class="header-anchor">#</a><span id="111-minimum-depth-of-binary-tree"> 111. Minimum Depth of Binary Tree</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-depth-of-binary-tree/">leetcode</a></p>
<p><strong>Recursion</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> &#125;<br>    leftDepth := minDepth(root.Left)<br>    rightDepth := minDepth(root.Right)<br><br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + rightDepth<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> root.Right == <span class="hljs-literal">nil</span> &amp;&amp; root.Left != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + leftDepth<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + min(leftDepth, rightDepth)    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Iteration</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    queue := []*TreeNode&#123;&#125;<br>    depth := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> depth &#125;<br>    queue = <span class="hljs-built_in">append</span>(queue, root)<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        size := <span class="hljs-built_in">len</span>(queue)<br>        depth++<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>            node := queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:]<br>            <span class="hljs-keyword">if</span> node.Left == <span class="hljs-literal">nil</span> &amp;&amp; node.Right == <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-keyword">return</span> depth<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Right)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> depth<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#222-count-complete-tree-nodes" class="header-anchor">#</a><span id="222-count-complete-tree-nodes"> 222. Count Complete Tree Nodes</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/count-complete-tree-nodes/">leetcode</a></p>
<p><strong>Recursion</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + countNodes(root.Left) + countNodes(root.Right)<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Iteration</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    queue := []*TreeNode&#123;&#125;<br>    count := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> count &#125;<br>    queue = <span class="hljs-built_in">append</span>(queue, root)<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        size := <span class="hljs-built_in">len</span>(queue)<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>            node := queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:]<br>            count++<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Right)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#110-balanced-binary-tree" class="header-anchor">#</a><span id="110-balanced-binary-tree"> 110. Balanced Binary Tree</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/balanced-binary-tree/submissions/">leetcode</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> x &gt; y &#123; <span class="hljs-keyword">return</span> x &#125;<br>    <span class="hljs-keyword">return</span> y<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">abs</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> -x<br>    &#125;<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">depth</span><span class="hljs-params">(node *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> &#125;<br>    leftDepth := depth(node.Left)<br>    <span class="hljs-keyword">if</span> leftDepth &lt; <span class="hljs-number">0</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span> &#125;<br>    rightDepth := depth(node.Right)<br>    <span class="hljs-keyword">if</span> rightDepth &lt; <span class="hljs-number">0</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span> &#125;<br>    <span class="hljs-keyword">if</span> abs(leftDepth - rightDepth) &gt; <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + min(leftDepth, rightDepth)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> depth(root) &gt;= <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure>
</p></div><div class="share"><span>Share</span>&nbsp;<span class="soc"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></span><span class="soc"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></span><span class="soc"><a target="_blank" rel="noopener" href="http://twitter.com/home?status=https://blog.kleon.space/interview/code/tree/%20KLEON%20Code - Tree" class="fa fa-twitter"></a></span></div><div class="pagination"><p class="clearfix"><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/interview/code/array/" title="Code - Array">Next post: Code - Array&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2022&nbsp;<a target="_blank" href="https://blog.kleon.space" rel="noopener noreferrer">Kleon</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>