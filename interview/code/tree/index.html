<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>Code - Tree · KLEON</title><meta name="description" content="Basics

Tree
Binary Tree
Full Binary Tree
Complete Binary Tree
Binary Search Tree
Balanced Search Tree
AVL Tree
Red–Black Tree
B-Tree
B+Tree
B*Tree


"><meta name="og:description" content="Basics

Tree
Binary Tree
Full Binary Tree
Complete Binary Tree
Binary Search Tree
Balanced Search Tree
AVL Tree
Red–Black Tree
B-Tree
B+Tree
B*Tree


"><meta name="twitter:site" content="KLEON"><meta name="twitter:title" content="Code - Tree"><meta name="twitter:card" content="summary"><meta name="keywords" content=""><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/github.min.css"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.10.2/katex.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 6.1.0"></head><body><div id="stage" class="container"><div class="row"><div id="side-bar" class="col-sm-3 col-xs-12 side-container invisible"><div class="vertical-text site-title"><h3 tabindex="-1" class="site-title-small"><a href="/" class="a-title"></a></h3><h1 tabindex="-1" class="site-title-large"><a href="/" class="a-title">吹拉弹唱</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div id="site-nav" class="site-title-links"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li><li><a href="/categories">Categories</a></li><li><a href="/tags">Tags</a></li><li><a href="/googlebe23cb0bc55fc412.html"></a></li><li><a href="/about/index.html"></a></li><li class="soc"><a href="https://github.com/kleon1024" target="_blank" rel="noopener noreferrer" aria-label="Github"><i class="fa fa-github">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2022&nbsp;<a target="_blank" href="https://blog.kleon.space" rel="noopener noreferrer">Kleon</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div id="main-container" class="col-sm-9 col-xs-12 main-container invisible"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>Code - Tree</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2022-05-15</span><span class="date meta-item">Updated at&nbsp;2022-05-15</span><span class="meta-item"><i class="fa fa-folder"></i><span>&nbsp;</span><a href="/categories/interview/" title="interview" class="a-tag">interview</a><span>&nbsp;</span></span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a href="/tags/interview/" title="interview" class="a-tag">interview</a><span>&nbsp;</span><a href="/tags/algorithm/" title="algorithm" class="a-tag">algorithm</a><span>&nbsp;</span></span></p><p class="post-abstract"><div class="toc">
<!-- toc -->
<ul>
<li><a href="#basics">Basics</a>
<ul>
<li><a href="#tree">Tree</a></li>
<li><a href="#binary-tree">Binary Tree</a></li>
<li><a href="#full-binary-tree">Full Binary Tree</a></li>
<li><a href="#complete-binary-tree">Complete Binary Tree</a></li>
<li><a href="#binary-search-tree">Binary Search Tree</a></li>
<li><a href="#balanced-search-tree">Balanced Search Tree</a></li>
<li><a href="#avl-tree">AVL Tree</a></li>
<li><a href="#red-black-tree">Red–Black Tree</a></li>
<li><a href="#b-tree">B-Tree</a></li>
<li><a href="#b-tree">B+Tree</a></li>
<li><a href="#b-tree">B*Tree</a></li>
</ul>
</li>
<li><a href="#leetcode">LeetCode</a>
<ul>
<li><a href="#144-binary-tree-preorder-traversal">144. Binary Tree Preorder Traversal</a></li>
<li><a href="#589-n-ary-tree-preorder-traversal">589. N-ary Tree Preorder Traversal</a></li>
<li><a href="#145-binary-tree-postorder-traversal">145. Binary Tree Postorder Traversal</a></li>
<li><a href="#590-n-ary-tree-postorder-traversal">590. N-ary Tree Postorder Traversal</a></li>
<li><a href="#94-binary-tree-inorder-traversal">94. Binary Tree Inorder Traversal</a></li>
<li><a href="#102-binary-tree-level-order-traversal">102. Binary Tree Level Order Traversal</a></li>
<li><a href="#107-binary-tree-level-order-traversal-ii">107. Binary Tree Level Order Traversal II</a></li>
<li><a href="#199-binary-tree-right-side-view">199. Binary Tree Right Side View</a></li>
<li><a href="#637-average-of-levels-in-binary-tree">637. Average of Levels in Binary Tree</a></li>
<li><a href="#429-n-ary-tree-level-order-traversal">429. N-ary Tree Level Order Traversal</a></li>
<li><a href="#114-flatten-binary-tree-to-linked-list">114. Flatten Binary Tree to Linked List</a></li>
<li><a href="#226-invert-binary-tree">226. Invert Binary Tree</a></li>
<li><a href="#101-symmetric-tree">101. Symmetric Tree</a></li>
<li><a href="#104-maximum-depth-of-binary-tree">104. Maximum Depth of Binary Tree</a></li>
<li><a href="#559-maximum-depth-of-n-ary-tree">559. Maximum Depth of N-ary Tree</a></li>
<li><a href="#111-minimum-depth-of-binary-tree">111. Minimum Depth of Binary Tree</a></li>
<li><a href="#222-count-complete-tree-nodes">222. Count Complete Tree Nodes</a></li>
<li><a href="#110-balanced-binary-tree">110. Balanced Binary Tree</a></li>
<li><a href="#257-binary-tree-paths">257. Binary Tree Paths</a></li>
<li><a href="#100-same-tree">100. Same Tree</a></li>
<li><a href="#404-sum-of-left-leaves">404. Sum of Left Leaves</a></li>
<li><a href="#513-find-bottom-left-tree-value">513. Find Bottom Left Tree Value</a></li>
<li><a href="#112-path-sum">112. Path Sum</a></li>
<li><a href="#113-path-sum-ii">113. Path Sum II</a></li>
<li><a href="#437-path-sum-iii">437. Path Sum III</a></li>
<li><a href="#106-construct-binary-tree-from-inorder-and-postorder-traversal">106. Construct Binary Tree from Inorder and Postorder Traversal</a></li>
<li><a href="#105-construct-binary-tree-from-preorder-and-inorder-traversal">105. Construct Binary Tree from Preorder and Inorder Traversal</a></li>
<li><a href="#654-maximum-binary-tree">654. Maximum Binary Tree</a></li>
<li><a href="#617-merge-two-binary-trees">617. Merge Two Binary Trees</a></li>
<li><a href="#700-search-in-a-binary-search-tree">700. Search in a Binary Search Tree</a></li>
<li><a href="#98-validate-binary-search-tree">98. Validate Binary Search Tree</a></li>
<li><a href="#530-minimum-absolute-difference-in-bst">530. Minimum Absolute Difference in BST</a></li>
<li><a href="#501-find-mode-in-binary-search-tree">501. Find Mode in Binary Search Tree</a></li>
<li><a href="#236-lowest-common-ancestor-of-a-binary-tree">236. Lowest Common Ancestor of a Binary Tree</a></li>
<li><a href="#235-lowest-common-ancestor-of-a-binary-search-tree">235. Lowest Common Ancestor of a Binary Search Tree</a></li>
<li><a href="#1644-lowest-common-ancestor-of-a-binary-tree-ii">1644. Lowest Common Ancestor of a Binary Tree II</a></li>
<li><a href="#1650-lowest-common-ancestor-of-a-binary-tree-iii">1650. Lowest Common Ancestor of a Binary Tree III</a></li>
<li><a href="#1676-lowest-common-ancestor-of-a-binary-tree-iii">1676. Lowest Common Ancestor of a Binary Tree III</a></li>
<li><a href="#701-insert-into-a-binary-search-tree">701. Insert into a Binary Search Tree</a></li>
<li><a href="#450-delete-node-in-a-bst">450. Delete Node in a BST</a></li>
<li><a href="#669-trim-a-binary-search-tree">669. Trim a Binary Search Tree</a></li>
<li><a href="#108-convert-sorted-array-to-binary-search-tree">108. Convert Sorted Array to Binary Search Tree</a></li>
<li><a href="#109-convert-sorted-list-to-binary-search-tree">109. Convert Sorted List to Binary Search Tree</a></li>
<li><a href="#1008-construct-binary-search-tree-from-preorder-traversal">1008. Construct Binary Search Tree from Preorder Traversal</a></li>
<li><a href="#449-serialize-and-deserialize-bst">449. Serialize and Deserialize BST</a></li>
<li><a href="#538-convert-bst-to-greater-tree">538. Convert BST to Greater Tree</a></li>
<li><a href="#99-recover-binary-search-tree">99. Recover Binary Search Tree</a></li>
<li><a href="#103-binary-tree-zigzag-level-order-traversal">103. Binary Tree Zigzag Level Order Traversal</a></li>
<li><a href="#1022-sum-of-root-to-leaf-binary-numbers">1022. Sum of Root To Leaf Binary Numbers</a></li>
<li><a href="#116-populating-next-right-pointers-in-each-node">116. Populating Next Right Pointers in Each Node</a></li>
<li><a href="#117-populating-next-right-pointers-in-each-node-ii">117. Populating Next Right Pointers in Each Node II</a></li>
<li><a href="#449-serialize-and-deserialize-bst-1">449. Serialize and Deserialize BST</a></li>
<li><a href="#297-serialize-and-deserialize-binary-tree">297. Serialize and Deserialize Binary Tree</a></li>
<li><a href="#652-find-duplicate-subtrees">652. Find Duplicate Subtrees</a></li>
<li><a href="#606-construct-string-from-binary-tree">606. Construct String from Binary Tree</a></li>
<li><a href="#124-binary-tree-maximum-path-sum">124. Binary Tree Maximum Path Sum</a></li>
<li><a href="#129-sum-root-to-leaf-numbers">129. Sum Root to Leaf Numbers</a></li>
<li><a href="#988-smallest-string-starting-from-leaf">988. Smallest String Starting From Leaf</a></li>
<li><a href="#230-kth-smallest-element-in-a-bst">230. Kth Smallest Element in a BST</a></li>
<li><a href="#671-second-minimum-node-in-a-binary-tree">671. Second Minimum Node In a Binary Tree</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div>
<h1><a href="#basics" class="header-anchor">#</a><span id="basics"> Basics</span></h1>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TreeNode <span class="hljs-keyword">struct</span> &#123;<br>  Val   <span class="hljs-type">int</span><br>  Left  *TreeNode<br>  Right *TreeNode<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#tree" class="header-anchor">#</a><span id="tree"> Tree</span></h2>
<p>A directional acyclic linear data structure in which each node can point to multiple nodes and only one node can point to self.</p>
<h2><a href="#binary-tree" class="header-anchor">#</a><span id="binary-tree"> Binary Tree</span></h2>
<p>A binary tree is a tree data structure in which each node has at most two children, which are referred to as the left child and the right child.</p>
<h2><a href="#full-binary-tree" class="header-anchor">#</a><span id="full-binary-tree"> Full Binary Tree</span></h2>
<p>A full Binary tree is a special type of binary tree in which every parent node/internal node has either two or no children.</p>
<h2><a href="#complete-binary-tree" class="header-anchor">#</a><span id="complete-binary-tree"> Complete Binary Tree</span></h2>
<p>A complete binary tree is a binary tree in which all the levels are completely filled except possibly the lowest one, which is filled from the left.</p>
<h2><a href="#binary-search-tree" class="header-anchor">#</a><span id="binary-search-tree"> Binary Search Tree</span></h2>
<p>A binary search tree (BST), also called an ordered or sorted binary tree, is a rooted binary tree data structure whose internal nodes each store a key greater than all the keys in the node’s left subtree and less than those in its right subtree. The time complexity of operations on the binary search tree is directly proportional to the height of the tree.</p>
<ul>
<li>pros: No need to adjust the structure when inserting data.</li>
<li>cons: The performance can be easily affected by the order of data insertion. The worst case is sequential insertion, which degenerates into a linked list.</li>
</ul>
<h2><a href="#balanced-search-tree" class="header-anchor">#</a><span id="balanced-search-tree"> Balanced Search Tree</span></h2>
<p>A balanced binary tree, also referred to as a height-balanced binary tree, is defined as a binary tree in which the height of the left and right subtree of any node differ by not more than 1.</p>
<h2><a href="#avl-tree" class="header-anchor">#</a><span id="avl-tree"> AVL Tree</span></h2>
<p>An AVL tree (named after inventors Adelson-Velsky and Landis) is a self-balancing binary search tree (BST). It was the first such data structure to be invented. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Lookup, insertion, and deletion all take O(log n) time in both the average and worst cases, where n is the number of nodes in the tree prior to the operation. Insertions and deletions may require the tree to be rebalanced by one or more tree rotations.</p>
<ul>
<li>pros: More balanced compared to binary search tree. The performance is still good enough in extreme cases.</li>
<li>cons: In the case of a similar read-write ratio, there are too many rotation operations.</li>
</ul>
<h2><a href="#red-black-tree" class="header-anchor">#</a><span id="red-black-tree"> Red–Black Tree</span></h2>
<p>A red–black tree is a kind of self-balancing binary search tree. Each node stores an extra bit representing “color” (“red” or “black”), used to ensure that the tree remains balanced during insertions and deletions.</p>
<ol>
<li>Every node has a colour either red or black.</li>
<li>The root of the tree is always black.</li>
<li>There are no two adjacent red nodes (A red node cannot have a red parent or red child).</li>
<li>Every path from a node (including root) to any of its descendants NULL nodes has the same number of black nodes.</li>
<li>All leaf nodes are black nodes.</li>
</ol>
<ul>
<li>pros: The writing performance is much higher.</li>
<li>cons: The searching performance is not as good as AVL tree, because the height difference of the child tree is 1 more than AVL, the worst case will have an extra comparison.</li>
</ul>
<h2><a href="#b-tree" class="header-anchor">#</a><span id="b-tree"> B-Tree</span></h2>
<p>A B-tree is a self-balancing tree data structure that maintains sorted data and allows searches, sequential access, insertions, and deletions in logarithmic time. The B-tree generalizes the binary search tree, allowing for nodes with more than two children.</p>
<p>M-ary search tree. Used for data indexing, the child node stores pointers and data chunks。the tree structure is maintained by splitting operations.</p>
<h2><a href="#b-tree" class="header-anchor">#</a><span id="b-tree"> B+Tree</span></h2>
<p>A B+ tree is an m-ary tree with a variable but often large number of children per node. A B+ tree consists of a root, internal nodes and leaves. The root may be either a leaf or a node with two or more children.</p>
<p>A B+ tree can be viewed as a B-tree in which each node contains only keys (not key–value pairs), and to which an additional level is added at the bottom with linked leaves.</p>
<h2><a href="#b-tree" class="header-anchor">#</a><span id="b-tree"> B*Tree</span></h2>
<p>B*-tree of order m is a search tree that is either empty or that satisfies three properties:</p>
<ol>
<li>The root node has minimum two and maximum 2 floor ((2m-2)/3) +1 children</li>
<li>Other internal nodes have the minimum floor ((2m-1)/3) and maximum m children</li>
<li>All external nodes are on the same level.</li>
</ol>
<h1><a href="#leetcode" class="header-anchor">#</a><span id="leetcode"> LeetCode</span></h1>
<h2><a href="#144-binary-tree-preorder-traversal" class="header-anchor">#</a><span id="144-binary-tree-preorder-traversal"> 144. Binary Tree Preorder Traversal</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-preorder-traversal/">leetcode</a></p>
<p><strong>Recursion</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    result := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> result<br>    &#125;<br>    result = <span class="hljs-built_in">append</span>(result, root.Val)<br>    result = <span class="hljs-built_in">append</span>(result, preorderTraversal(root.Left)...)<br>    result = <span class="hljs-built_in">append</span>(result, preorderTraversal(root.Right)...)<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Iteration</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    stack := []*TreeNode&#123;&#125;<br>    result := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root != <span class="hljs-literal">nil</span> &#123;<br>        stack = <span class="hljs-built_in">append</span>(stack, root)<br>    &#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack) &gt; <span class="hljs-number">0</span> &#123;<br>        node := stack[<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>        stack = stack[:<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> node != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                stack = <span class="hljs-built_in">append</span>(stack, node.Right)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                stack = <span class="hljs-built_in">append</span>(stack, node.Left)<br>            &#125;<br>            stack = <span class="hljs-built_in">append</span>(stack, node)<br>            stack = <span class="hljs-built_in">append</span>(stack, <span class="hljs-literal">nil</span>)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            node = stack[<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>            stack = stack[:<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>            result = <span class="hljs-built_in">append</span>(result, node.Val)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#589-n-ary-tree-preorder-traversal" class="header-anchor">#</a><span id="589-n-ary-tree-preorder-traversal"> 589. N-ary Tree Preorder Traversal</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/n-ary-tree-preorder-traversal/">leetcode</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a Node.</span><br><span class="hljs-comment"> * type Node struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Children []*Node</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">preorder</span><span class="hljs-params">(root *Node)</span></span> []<span class="hljs-type">int</span> &#123;<br>    result := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> result &#125;<br>    result = <span class="hljs-built_in">append</span>(result, root.Val)<br>    <span class="hljs-keyword">for</span> _, child := <span class="hljs-keyword">range</span> root.Children &#123;<br>        result = <span class="hljs-built_in">append</span>(result, preorder(child)...)<br>    &#125;<br>    <span class="hljs-keyword">return</span> result    <br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#145-binary-tree-postorder-traversal" class="header-anchor">#</a><span id="145-binary-tree-postorder-traversal"> 145. Binary Tree Postorder Traversal</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-postorder-traversal/">leetcode</a></p>
<p><strong>Recursion</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    result := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> result<br>    &#125;<br>    result = <span class="hljs-built_in">append</span>(result, postorderTraversal(root.Left)...)<br>    result = <span class="hljs-built_in">append</span>(result, postorderTraversal(root.Right)...)<br>    result = <span class="hljs-built_in">append</span>(result, root.Val)<br>    <span class="hljs-keyword">return</span> result    <br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Iteration</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    stack := []*TreeNode&#123;&#125;<br>    result := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root != <span class="hljs-literal">nil</span> &#123;<br>        stack = <span class="hljs-built_in">append</span>(stack, root)<br>    &#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack) &gt; <span class="hljs-number">0</span> &#123;<br>        node := stack[<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>        stack = stack[:<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> node != <span class="hljs-literal">nil</span> &#123;<br>            stack = <span class="hljs-built_in">append</span>(stack, node)<br>            stack = <span class="hljs-built_in">append</span>(stack, <span class="hljs-literal">nil</span>)<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                stack = <span class="hljs-built_in">append</span>(stack, node.Right)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                stack = <span class="hljs-built_in">append</span>(stack, node.Left)<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            node = stack[<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>            stack = stack[:<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>            result = <span class="hljs-built_in">append</span>(result, node.Val)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result <br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#590-n-ary-tree-postorder-traversal" class="header-anchor">#</a><span id="590-n-ary-tree-postorder-traversal"> 590. N-ary Tree Postorder Traversal</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/n-ary-tree-postorder-traversal/">leetcode</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a Node.</span><br><span class="hljs-comment"> * type Node struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Children []*Node</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">postorder</span><span class="hljs-params">(root *Node)</span></span> []<span class="hljs-type">int</span> &#123;<br>    result := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> result &#125;<br>    <span class="hljs-keyword">for</span> _, child := <span class="hljs-keyword">range</span> root.Children &#123;<br>        result = <span class="hljs-built_in">append</span>(result, postorder(child)...)<br>    &#125;<br>    result = <span class="hljs-built_in">append</span>(result, root.Val)<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#94-binary-tree-inorder-traversal" class="header-anchor">#</a><span id="94-binary-tree-inorder-traversal"> 94. Binary Tree Inorder Traversal</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-inorder-traversal/">leetcode</a></p>
<p><strong>Recursion</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    result := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> result<br>    &#125;<br>    result = <span class="hljs-built_in">append</span>(result, inorderTraversal(root.Left)...)<br>    result = <span class="hljs-built_in">append</span>(result, root.Val)<br>    result = <span class="hljs-built_in">append</span>(result, inorderTraversal(root.Right)...)<br>    <span class="hljs-keyword">return</span> result        <br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Iteration</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    stack := []*TreeNode&#123;&#125;<br>    result := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root != <span class="hljs-literal">nil</span> &#123;<br>        stack = <span class="hljs-built_in">append</span>(stack, root)<br>    &#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack) &gt; <span class="hljs-number">0</span> &#123;<br>        node := stack[<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>        stack = stack[:<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> node != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                stack = <span class="hljs-built_in">append</span>(stack, node.Right)<br>            &#125;<br>            stack = <span class="hljs-built_in">append</span>(stack, node)<br>            stack = <span class="hljs-built_in">append</span>(stack, <span class="hljs-literal">nil</span>)<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                stack = <span class="hljs-built_in">append</span>(stack, node.Left)<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            node = stack[<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>            stack = stack[:<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>            result = <span class="hljs-built_in">append</span>(result, node.Val)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result    <br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#102-binary-tree-level-order-traversal" class="header-anchor">#</a><span id="102-binary-tree-level-order-traversal"> 102. Binary Tree Level Order Traversal</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-level-order-traversal/">leetcode</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(root *TreeNode)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    queue := []*TreeNode&#123;&#125;<br>    result := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root != <span class="hljs-literal">nil</span> &#123;<br>        queue = <span class="hljs-built_in">append</span>(queue, root)<br>    &#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        size := <span class="hljs-built_in">len</span>(queue)<br>        vec := []<span class="hljs-type">int</span>&#123;&#125;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>            node := queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:]<br>            vec = <span class="hljs-built_in">append</span>(vec, node.Val)<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Right)<br>            &#125;<br>        &#125;<br>        result = <span class="hljs-built_in">append</span>(result, vec)<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#107-binary-tree-level-order-traversal-ii" class="header-anchor">#</a><span id="107-binary-tree-level-order-traversal-ii"> 107. Binary Tree Level Order Traversal II</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/">leetcode</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">levelOrderBottom</span><span class="hljs-params">(root *TreeNode)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    queue := []*TreeNode&#123;&#125;<br>    result := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root != <span class="hljs-literal">nil</span> &#123;<br>        queue = <span class="hljs-built_in">append</span>(queue, root)<br>    &#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        size := <span class="hljs-built_in">len</span>(queue)<br>        vec := []<span class="hljs-type">int</span>&#123;&#125;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>            node := queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:]<br>            vec = <span class="hljs-built_in">append</span>(vec, node.Val)<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Right)<br>            &#125;<br>        &#125;<br>        result = <span class="hljs-built_in">append</span>([][]<span class="hljs-type">int</span>&#123;vec&#125;, result...)<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Or</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">levelOrderBottom</span><span class="hljs-params">(root *TreeNode)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    queue := []*TreeNode&#123;&#125;<br>    result := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root != <span class="hljs-literal">nil</span> &#123;<br>        queue = <span class="hljs-built_in">append</span>(queue, root)<br>    &#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        size := <span class="hljs-built_in">len</span>(queue)<br>        vec := []<span class="hljs-type">int</span>&#123;&#125;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>            node := queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:]<br>            vec = <span class="hljs-built_in">append</span>(vec, node.Val)<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Right)<br>            &#125;<br>        &#125;<br>        result = <span class="hljs-built_in">append</span>(result, vec)<br>    &#125;<br>    <span class="hljs-keyword">for</span> i, j := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(result)<span class="hljs-number">-1</span>; i &lt; j; i, j = i+<span class="hljs-number">1</span>, j<span class="hljs-number">-1</span> &#123;<br>        result[i], result[j] = result[j], result[i]<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#199-binary-tree-right-side-view" class="header-anchor">#</a><span id="199-binary-tree-right-side-view"> 199. Binary Tree Right Side View</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-right-side-view/">leetcode</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rightSideView</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    queue := []*TreeNode&#123;&#125;<br>    result := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root != <span class="hljs-literal">nil</span> &#123;<br>        queue = <span class="hljs-built_in">append</span>(queue, root)<br>    &#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        size := <span class="hljs-built_in">len</span>(queue)<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>            node := queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:]<br>            <span class="hljs-keyword">if</span> i == size - <span class="hljs-number">1</span> &#123;<br>                result = <span class="hljs-built_in">append</span>(result, node.Val)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Right)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#637-average-of-levels-in-binary-tree" class="header-anchor">#</a><span id="637-average-of-levels-in-binary-tree"> 637. Average of Levels in Binary Tree</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/average-of-levels-in-binary-tree/">leetcode</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">averageOfLevels</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">float64</span> &#123;<br>    queue := []*TreeNode&#123;&#125;<br>    result := []<span class="hljs-type">float64</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root != <span class="hljs-literal">nil</span> &#123;<br>        queue = <span class="hljs-built_in">append</span>(queue, root)<br>    &#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        size := <span class="hljs-built_in">len</span>(queue)<br>        sum := <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>            node := queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:]<br>            sum += node.Val<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Right)<br>            &#125;<br>        &#125;<br>        result = <span class="hljs-built_in">append</span>(result, <span class="hljs-type">float64</span>(sum) / <span class="hljs-type">float64</span>(size))<br>    &#125;<br>    <span class="hljs-keyword">return</span> result  <br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#429-n-ary-tree-level-order-traversal" class="header-anchor">#</a><span id="429-n-ary-tree-level-order-traversal"> 429. N-ary Tree Level Order Traversal</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/n-ary-tree-level-order-traversal/">leetcode</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a Node.</span><br><span class="hljs-comment"> * type Node struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Children []*Node</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(root *Node)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    queue := []*Node&#123;&#125;<br>    result := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root != <span class="hljs-literal">nil</span> &#123;<br>        queue = <span class="hljs-built_in">append</span>(queue, root)<br>    &#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        size := <span class="hljs-built_in">len</span>(queue)<br>        vec := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, size)<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>            node := queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:]<br>            vec = <span class="hljs-built_in">append</span>(vec, node.Val)<br>            <span class="hljs-keyword">for</span> _, child := <span class="hljs-keyword">range</span> node.Children &#123;<br>                <span class="hljs-keyword">if</span> child != <span class="hljs-literal">nil</span> &#123;<br>                    queue = <span class="hljs-built_in">append</span>(queue, child)<br>                &#125;<br>            &#125;<br>        &#125;<br>        result = <span class="hljs-built_in">append</span>(result, vec)<br>    &#125;<br>    <span class="hljs-keyword">return</span> result     <br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#114-flatten-binary-tree-to-linked-list" class="header-anchor">#</a><span id="114-flatten-binary-tree-to-linked-list"> 114. Flatten Binary Tree to Linked List</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/">leetcode</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">flatten</span><span class="hljs-params">(root *TreeNode)</span></span>  &#123;<br>    stack := []*TreeNode&#123;&#125;<br>    list := []*TreeNode&#123;&#125;<br>    node := root<br>    <span class="hljs-keyword">for</span> node != <span class="hljs-literal">nil</span> || <span class="hljs-built_in">len</span>(stack) &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">for</span> node != <span class="hljs-literal">nil</span> &#123;<br>            list = <span class="hljs-built_in">append</span>(list, node)<br>            stack = <span class="hljs-built_in">append</span>(stack, node)<br>            node = node.Left<br>        &#125;<br>        node = stack[<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>        node = node.Right<br>        stack = stack[:<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(list); i++ &#123;<br>        prev, curr := list[i<span class="hljs-number">-1</span>], list[i]<br>        prev.Left, prev.Right = <span class="hljs-literal">nil</span>, curr<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#226-invert-binary-tree" class="header-anchor">#</a><span id="226-invert-binary-tree"> 226. Invert Binary Tree</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/invert-binary-tree/">leetcode</a></p>
<p><strong>Recursion</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">invertTree</span><span class="hljs-params">(root *TreeNode)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> root<br>    &#125;<br>    root.Left, root.Right = root.Right, root.Left<br>    invertTree(root.Left)<br>    invertTree(root.Right)<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Iteration</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">invertTree</span><span class="hljs-params">(root *TreeNode)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> root<br>    &#125;<br>    stack := []*TreeNode&#123;&#125;<br>    stack = <span class="hljs-built_in">append</span>(stack, root)<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack) &gt; <span class="hljs-number">0</span> &#123;<br>        node := stack[<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>        stack = stack[:<span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>]<br>        node.Left, node.Right = node.Right, node.Left<br>        <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>            stack = <span class="hljs-built_in">append</span>(stack, node.Right)<br>        &#125;<br>        <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>            stack = <span class="hljs-built_in">append</span>(stack, node.Left)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Level Order</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">invertTree</span><span class="hljs-params">(root *TreeNode)</span></span> *TreeNode &#123;<br>    queue := []*TreeNode&#123;&#125;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> root<br>    &#125;<br>    queue = <span class="hljs-built_in">append</span>(queue, root)<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        size := <span class="hljs-built_in">len</span>(queue)<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>            node := queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:]<br>            node.Left, node.Right = node.Right, node.Left<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Right)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#101-symmetric-tree" class="header-anchor">#</a><span id="101-symmetric-tree"> 101. Symmetric Tree</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/symmetric-tree/">leetcode</a></p>
<p><strong>Recursion</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">compare</span><span class="hljs-params">(left *TreeNode, right *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> right != <span class="hljs-literal">nil</span> &amp;&amp; left == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>    <span class="hljs-keyword">if</span> right == <span class="hljs-literal">nil</span> &amp;&amp; left != <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>    <span class="hljs-keyword">if</span> right == <span class="hljs-literal">nil</span> &amp;&amp; left == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125;<br>    <span class="hljs-keyword">if</span> right.Val != left.Val &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br><br>    outside := compare(left.Left, right.Right)<br>    inside := compare(left.Right, right.Left)<br>    <span class="hljs-keyword">return</span> outside &amp;&amp; inside<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125;<br>    <span class="hljs-keyword">return</span> compare(root.Left, root.Right)<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Iteration</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125;<br>    queue := []*TreeNode&#123;&#125;<br>    queue = <span class="hljs-built_in">append</span>(queue, root.Left)<br>    queue = <span class="hljs-built_in">append</span>(queue, root.Right)<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        left := queue[<span class="hljs-number">0</span>]; queue = queue[<span class="hljs-number">1</span>:]<br>        right := queue[<span class="hljs-number">0</span>]; queue = queue[<span class="hljs-number">1</span>:]<br>        <span class="hljs-keyword">if</span> left == <span class="hljs-literal">nil</span> &amp;&amp; right == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> left == <span class="hljs-literal">nil</span> || right == <span class="hljs-literal">nil</span> || left.Val != right.Val &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>        queue = <span class="hljs-built_in">append</span>(queue, left.Left)<br>        queue = <span class="hljs-built_in">append</span>(queue, right.Right)<br>        queue = <span class="hljs-built_in">append</span>(queue, left.Right)<br>        queue = <span class="hljs-built_in">append</span>(queue, right.Left)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#104-maximum-depth-of-binary-tree" class="header-anchor">#</a><span id="104-maximum-depth-of-binary-tree"> 104. Maximum Depth of Binary Tree</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">leetcode</a></p>
<p><strong>Recursion</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + max(maxDepth(root.Left), maxDepth(root.Right))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Iteration</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a Node.</span><br><span class="hljs-comment"> * type Node struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(root *Node)</span></span> <span class="hljs-type">int</span> &#123;<br>    queue := []*Node&#123;&#125;<br>    depth := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> depth &#125;<br>    queue = <span class="hljs-built_in">append</span>(queue, root)<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        size := <span class="hljs-built_in">len</span>(queue)<br>        depth++<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>            node := queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:]<br>            queue = <span class="hljs-built_in">append</span>(queue, node.Left)<br>            queue = <span class="hljs-built_in">append</span>(queue, node.Right)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> depth<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#559-maximum-depth-of-n-ary-tree" class="header-anchor">#</a><span id="559-maximum-depth-of-n-ary-tree"> 559. Maximum Depth of N-ary Tree</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-depth-of-n-ary-tree/">leetcode</a></p>
<p><strong>Recursion</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a Node.</span><br><span class="hljs-comment"> * type Node struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Children []*Node</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(root *Node)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    max := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, child := <span class="hljs-keyword">range</span> root.Children &#123;<br>        depth := maxDepth(child)<br>        <span class="hljs-keyword">if</span> depth &gt; max &#123;<br>            max = depth<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + max<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Iteration</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a Node.</span><br><span class="hljs-comment"> * type Node struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Children []*Node</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(root *Node)</span></span> <span class="hljs-type">int</span> &#123;<br>    queue := []*Node&#123;&#125;<br>    depth := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> depth &#125;<br>    queue = <span class="hljs-built_in">append</span>(queue, root)<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        size := <span class="hljs-built_in">len</span>(queue)<br>        depth++<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>            node := queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:]<br>            <span class="hljs-keyword">for</span> _, n := <span class="hljs-keyword">range</span> node.Children &#123;<br>                <span class="hljs-keyword">if</span> n != <span class="hljs-literal">nil</span> &#123;<br>                    queue = <span class="hljs-built_in">append</span>(queue, n)<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> depth<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#111-minimum-depth-of-binary-tree" class="header-anchor">#</a><span id="111-minimum-depth-of-binary-tree"> 111. Minimum Depth of Binary Tree</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-depth-of-binary-tree/">leetcode</a></p>
<p><strong>Recursion</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> &#125;<br>    leftDepth := minDepth(root.Left)<br>    rightDepth := minDepth(root.Right)<br><br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + rightDepth<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> root.Right == <span class="hljs-literal">nil</span> &amp;&amp; root.Left != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + leftDepth<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + min(leftDepth, rightDepth)    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Iteration</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    queue := []*TreeNode&#123;&#125;<br>    depth := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> depth &#125;<br>    queue = <span class="hljs-built_in">append</span>(queue, root)<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        size := <span class="hljs-built_in">len</span>(queue)<br>        depth++<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>            node := queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:]<br>            <span class="hljs-keyword">if</span> node.Left == <span class="hljs-literal">nil</span> &amp;&amp; node.Right == <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-keyword">return</span> depth<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Right)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> depth<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#222-count-complete-tree-nodes" class="header-anchor">#</a><span id="222-count-complete-tree-nodes"> 222. Count Complete Tree Nodes</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/count-complete-tree-nodes/">leetcode</a></p>
<p><strong>Recursion</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + countNodes(root.Left) + countNodes(root.Right)<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Iteration</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    queue := []*TreeNode&#123;&#125;<br>    count := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> count &#125;<br>    queue = <span class="hljs-built_in">append</span>(queue, root)<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        size := <span class="hljs-built_in">len</span>(queue)<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>            node := queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:]<br>            count++<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Right)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#110-balanced-binary-tree" class="header-anchor">#</a><span id="110-balanced-binary-tree"> 110. Balanced Binary Tree</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/balanced-binary-tree/submissions/">leetcode</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> x &gt; y &#123; <span class="hljs-keyword">return</span> x &#125;<br>    <span class="hljs-keyword">return</span> y<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">abs</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> -x<br>    &#125;<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">depth</span><span class="hljs-params">(node *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> &#125;<br>    leftDepth := depth(node.Left)<br>    <span class="hljs-keyword">if</span> leftDepth &lt; <span class="hljs-number">0</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span> &#125;<br>    rightDepth := depth(node.Right)<br>    <span class="hljs-keyword">if</span> rightDepth &lt; <span class="hljs-number">0</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span> &#125;<br>    <span class="hljs-keyword">if</span> abs(leftDepth - rightDepth) &gt; <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + min(leftDepth, rightDepth)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> depth(root) &gt;= <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#257-binary-tree-paths" class="header-anchor">#</a><span id="257-binary-tree-paths"> 257. Binary Tree Paths</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-paths/">leetcode</a></p>
<p>Simple preorder traversal.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> []<span class="hljs-type">string</span>&#123;&#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> path(root, <span class="hljs-string">&quot;&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">path</span><span class="hljs-params">(node *TreeNode, pathStr <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span>&#123;<br>    results := []<span class="hljs-type">string</span>&#123;&#125;<br>    pathStr += fmt.Sprintf(<span class="hljs-string">&quot;%d&quot;</span>, node.Val)<br>    <span class="hljs-keyword">if</span> node.Left == <span class="hljs-literal">nil</span> &amp;&amp; node.Right == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> []<span class="hljs-type">string</span>&#123;pathStr&#125;<br>    &#125;<br>    pathStr += <span class="hljs-string">&quot;-&gt;&quot;</span><br>    <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>        results = <span class="hljs-built_in">append</span>(results, path(node.Left, pathStr)...)<br>    &#125;<br>    <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>        results = <span class="hljs-built_in">append</span>(results, path(node.Right, pathStr)...)<br>    &#125;<br>    <span class="hljs-keyword">return</span> results<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#100-same-tree" class="header-anchor">#</a><span id="100-same-tree"> 100. Same Tree</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/same-tree/">leetcode</a></p>
<p><strong>Recursion</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isSameTree</span><span class="hljs-params">(p *TreeNode, q *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> p == <span class="hljs-literal">nil</span> &amp;&amp; q == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> p == <span class="hljs-literal">nil</span> &amp;&amp; q != <span class="hljs-literal">nil</span> || p != <span class="hljs-literal">nil</span> &amp;&amp; q == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> p != <span class="hljs-literal">nil</span> &amp;&amp; q != <span class="hljs-literal">nil</span> &amp;&amp; p.Val != q.Val &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> !isSameTree(p.Left, q.Left) || !isSameTree(p.Right, q.Right) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Iteration</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isSameTree</span><span class="hljs-params">(p *TreeNode, q *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    queue := []*TreeNode&#123;&#125;<br>    queue = <span class="hljs-built_in">append</span>(queue, p)<br>    queue = <span class="hljs-built_in">append</span>(queue, q)<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        left := queue[<span class="hljs-number">0</span>]; queue = queue[<span class="hljs-number">1</span>:]<br>        right := queue[<span class="hljs-number">0</span>]; queue = queue[<span class="hljs-number">1</span>:]<br>        <span class="hljs-keyword">if</span> left == <span class="hljs-literal">nil</span> &amp;&amp; right == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> left == <span class="hljs-literal">nil</span> || right == <span class="hljs-literal">nil</span> || left.Val != right.Val &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>        queue = <span class="hljs-built_in">append</span>(queue, left.Left)<br>        queue = <span class="hljs-built_in">append</span>(queue, right.Left)<br>        queue = <span class="hljs-built_in">append</span>(queue, left.Right)<br>        queue = <span class="hljs-built_in">append</span>(queue, right.Right)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#404-sum-of-left-leaves" class="header-anchor">#</a><span id="404-sum-of-left-leaves"> 404. Sum of Left Leaves</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sum-of-left-leaves/">leetcode</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sumOfLeftLeaves</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> &#125;<br>    sum := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> root.Left != <span class="hljs-literal">nil</span> &amp;&amp; root.Left.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Left.Right == <span class="hljs-literal">nil</span> &#123;<br>        sum = root.Left.Val<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum + sumOfLeftLeaves(root.Left) + sumOfLeftLeaves(root.Right)    <br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#513-find-bottom-left-tree-value" class="header-anchor">#</a><span id="513-find-bottom-left-tree-value"> 513. Find Bottom Left Tree Value</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-bottom-left-tree-value/">leetcode</a></p>
<p>Layer Order Traversal</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    queue := []*TreeNode&#123;root&#125;<br>    result := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        size := <span class="hljs-built_in">len</span>(queue)<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>            node := queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:]<br>            <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123; result = node.Val &#125;<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Right)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#112-path-sum" class="header-anchor">#</a><span id="112-path-sum"> 112. Path Sum</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/path-sum/">leetcode</a></p>
<p><strong>Recursion</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(root *TreeNode, targetSum <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &amp;&amp; root.Val == targetSum &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    nextSum := targetSum - root.Val<br>    <span class="hljs-keyword">return</span> hasPathSum(root.Left, nextSum) || hasPathSum(root.Right, nextSum)<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#113-path-sum-ii" class="header-anchor">#</a><span id="113-path-sum-ii"> 113. Path Sum II</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/path-sum-ii/">leetcode</a></p>
<p><strong>Recursion</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">traverse</span><span class="hljs-params">(root *TreeNode, targetSum <span class="hljs-type">int</span>, res *[][]<span class="hljs-type">int</span>, path[]<span class="hljs-type">int</span>)</span></span> &#123;<br>    path = <span class="hljs-built_in">append</span>(path, root.Val)<br>    nextSum := targetSum - root.Val<br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> nextSum == <span class="hljs-number">0</span> &#123;<br>            tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(path))<br>            <span class="hljs-built_in">copy</span>(tmp, path)<br>            *res = <span class="hljs-built_in">append</span>(*res, tmp)<br>        &#125;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> root.Left != <span class="hljs-literal">nil</span> &#123;<br>        traverse(root.Left, nextSum, res, path)<br>    &#125;<br>    <span class="hljs-keyword">if</span> root.Right != <span class="hljs-literal">nil</span> &#123;<br>        traverse(root.Right, nextSum, res, path)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(root *TreeNode, targetSum <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    result := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    path := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> result &#125;<br>    traverse(root, targetSum, &amp;result, path)<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#437-path-sum-iii" class="header-anchor">#</a><span id="437-path-sum-iii"> 437. Path Sum III</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/path-sum-iii/">leetcode</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(root *TreeNode, targetSum <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> pathSumFrom(root, targetSum) + pathSum(root.Left, targetSum) + pathSum(root.Right, targetSum)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pathSumFrom</span><span class="hljs-params">(node *TreeNode, currentSum <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    sum := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> node.Val == currentSum &#123;<br>        sum += <span class="hljs-number">1</span><br>    &#125;<br>    nextSum := currentSum - node.Val<br>    <span class="hljs-keyword">return</span> sum + pathSumFrom(node.Left, nextSum) + pathSumFrom(node.Right, nextSum)<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#106-construct-binary-tree-from-inorder-and-postorder-traversal" class="header-anchor">#</a><span id="106-construct-binary-tree-from-inorder-and-postorder-traversal"> 106. Construct Binary Tree from Inorder and Postorder Traversal</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">leetcode</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">traverse</span><span class="hljs-params">(inorder []<span class="hljs-type">int</span>, postorder []<span class="hljs-type">int</span>, inStart, inEnd, poStart, poEnd <span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> poStart == poEnd &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> &#125;<br>    rootVal := postorder[poEnd - <span class="hljs-number">1</span>]<br>    root := &amp;TreeNode&#123;Val: rootVal&#125;<br>    <span class="hljs-keyword">if</span> poEnd - poStart == <span class="hljs-number">1</span> &#123; <span class="hljs-keyword">return</span> root &#125;<br><br>    <span class="hljs-keyword">var</span> inMid <span class="hljs-type">int</span><br>    <span class="hljs-keyword">for</span> inMid = inStart; inMid &lt; inEnd; inMid++ &#123;<br>        <span class="hljs-keyword">if</span> inorder[inMid] == rootVal &#123; <span class="hljs-keyword">break</span> &#125;<br>    &#125;<br><br>    poMid := poStart + inMid - inStart<br>    root.Left = traverse(inorder, postorder, inStart, inMid, poStart, poMid)<br>    root.Right = traverse(inorder, postorder, inMid + <span class="hljs-number">1</span>, inEnd, poMid, poEnd - <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(inorder []<span class="hljs-type">int</span>, postorder []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">return</span> traverse(inorder, postorder, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(inorder), <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(postorder))<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#105-construct-binary-tree-from-preorder-and-inorder-traversal" class="header-anchor">#</a><span id="105-construct-binary-tree-from-preorder-and-inorder-traversal"> 105. Construct Binary Tree from Preorder and Inorder Traversal</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">leetcode</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">traverse</span><span class="hljs-params">(preorder []<span class="hljs-type">int</span>, inorder []<span class="hljs-type">int</span>, prStart, prEnd, inStart, inEnd <span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-comment">// fmt.Printf(&quot;%v %v %v %v\n&quot;, prStart, prEnd, inStart, inEnd)</span><br>    <span class="hljs-keyword">if</span> prStart == prEnd &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    val := preorder[prStart]<br>    root := &amp;TreeNode&#123;Val: val&#125;<br>    <span class="hljs-keyword">if</span> prEnd - prStart == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> root<br>    &#125;<br>    <br>    <span class="hljs-keyword">var</span> inMid <span class="hljs-type">int</span><br>    <span class="hljs-keyword">for</span> inMid = inStart; inMid &lt; inEnd; inMid++&#123;<br>        <span class="hljs-keyword">if</span> inorder[inMid] == val &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br>    <br>    prMid := prStart + <span class="hljs-number">1</span> + inMid - inStart<br>    root.Left = traverse(preorder, inorder, prStart+<span class="hljs-number">1</span>, prMid, inStart, inMid)<br>    root.Right = traverse(preorder, inorder, prMid, prEnd, inMid+<span class="hljs-number">1</span>, inEnd)<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(preorder []<span class="hljs-type">int</span>, inorder []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">return</span> traverse(preorder, inorder, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(preorder), <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(inorder))<br>&#125;<br></code></pre></td></tr></table></figure>
<p>More concise using slice.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(preorder []<span class="hljs-type">int</span>, inorder []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-comment">// fmt.Printf(&quot;%v | %v \n&quot;, preorder, inorder)</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(preorder) == <span class="hljs-number">0</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> &#125;<br>    rootVal := preorder[<span class="hljs-number">0</span>]<br>    root := &amp;TreeNode&#123;Val: rootVal&#125;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(preorder) == <span class="hljs-number">1</span> &#123; <span class="hljs-keyword">return</span> root &#125;<br><br>    <span class="hljs-keyword">var</span> inMid <span class="hljs-type">int</span><br>    <span class="hljs-keyword">for</span> inMid = <span class="hljs-number">0</span>; inMid &lt; <span class="hljs-built_in">len</span>(inorder); inMid++ &#123;<br>        <span class="hljs-keyword">if</span> inorder[inMid] == rootVal &#123; <span class="hljs-keyword">break</span> &#125;<br>    &#125;<br><br>    root.Left = buildTree(preorder[<span class="hljs-number">1</span>:<span class="hljs-number">1</span>+inMid], inorder[:inMid])<br>    root.Right = buildTree(preorder[<span class="hljs-number">1</span>+inMid:], inorder[inMid+<span class="hljs-number">1</span>:])<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#654-maximum-binary-tree" class="header-anchor">#</a><span id="654-maximum-binary-tree"> 654. Maximum Binary Tree</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-binary-tree/">leetcode</a></p>
<p><strong>Recursion</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">constructMaximumBinaryTree</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> &#125;<br>    max := nums[<span class="hljs-number">0</span>]<br>    index := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> nums &#123;<br>        <span class="hljs-keyword">if</span> v &gt; max &#123; <br>            max = v<br>            index = i<br>        &#125;<br>    &#125;<br>    root := &amp;TreeNode&#123;Val: max&#125;<br>    root.Left = constructMaximumBinaryTree(nums[:index])<br>    root.Right = constructMaximumBinaryTree(nums[index+<span class="hljs-number">1</span>:])<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Monotonic Stack</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">constructMaximumBinaryTree</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> &#125;<br>    stack := []*TreeNode&#123;&#125;<br>    <span class="hljs-keyword">var</span> last *TreeNode<br>    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack) &gt; <span class="hljs-number">0</span> &amp;&amp; stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>].Val &lt; num &#123;<br>            last = stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>            stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>        &#125;<br>        node := &amp;TreeNode&#123;Val: num&#125;<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack) &gt; <span class="hljs-number">0</span> &#123;<br>            stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>].Right = node<br>        &#125;<br>        <span class="hljs-keyword">if</span> last != <span class="hljs-literal">nil</span> &#123;<br>            node.Left = last<br>        &#125;<br>        stack = <span class="hljs-built_in">append</span>(stack, node)<br>        last = <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> stack[<span class="hljs-number">0</span>]<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#617-merge-two-binary-trees" class="header-anchor">#</a><span id="617-merge-two-binary-trees"> 617. Merge Two Binary Trees</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-two-binary-trees/">leetcode</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeTrees</span><span class="hljs-params">(root1 *TreeNode, root2 *TreeNode)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> root1 == <span class="hljs-literal">nil</span> &amp;&amp; root2 == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> root1 == <span class="hljs-literal">nil</span> &amp;&amp; root2 != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> root2<br>    &#125;<br>    <span class="hljs-keyword">if</span> root1 != <span class="hljs-literal">nil</span> &amp;&amp; root2 == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> root1<br>    &#125;<br>    root1.Val += root2.Val<br>    root1.Left = mergeTrees(root1.Left, root2.Left)<br>    root1.Right = mergeTrees(root1.Right, root2.Right)<br>    <span class="hljs-keyword">return</span> root1<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#700-search-in-a-binary-search-tree" class="header-anchor">#</a><span id="700-search-in-a-binary-search-tree"> 700. Search in a Binary Search Tree</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/search-in-a-binary-search-tree/">leetcode</a></p>
<p><strong>Recursion</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">searchBST</span><span class="hljs-params">(root *TreeNode, val <span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> &#125;<br>    <span class="hljs-keyword">if</span> root.Val &gt; val &#123; <span class="hljs-keyword">return</span> searchBST(root.Left, val) &#125;<br>    <span class="hljs-keyword">if</span> root.Val &lt; val &#123; <span class="hljs-keyword">return</span> searchBST(root.Right, val) &#125;<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Iteration</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">searchBST</span><span class="hljs-params">(root *TreeNode, val <span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">for</span> root != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> root.Val &gt; val &#123; <br>            root = root.Left<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> root.Val &lt; val &#123;<br>            root = root.Right<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> root<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#98-validate-binary-search-tree" class="header-anchor">#</a><span id="98-validate-binary-search-tree"> 98. Validate Binary Search Tree</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/validate-binary-search-tree/">leetcode</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> helper(root, math.MinInt64, math.MaxInt64)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">helper</span><span class="hljs-params">(root *TreeNode, lower, upper <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> root.Val &lt;= lower || root.Val &gt;= upper &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> helper(root.Left, lower, root.Val) &amp;&amp; helper(root.Right, root.Val, upper)<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#530-minimum-absolute-difference-in-bst" class="header-anchor">#</a><span id="530-minimum-absolute-difference-in-bst"> 530. Minimum Absolute Difference in BST</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-absolute-difference-in-bst/">leetcode</a></p>
<p><strong>Inorder Traversal</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">type</span> Searcher <span class="hljs-keyword">struct</span> &#123;<br>    min <span class="hljs-type">int</span><br>    last <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">abs</span><span class="hljs-params">(a <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> -a<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Searcher)</span></span>traverse(root *TreeNode) &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> &#125;<br>    s.traverse(root.Left)<br>    val := abs(root.Val - s.last)<br>    <span class="hljs-keyword">if</span> val &lt; s.min &#123;<br>        s.min = val<br>    &#125;<br>    s.last = root.Val<br>    s.traverse(root.Right)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMinimumDifference</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    s := Searcher&#123;math.MaxInt64, math.MaxInt64&#125;<br>    s.traverse(root)<br>    <span class="hljs-keyword">return</span> s.min<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Interval</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMinimumDifference</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> traverse(root, math.MinInt32, math.MaxInt32)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">traverse</span><span class="hljs-params">(node *TreeNode, lo, hi <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> hi - lo<br>    &#125;<br>    left := traverse(node.Left, lo, node.Val)<br>    right := traverse(node.Right, node.Val, hi)<br>    <span class="hljs-keyword">return</span> min(left, right)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#501-find-mode-in-binary-search-tree" class="header-anchor">#</a><span id="501-find-mode-in-binary-search-tree"> 501. Find Mode in Binary Search Tree</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-mode-in-binary-search-tree/">leetcode</a></p>
<p><strong>Inorder Traversal</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">type</span> Searcher <span class="hljs-keyword">struct</span> &#123;<br>    Last <span class="hljs-type">int</span><br>    Count <span class="hljs-type">int</span><br>    MaxCount <span class="hljs-type">int</span><br>    Modes []<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Searcher)</span></span>traverse(root *TreeNode) &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> &#125;<br>    s.traverse(root.Left)<br>    <span class="hljs-keyword">if</span> root.Val == s.Last &#123;<br>        s.Count++<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        s.Last = root.Val<br>        s.Count = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> s.Count &gt; s.MaxCount &#123;<br>        s.Modes = <span class="hljs-literal">nil</span><br>        s.Modes = <span class="hljs-built_in">append</span>(s.Modes, root.Val)<br>        s.MaxCount = s.Count<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> s.Count == s.MaxCount &#123;<br>        s.Modes = <span class="hljs-built_in">append</span>(s.Modes, root.Val)<br>    &#125;<br>    s.traverse(root.Right)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findMode</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    s := Searcher&#123;<br>        Last: <span class="hljs-number">0</span>,<br>        Count: <span class="hljs-number">0</span>,<br>        MaxCount: <span class="hljs-number">0</span>,<br>    &#125;<br>    s.traverse(root)<br>    <span class="hljs-keyword">return</span> s.Modes<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Hash Table</strong></p>
<p>But with extra space.</p>
<h2><a href="#236-lowest-common-ancestor-of-a-binary-tree" class="header-anchor">#</a><span id="236-lowest-common-ancestor-of-a-binary-tree"> 236. Lowest Common Ancestor of a Binary Tree</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/">leetcode</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(root, p, q *TreeNode)</span></span> *TreeNode &#123;<br>     <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>     &#125;<br>     <span class="hljs-keyword">if</span> root.Val == p.Val || root.Val == q.Val &#123;<br>         <span class="hljs-keyword">return</span> root<br>     &#125;<br>     left := lowestCommonAncestor(root.Left, p, q)<br>     right := lowestCommonAncestor(root.Right, p, q)<br>     <span class="hljs-keyword">if</span> left != <span class="hljs-literal">nil</span> &amp;&amp; right != <span class="hljs-literal">nil</span> &#123;<br>         <span class="hljs-keyword">return</span> root<br>     &#125;<br>     <span class="hljs-keyword">if</span> left == <span class="hljs-literal">nil</span> &amp;&amp; right != <span class="hljs-literal">nil</span> &#123;<br>         <span class="hljs-keyword">return</span> right<br>     &#125;<br>     <span class="hljs-keyword">if</span> left != <span class="hljs-literal">nil</span> &amp;&amp; right == <span class="hljs-literal">nil</span> &#123;<br>         <span class="hljs-keyword">return</span> left<br>     &#125;<br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#235-lowest-common-ancestor-of-a-binary-search-tree" class="header-anchor">#</a><span id="235-lowest-common-ancestor-of-a-binary-search-tree"> 235. Lowest Common Ancestor of a Binary Search Tree</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">leetcode</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val   int</span><br><span class="hljs-comment"> *     Left  *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(root, p, q *TreeNode)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> p.Val &lt; root.Val &amp;&amp; q.Val &lt; root.Val &#123;<br>        <span class="hljs-keyword">return</span> lowestCommonAncestor(root.Left, p, q)<br>    &#125;<br>    <span class="hljs-keyword">if</span> p.Val &gt; root.Val &amp;&amp; q.Val &gt; root.Val &#123;<br>        <span class="hljs-keyword">return</span> lowestCommonAncestor(root.Right, p, q)<br>    &#125;<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#1644-lowest-common-ancestor-of-a-binary-tree-ii" class="header-anchor">#</a><span id="1644-lowest-common-ancestor-of-a-binary-tree-ii"> 1644. Lowest Common Ancestor of a Binary Tree II</span></h2>
<p><a target="_blank" rel="noopener" href="https://chowdera.com/2021/08/20210815222753186d.html">chowdera</a></p>
<p>This similar to 236, except we have to</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-keyword">var</span> findp, findq <span class="hljs-type">bool</span><br> <span class="hljs-keyword">var</span> top *TreeNode<br><br> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(root, p, q *TreeNode)</span></span> *TreeNode &#123;<br>     <span class="hljs-keyword">if</span> top == <span class="hljs-literal">nil</span> &#123;<br>         top == root<br>     &#125;<br>     <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>     &#125;<br>     <span class="hljs-keyword">if</span> root.Val == p.Val || root.Val == q.Val &#123;<br>         <span class="hljs-keyword">return</span> root<br>     &#125;<br>     left := lowestCommonAncestor(root.Left, p, q)<br>     right := lowestCommonAncestor(root.Right, p, q)<br>     <span class="hljs-keyword">if</span> top == root &amp;&amp; !(findp &amp;&amp; findq) &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>     &#125;<br><br>     <span class="hljs-keyword">if</span> left != <span class="hljs-literal">nil</span> &amp;&amp; right != <span class="hljs-literal">nil</span> &#123;<br>         <span class="hljs-keyword">return</span> root<br>     &#125;<br>     <span class="hljs-keyword">if</span> left == <span class="hljs-literal">nil</span> &amp;&amp; right != <span class="hljs-literal">nil</span> &#123;<br>         <span class="hljs-keyword">return</span> right<br>     &#125;<br>     <span class="hljs-keyword">if</span> left != <span class="hljs-literal">nil</span> &amp;&amp; right == <span class="hljs-literal">nil</span> &#123;<br>         <span class="hljs-keyword">return</span> left<br>     &#125;<br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#1650-lowest-common-ancestor-of-a-binary-tree-iii" class="header-anchor">#</a><span id="1650-lowest-common-ancestor-of-a-binary-tree-iii"> 1650. Lowest Common Ancestor of a Binary Tree III</span></h2>
<p><a target="_blank" rel="noopener" href="https://chowdera.com/2021/08/20210815222753182Z.html">chowdera</a></p>
<p>The problem is equivalent to 160. Using a hash map to stop early.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> *     Parent *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(p, q *TreeNode)</span></span> *TreeNode &#123;<br>     <span class="hljs-keyword">if</span> p == <span class="hljs-literal">nil</span> || q == <span class="hljs-literal">nil</span> &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>     &#125;<br>     d := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*TreeNode]<span class="hljs-keyword">struct</span>&#123;&#125;)<br>     <span class="hljs-keyword">for</span> p != <span class="hljs-literal">nil</span> &#123;<br>         d[p] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>         p = p.Next<br>     &#125;<br>     <span class="hljs-keyword">for</span> q != <span class="hljs-literal">nil</span> &#123;<br>         <span class="hljs-keyword">if</span> p, exists := d[q]; exists &#123;<br>             <span class="hljs-keyword">return</span> p<br>         &#125;<br>         q = q.Next<br>     &#125;<br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br> &#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#1676-lowest-common-ancestor-of-a-binary-tree-iii" class="header-anchor">#</a><span id="1676-lowest-common-ancestor-of-a-binary-tree-iii"> 1676. Lowest Common Ancestor of a Binary Tree III</span></h2>
<p><a target="_blank" rel="noopener" href="https://chowdera.com/2021/08/20210816004852101k.html">leetcode</a></p>
<h2><a href="#701-insert-into-a-binary-search-tree" class="header-anchor">#</a><span id="701-insert-into-a-binary-search-tree"> 701. Insert into a Binary Search Tree</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/insert-into-a-binary-search-tree/">leetcode</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(root *TreeNode, val <span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> &amp;TreeNode&#123;Val: val&#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> val &lt; root.Val &#123;<br>        root.Left = insertIntoBST(root.Left, val)<br>    &#125;<br>    <span class="hljs-keyword">if</span> val &gt; root.Val &#123;<br>        root.Right = insertIntoBST(root.Right, val)<br>    &#125;<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#450-delete-node-in-a-bst" class="header-anchor">#</a><span id="450-delete-node-in-a-bst"> 450. Delete Node in a BST</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/delete-node-in-a-bst/">leetcode</a></p>
<ol start="0">
<li>Cannot find in tree.</li>
<li>If the node is leaf, just delete it. parent.left = null</li>
<li>If the right child is null, parent.left = node.left</li>
<li>If the left child is null, parent.left = node.right</li>
<li>If both the left and right child are not null, there two methods:
<ol>
<li>substitute with the least node in right sub-tree, this node is still larger than any node in the left sub-tree. How to find that node? This node is the most left node of right sub-tree.</li>
<li>hang the left sub-tree to the most left node of right sub-tree, this is equivalent to 3.</li>
</ol>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(root *TreeNode, key <span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> root &#125;<br>    <span class="hljs-keyword">if</span> root.Val == key &#123;<br>        <span class="hljs-keyword">if</span> root.Right == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> root.Left<br>        &#125;<br>        cur := root.Right<br>        <span class="hljs-keyword">for</span> cur.Left != <span class="hljs-literal">nil</span> &#123;<br>            cur = cur.Left<br>        &#125;<br>        root.Val, cur.Val = cur.Val, root.Val<br>    &#125;<br>    root.Left = deleteNode(root.Left, key)<br>    root.Right = deleteNode(root.Right, key)<br>    <span class="hljs-keyword">return</span> root    <br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#669-trim-a-binary-search-tree" class="header-anchor">#</a><span id="669-trim-a-binary-search-tree"> 669. Trim a Binary Search Tree</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/trim-a-binary-search-tree/">leetcode</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trimBST</span><span class="hljs-params">(root *TreeNode, low <span class="hljs-type">int</span>, high <span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> root &#125;<br>    <span class="hljs-keyword">if</span> root.Val &lt; low &#123;<br>        <span class="hljs-keyword">return</span> trimBST(root.Right, low, high)<br>    &#125;<br>    <span class="hljs-keyword">if</span> root.Val &gt; high &#123;<br>        <span class="hljs-keyword">return</span> trimBST(root.Left, low, high)<br>    &#125;<br>    root.Left = trimBST(root.Left, low, high)<br>    root.Right = trimBST(root.Right, low, high)<br>    <span class="hljs-keyword">return</span> root    <br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#108-convert-sorted-array-to-binary-search-tree" class="header-anchor">#</a><span id="108-convert-sorted-array-to-binary-search-tree"> 108. Convert Sorted Array to Binary Search Tree</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/">leetcode</a></p>
<p>Keep dividing the num array into two equal parts.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> &#125;<br>    mid := <span class="hljs-built_in">len</span>(nums) / <span class="hljs-number">2</span><br>    root := &amp;TreeNode&#123;Val: nums[mid]&#125;<br>    root.Left = sortedArrayToBST(nums[:mid])<br>    root.Right = sortedArrayToBST(nums[mid+<span class="hljs-number">1</span>:])<br>    <span class="hljs-keyword">return</span> root    <br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#109-convert-sorted-list-to-binary-search-tree" class="header-anchor">#</a><span id="109-convert-sorted-list-to-binary-search-tree"> 109. Convert Sorted List to Binary Search Tree</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/">leetcode</a></p>
<p><strong>108</strong></p>
<p>Converted to 108. And the time complexity is O(N) and the space complexity is O(N).</p>
<p><strong>Divide Conquer</strong></p>
<p>TC O(N) SC O(logN)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortedListToBST</span><span class="hljs-params">(head *ListNode)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> head.Next == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> &amp;TreeNode&#123;Val: head.Val&#125;<br>    &#125;<br>    slow, fast := head, head.Next.Next<br>    <span class="hljs-keyword">for</span> fast != <span class="hljs-literal">nil</span> &amp;&amp; fast.Next != <span class="hljs-literal">nil</span> &#123;<br>        fast = fast.Next.Next<br>        slow = slow.Next<br>    &#125;<br>    mid := slow.Next<br>    slow.Next = <span class="hljs-literal">nil</span><br>    root := &amp;TreeNode&#123;Val: mid.Val&#125;<br>    root.Left = sortedListToBST(head)<br>    root.Right = sortedListToBST(mid.Next)<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#1008-construct-binary-search-tree-from-preorder-traversal" class="header-anchor">#</a><span id="1008-construct-binary-search-tree-from-preorder-traversal"> 1008. Construct Binary Search Tree from Preorder Traversal</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/">leetcode</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bstFromPreorder</span><span class="hljs-params">(preorder []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(preorder) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    root := &amp;TreeNode&#123;Val: preorder[<span class="hljs-number">0</span>]&#125;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(preorder) == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> root<br>    &#125;<br>    <span class="hljs-keyword">var</span> mid <span class="hljs-type">int</span><br>    <span class="hljs-keyword">for</span> mid = <span class="hljs-number">1</span>; mid &lt; <span class="hljs-built_in">len</span>(preorder); mid++ &#123;<br>        <span class="hljs-keyword">if</span> preorder[mid] &gt; preorder[<span class="hljs-number">0</span>] &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br>    root.Left = bstFromPreorder(preorder[<span class="hljs-number">1</span>:mid])<br>    root.Right = bstFromPreorder(preorder[mid:])<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#449-serialize-and-deserialize-bst" class="header-anchor">#</a><span id="449-serialize-and-deserialize-bst"> 449. Serialize and Deserialize BST</span></h2>
<p>Use preorder traversal</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br></code></pre></td></tr></table></figure>
<h2><a href="#538-convert-bst-to-greater-tree" class="header-anchor">#</a><span id="538-convert-bst-to-greater-tree"> 538. Convert BST to Greater Tree</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/convert-bst-to-greater-tree/">leetcode</a></p>
<p>Simply use inverse inorder traversal.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">traverse</span><span class="hljs-params">(root *TreeNode, val <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> val &#125;<br>    val = traverse(root.Right, val)<br>    root.Val += val<br>    val = root.Val<br>    val = traverse(root.Left, val)<br>    <span class="hljs-keyword">return</span> val<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">convertBST</span><span class="hljs-params">(root *TreeNode)</span></span> *TreeNode &#123;<br>    traverse(root, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#99-recover-binary-search-tree" class="header-anchor">#</a><span id="99-recover-binary-search-tree"> 99. Recover Binary Search Tree</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/recover-binary-search-tree/">leetcode</a></p>
<p>The inorder traversal of binary search tree is monotonically increasing. Since there are only two nodes were swapped, they must be adjacent elements. Find out these two elements and swap them.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">var</span> first, second, prev *TreeNode<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">recoverTree</span><span class="hljs-params">(root *TreeNode)</span></span>  &#123;<br>    first = <span class="hljs-literal">nil</span><br>    second = <span class="hljs-literal">nil</span><br>    prev = &amp;TreeNode&#123;Val: math.MinInt32&#125;<br>    traverse(root)<br>    first.Val, second.Val = second.Val, first.Val<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">traverse</span><span class="hljs-params">(root *TreeNode)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    traverse(root.Left)<br>    <br>    <span class="hljs-keyword">if</span> first == <span class="hljs-literal">nil</span> &amp;&amp; prev.Val &gt; root.Val &#123;<br>        first = prev<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> first != <span class="hljs-literal">nil</span> &amp;&amp; prev.Val &gt; root.Val &#123;<br>        second = root<br>    &#125;<br>    <br>    prev = root<br>    <br>    traverse(root.Right)<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#103-binary-tree-zigzag-level-order-traversal" class="header-anchor">#</a><span id="103-binary-tree-zigzag-level-order-traversal"> 103. Binary Tree Zigzag Level Order Traversal</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/">leetcode</a></p>
<p>Use a new queue to store the nodes of the next layer.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">zigzagLevelOrder</span><span class="hljs-params">(root *TreeNode)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> [][]<span class="hljs-type">int</span>&#123;&#125;<br>    &#125;<br>    zig := <span class="hljs-literal">true</span><br>    queue := []*TreeNode&#123;root&#125;<br>    res := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        size := <span class="hljs-built_in">len</span>(queue)<br>        vec := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, size)<br>        nqueue := []*TreeNode&#123;&#125;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>            <span class="hljs-keyword">var</span> val <span class="hljs-type">int</span><br>            <span class="hljs-keyword">if</span> zig &#123;<br>                val = queue[i].Val <br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                val = queue[size<span class="hljs-number">-1</span>-i].Val<br>            &#125;<br>            vec = <span class="hljs-built_in">append</span>(vec, val)<br>            node := queue[i]<br>            <br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                nqueue = <span class="hljs-built_in">append</span>(nqueue, node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                nqueue = <span class="hljs-built_in">append</span>(nqueue, node.Right)<br>            &#125;<br>        &#125;<br>        queue = nqueue<br>        res = <span class="hljs-built_in">append</span>(res, vec)<br>        zig = !zig<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#1022-sum-of-root-to-leaf-binary-numbers" class="header-anchor">#</a><span id="1022-sum-of-root-to-leaf-binary-numbers"> 1022. Sum of Root To Leaf Binary Numbers</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/">leetcode</a></p>
<p>Using &lt;&lt;.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sumRootToLeaf</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> &#125;<br>    <span class="hljs-keyword">return</span> traverse(root, <span class="hljs-number">0</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">traverse</span><span class="hljs-params">(root *TreeNode, value <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> value &lt;&lt; <span class="hljs-number">1</span> + root.Val<br>    &#125;<br>    sum := <span class="hljs-number">0</span><br>    nextValue := value &lt;&lt; <span class="hljs-number">1</span> + root.Val<br>    <span class="hljs-keyword">if</span> root.Left != <span class="hljs-literal">nil</span> &#123;<br>        sum += traverse(root.Left, nextValue)<br>    &#125;<br>    <span class="hljs-keyword">if</span> root.Right != <span class="hljs-literal">nil</span> &#123;<br>        sum += traverse(root.Right, nextValue)<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#116-populating-next-right-pointers-in-each-node" class="header-anchor">#</a><span id="116-populating-next-right-pointers-in-each-node"> 116. Populating Next Right Pointers in Each Node</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/">leetcode</a></p>
<p><strong>Level Order Traversal</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a Node.</span><br><span class="hljs-comment"> * type Node struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *Node</span><br><span class="hljs-comment"> *     Right *Node</span><br><span class="hljs-comment"> *     Next *Node</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">connect</span><span class="hljs-params">(root *Node)</span></span> *Node &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> root<br>    &#125;<br>    queue := []*Node&#123;root&#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        size := <span class="hljs-built_in">len</span>(queue)<br>        <span class="hljs-keyword">var</span> prev *Node<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>            node := queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:]<br>            <span class="hljs-keyword">if</span> prev != <span class="hljs-literal">nil</span> &amp;&amp; i &lt; size &#123;<br>                prev.Next = node<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Right)<br>            &#125;<br>            prev = node<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>O(1) Space</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a Node.</span><br><span class="hljs-comment"> * type Node struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *Node</span><br><span class="hljs-comment"> *     Right *Node</span><br><span class="hljs-comment"> *     Next *Node</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">connect</span><span class="hljs-params">(root *Node)</span></span> *Node &#123;<br>    level_start := root<br>    <span class="hljs-keyword">for</span> level_start != <span class="hljs-literal">nil</span> &#123;<br>        cur := level_start<br>        <span class="hljs-keyword">for</span> cur != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">if</span> cur.Left != <span class="hljs-literal">nil</span> &#123;<br>                cur.Left.Next = cur.Right<br>            &#125;<br>            <span class="hljs-keyword">if</span> cur.Right != <span class="hljs-literal">nil</span> &amp;&amp; cur.Next != <span class="hljs-literal">nil</span> &#123;<br>                cur.Right.Next = cur.Next.Left<br>            &#125;<br>            cur = cur.Next<br>        &#125;<br>        level_start = level_start.Left<br>    &#125;<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#117-populating-next-right-pointers-in-each-node-ii" class="header-anchor">#</a><span id="117-populating-next-right-pointers-in-each-node-ii"> 117. Populating Next Right Pointers in Each Node II</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/">leetcode</a></p>
<p><strong>Level Order Traversal</strong> Same as 116.</p>
<p><strong>O(1) Space</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a Node.</span><br><span class="hljs-comment"> * type Node struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *Node</span><br><span class="hljs-comment"> *     Right *Node</span><br><span class="hljs-comment"> *     Next *Node</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">connect</span><span class="hljs-params">(root *Node)</span></span> *Node &#123;<br>    cur := &amp;Node&#123;Val: <span class="hljs-number">0</span>&#125;<br>    dummy := cur<br>    level := root<br>    <span class="hljs-keyword">for</span> level != <span class="hljs-literal">nil</span> &#123;<br>        cur.Next = level.Left<br>        <span class="hljs-keyword">if</span> cur.Next != <span class="hljs-literal">nil</span> &#123;<br>            cur = cur.Next<br>        &#125;<br>        cur.Next = level.Right<br>        <span class="hljs-keyword">if</span> cur.Next != <span class="hljs-literal">nil</span> &#123;<br>            cur = cur.Next<br>        &#125;<br>        level = level.Next<br>        <span class="hljs-keyword">if</span> level == <span class="hljs-literal">nil</span> &#123;<br>            cur = dummy<br>            level = dummy.Next<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#449-serialize-and-deserialize-bst" class="header-anchor">#</a><span id="449-serialize-and-deserialize-bst"> 449. Serialize and Deserialize BST</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/serialize-and-deserialize-bst/">leetcode</a></p>
<p>Borrow from 144 and 1008.</p>
<p>Be careful with make([]int, 0, 0), this will return a []int{0}</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">type</span> Codec <span class="hljs-keyword">struct</span> &#123;<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> Codec &#123;<br>    <span class="hljs-keyword">return</span> Codec&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// Serializes a tree to a single string.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Codec)</span></span> serialize(root *TreeNode) <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>    &#125;<br>    result := preorderTraversal(root)<br>    resultStr := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(result))<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> result &#123;<br>        resultStr = <span class="hljs-built_in">append</span>(resultStr, strconv.Itoa(result[i]))<br>    &#125;<br>    <span class="hljs-keyword">return</span> strings.Join(resultStr, <span class="hljs-string">&quot;,&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// Deserializes your encoded data to tree.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Codec)</span></span> deserialize(data <span class="hljs-type">string</span>) *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> data == <span class="hljs-string">&quot;&quot;</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    resultStr := strings.Split(data, <span class="hljs-string">&quot;,&quot;</span>)<br>    result := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(resultStr))<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> resultStr &#123;<br>        num, _ := strconv.Atoi(resultStr[i])<br>        result = <span class="hljs-built_in">append</span>(result, num)<br>    &#125;<br>    <span class="hljs-keyword">return</span> bstFromPreorder(result)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bstFromPreorder</span><span class="hljs-params">(preorder []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(preorder) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    root := &amp;TreeNode&#123;Val: preorder[<span class="hljs-number">0</span>]&#125;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(preorder) == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> root<br>    &#125;<br>    <span class="hljs-keyword">var</span> mid <span class="hljs-type">int</span><br>    <span class="hljs-keyword">for</span> mid = <span class="hljs-number">1</span>; mid &lt; <span class="hljs-built_in">len</span>(preorder); mid++ &#123;<br>        <span class="hljs-keyword">if</span> preorder[mid] &gt; preorder[<span class="hljs-number">0</span>] &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br>    root.Left = bstFromPreorder(preorder[<span class="hljs-number">1</span>:mid])<br>    root.Right = bstFromPreorder(preorder[mid:])<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    result := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> result<br>    &#125;<br>    result = <span class="hljs-built_in">append</span>(result, root.Val)<br>    result = <span class="hljs-built_in">append</span>(result, preorderTraversal(root.Left)...)<br>    result = <span class="hljs-built_in">append</span>(result, preorderTraversal(root.Right)...)<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Codec object will be instantiated and called as such:</span><br><span class="hljs-comment"> * ser := Constructor()</span><br><span class="hljs-comment"> * deser := Constructor()</span><br><span class="hljs-comment"> * tree := ser.serialize(root)</span><br><span class="hljs-comment"> * ans := deser.deserialize(tree)</span><br><span class="hljs-comment"> * return ans</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<h2><a href="#297-serialize-and-deserialize-binary-tree" class="header-anchor">#</a><span id="297-serialize-and-deserialize-binary-tree"> 297. Serialize and Deserialize Binary Tree</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/">leetcode</a></p>
<p>Using marshal &amp; unmarshal.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">type</span> Codec <span class="hljs-keyword">struct</span> &#123;<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> Codec &#123;<br>    <span class="hljs-keyword">return</span> Codec&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// Serializes a tree to a single string.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Codec)</span></span> serialize(root *TreeNode) <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-literal">nil</span> == root &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[]&quot;</span><br>    &#125;<br>    b, _ := json.Marshal(root)<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(b)<br>&#125;<br><br><span class="hljs-comment">// Deserializes your encoded data to tree.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Codec)</span></span> deserialize(data <span class="hljs-type">string</span>) *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;[]&quot;</span> == data &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">var</span> root TreeNode<br>    json.Unmarshal([]<span class="hljs-type">byte</span>(data), &amp;root)<br>    <span class="hljs-keyword">return</span> &amp;root<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Codec object will be instantiated and called as such:</span><br><span class="hljs-comment"> * ser := Constructor();</span><br><span class="hljs-comment"> * deser := Constructor();</span><br><span class="hljs-comment"> * data := ser.serialize(root);</span><br><span class="hljs-comment"> * ans := deser.deserialize(data);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<h2><a href="#652-find-duplicate-subtrees" class="header-anchor">#</a><span id="652-find-duplicate-subtrees"> 652. Find Duplicate Subtrees</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-duplicate-subtrees/">leetcode</a></p>
<p><strong>Hash Map Of Serialized String</strong></p>
<p>Time Complexity O(N^2)</p>
<p>Go through all the letters of that string. Each letter of this string is one node. Therefore, the first solution has a complexity of n ^ 2.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> res []*TreeNode<br><span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findDuplicateSubtrees</span><span class="hljs-params">(root *TreeNode)</span></span> []*TreeNode &#123;<br>    res = []*TreeNode&#123;&#125;<br>    m = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br>    postorder(root)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">postorder</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;#&quot;</span><br>    &#125;<br>    serial := fmt.Sprintf(<span class="hljs-string">&quot;%d&quot;</span>, root.Val) + <span class="hljs-string">&quot;,&quot;</span> + postorder(root.Left) + <span class="hljs-string">&quot;,&quot;</span> + postorder(root.Right)<br>    m[serial]++<br>    <span class="hljs-keyword">if</span> m[serial] == <span class="hljs-number">2</span> &#123;<br>        res = <span class="hljs-built_in">append</span>(res, root)<br>    &#125;<br>    <span class="hljs-keyword">return</span> serial<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Cache the subtree structure</strong></p>
<p>Time complexity decreased to O(N)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> res []*TreeNode<br><span class="hljs-keyword">var</span> serialToId <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> idToCount <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> id <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findDuplicateSubtrees</span><span class="hljs-params">(root *TreeNode)</span></span> []*TreeNode &#123;<br>    id = <span class="hljs-number">1</span><br>    res = []*TreeNode&#123;&#125;<br>    serialToId = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br>    idToCount = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br>    postorder(root)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">postorder</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    left := postorder(root.Left)<br>    right := postorder(root.Right)<br>    serial := fmt.Sprintf(<span class="hljs-string">&quot;%v,%v,%v&quot;</span>, left, root.Val, right)<br>    serialId, exists := serialToId[serial]<br>    <span class="hljs-keyword">if</span> !exists &#123;<br>        serialId = id<br>        serialToId[serial] = serialId<br>        id++<br>    &#125;<br>    idToCount[serialId]++<br>    <span class="hljs-keyword">if</span> idToCount[serialId] == <span class="hljs-number">2</span> &#123;<br>        res = <span class="hljs-built_in">append</span>(res, root)<br>    &#125;<br>    <span class="hljs-keyword">return</span> serialId<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#606-construct-string-from-binary-tree" class="header-anchor">#</a><span id="606-construct-string-from-binary-tree"> 606. Construct String from Binary Tree</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-string-from-binary-tree/">leetcode</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">tree2str</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>    &#125;<br>    curVal := fmt.Sprintf(<span class="hljs-string">&quot;%v&quot;</span>, root.Val)<br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> curVal<br>    &#125;<br>    left := <span class="hljs-string">&quot;(&quot;</span> + tree2str(root.Left) + <span class="hljs-string">&quot;)&quot;</span><br>    right := <span class="hljs-string">&quot;(&quot;</span> + tree2str(root.Right) + <span class="hljs-string">&quot;)&quot;</span><br>    res := curVal + left<br>    <span class="hljs-keyword">if</span> root.Right != <span class="hljs-literal">nil</span> &#123;<br>        res += right<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#124-binary-tree-maximum-path-sum" class="header-anchor">#</a><span id="124-binary-tree-maximum-path-sum"> 124. Binary Tree Maximum Path Sum</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-maximum-path-sum/">leetcode</a></p>
<p>Here’s the situations:</p>
<ol>
<li>If there’s only 1 node, return it’s value.</li>
<li>If there’s 2 nodes, return the sum of all non-negative nodes.</li>
<li>If there’s 1 root with two child, the maximum path sum can be the left gain + right gain + root.Val. And the max gain can be root.Val + max(left gain, right gain)</li>
<li>If the subtree’s gain is negative, there’s no need to consider it.</li>
<li>The null is considered as 0 gain.</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> maxPath <span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    maxPath = math.MinInt32<br>    getMaxGain(root)<br>    <span class="hljs-keyword">return</span> maxPath<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMaxGain</span><span class="hljs-params">(node *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    leftGain := max(getMaxGain(node.Left), <span class="hljs-number">0</span>)<br>    rightGain := max(getMaxGain(node.Right), <span class="hljs-number">0</span>)<br>    <br>    curPath := node.Val + leftGain + rightGain<br>    maxPath = max(maxPath, curPath)<br>    <br>    <span class="hljs-keyword">return</span> node.Val + max(leftGain, rightGain)<br>&#125;<br>                    <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#129-sum-root-to-leaf-numbers" class="header-anchor">#</a><span id="129-sum-root-to-leaf-numbers"> 129. Sum Root to Leaf Numbers</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sum-root-to-leaf-numbers/">leetcode</a></p>
<p>Simple dfs problem.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> sum <span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sumNumbers</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    sum = <span class="hljs-number">0</span><br>    dfs(root, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(root *TreeNode, curNumber <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    curNumber *= <span class="hljs-number">10</span><br>    curNumber += root.Val<br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;<br>        sum += curNumber<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    dfs(root.Left, curNumber)<br>    dfs(root.Right, curNumber)<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#988-smallest-string-starting-from-leaf" class="header-anchor">#</a><span id="988-smallest-string-starting-from-leaf"> 988. Smallest String Starting From Leaf</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/smallest-string-starting-from-leaf/">leetcode</a></p>
<p>Go support lexicographical comparison using &gt;, &lt; operations.</p>
<p><strong>Top-Down</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">smallestFromLeaf</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> traverse(root, <span class="hljs-string">&quot;&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">traverse</span><span class="hljs-params">(root *TreeNode, s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;|&quot;</span><br>    &#125;<br>    s = <span class="hljs-type">string</span>(<span class="hljs-type">int</span>(<span class="hljs-string">&#x27;a&#x27;</span>) + root.Val) + s<br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> s<br>    &#125;<br>    left := traverse(root.Left, s)<br>    right := traverse(root.Right, s)<br>    <span class="hljs-keyword">return</span> min(left, right)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#230-kth-smallest-element-in-a-bst" class="header-anchor">#</a><span id="230-kth-smallest-element-in-a-bst"> 230. Kth Smallest Element in a BST</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/">leetcode</a></p>
<p>Use inorder traversal.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> count <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> res <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> target <span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(root *TreeNode, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    res = <span class="hljs-number">0</span><br>    count = <span class="hljs-number">0</span><br>    target = k<br>    traverse(root)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">traverse</span><span class="hljs-params">(root *TreeNode)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    traverse(root.Left)<br>    <span class="hljs-keyword">if</span> count == target &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    count++<br>    <span class="hljs-keyword">if</span> count == target &#123;<br>        res = root.Val<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    traverse(root.Right)<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><a href="#671-second-minimum-node-in-a-binary-tree" class="header-anchor">#</a><span id="671-second-minimum-node-in-a-binary-tree"> 671. Second Minimum Node In a Binary Tree</span></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/">leetcode</a></p>
<p>Divide and conquer</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findSecondMinimumValue</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br>    left := root.Left.Val<br>    right := root.Right.Val<br>    <br>    <span class="hljs-keyword">if</span> root.Left.Val == root.Val &#123;<br>        left = findSecondMinimumValue(root.Left)<br>    &#125;<br>    <span class="hljs-keyword">if</span> root.Right.Val == root.Val &#123;<br>        right = findSecondMinimumValue(root.Right)<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> left != <span class="hljs-number">-1</span> &amp;&amp; right != <span class="hljs-number">-1</span> &#123;<br>        <span class="hljs-keyword">return</span> min(left, right)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> left != <span class="hljs-number">-1</span> &#123;<br>        <span class="hljs-keyword">return</span> left<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> right<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure></p></div><div class="share"><span>Share</span>&nbsp;<span class="soc"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></span><span class="soc"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></span><span class="soc"><a target="_blank" rel="noopener" href="http://twitter.com/home?status=https://blog.kleon.space/interview/code/tree/%20KLEON%20Code - Tree" class="fa fa-twitter"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/interview/system/" title="System Design"><i class="fa fa-angle-double-left"></i>&nbsp;Previous post: System Design</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/interview/code/array/" title="Code - Array">Next post: Code - Array&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2022&nbsp;<a target="_blank" href="https://blog.kleon.space" rel="noopener noreferrer">Kleon</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>